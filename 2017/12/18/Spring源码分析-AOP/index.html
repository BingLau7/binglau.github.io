<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Spring,Java," />





  <link rel="alternate" href="/atom.xml" title="村里最好的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="动态 AOP 使用示例 创建用于拦截的 bean 12345678@Datapublic class TestBean &amp;#123;    private String testStr = &quot;test&quot;;    public void test() &amp;#123;        Sys">
<meta name="keywords" content="Spring,Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码分析-AOP">
<meta property="og:url" content="http://yoursite.com/2017/12/18/Spring源码分析-AOP/index.html">
<meta property="og:site_name" content="村里最好的博客">
<meta property="og:description" content="动态 AOP 使用示例 创建用于拦截的 bean 12345678@Datapublic class TestBean &amp;#123;    private String testStr = &quot;test&quot;;    public void test() &amp;#123;        System.out.println(&quot;test&quot;);    &amp;#125;&amp;#125;  创建 Advisor 12345">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/BingLau7/blog/blob/master/images/blog_41/AnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg?raw=true">
<meta property="og:image" content="https://github.com/BingLau7/blog/blob/master/images/blog_41/Advice%20%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?raw=true">
<meta property="og:updated_time" content="2017-12-18T14:29:08.713Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring源码分析-AOP">
<meta name="twitter:description" content="动态 AOP 使用示例 创建用于拦截的 bean 12345678@Datapublic class TestBean &amp;#123;    private String testStr = &quot;test&quot;;    public void test() &amp;#123;        System.out.println(&quot;test&quot;);    &amp;#125;&amp;#125;  创建 Advisor 12345">
<meta name="twitter:image" content="https://github.com/BingLau7/blog/blob/master/images/blog_41/AnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg?raw=true">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/18/Spring源码分析-AOP/"/>





  <title>Spring源码分析-AOP | 村里最好的博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">村里最好的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/18/Spring源码分析-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/BingLau7/blog/blob/master/images/drunktocat.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring源码分析-AOP</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-18T22:28:01+08:00">
                2017-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="动态-AOP-使用示例"><a href="#动态-AOP-使用示例" class="headerlink" title="动态 AOP 使用示例"></a>动态 AOP 使用示例</h2><ol>
<li><p>创建用于拦截的 bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String testStr = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 Advisor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* *.test(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beforeTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundTest</span><span class="params">(ProceedingJoinPoint p)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"brfore around"</span>);</span><br><span class="line">        Object o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            o = p.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after around"</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.bean.TestBean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.AspectJTest"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beanFactory.xml"</span>);</span><br><span class="line">    TestBean bean = (TestBean) ctx.getBean(<span class="string">"testBean"</span>);</span><br><span class="line">    bean.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不出意外结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brfore around</span><br><span class="line">beforeTest</span><br><span class="line">test</span><br><span class="line">after around</span><br><span class="line">afterTest</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可知 <code>&lt;aop:aspectj-autoproxy /&gt;</code> 是开启 aop 的关键，我们不妨由此入手。</p>
<a id="more"></a>
<h2 id="动态-AOP-自定义标签"><a href="#动态-AOP-自定义标签" class="headerlink" title="动态 AOP 自定义标签"></a>动态 AOP 自定义标签</h2><p>之前讲过 Spring 中的<a href="https://binglau7.github.io/2017/11/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-bean%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/" target="_blank" rel="noopener">自定义注解</a>，如果声明了自定义的注解，那么就一定会在程序中的某个地方注册了对应的解析器。我们搜索整个代码，尝试找到注册的地方，全局搜索后我们发现了在 <code>AopNamespaceHandler</code> 中对应着这样一段函数。中间我们看到了 <code>aspectj-autoproxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">	registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">	registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">	registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only in 2.0 XSD: moved to context namespace as of 2.1</span></span><br><span class="line">	registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册-AnnotationAwareAspectJAutoProxyCreator"><a href="#注册-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="注册 AnnotationAwareAspectJAutoProxyCreator"></a>注册 <code>AnnotationAwareAspectJAutoProxyCreator</code></h3><p>所有解析器，因为是对 <code>BeanDefinitionParser</code> 接口的统一实现，入口都是从 <code>parse</code> 函数开始的，<code>AspectJAutoProxyBeanDefinitionParser</code> 的 <code>parse</code> 函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">	AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">        <span class="comment">// 对于注解中子类的处理</span></span><br><span class="line">	extendBeanDefinition(element, parserContext);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>registerAspectJAnnotationAutoProxyCreatorIfNecessary</code> 很明显值得注意，这也是其关键逻辑的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册或升级 AutoProxyCreator 定义 beanName 为 org.Springframework.aop.config.internalAutoProxyCreator 的 BeanDefinition</span></span><br><span class="line">	BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">			parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">        <span class="comment">// 对于 proxy-target-class 以及 expose-proxy 属性的处理</span></span><br><span class="line">	useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">        <span class="comment">// 注册组件并通知，便于监听器做进一步处理</span></span><br><span class="line">        <span class="comment">// 其中 beanDefinition 的 className 为 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">	registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册或者升级-AnnotationAwareAspectJAutoProxyCreator"><a href="#注册或者升级-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="注册或者升级 AnnotationAwareAspectJAutoProxyCreator"></a>注册或者升级 <code>AnnotationAwareAspectJAutoProxyCreator</code></h4><p>对于 AOP 的实现，基本上都是靠 <code>AnnotationAwareAspectJAutoProxyCreator</code> 去完成，它可以根据 <code>@Point</code> 注解定义的切点来自动代理相匹配的 bean。但是为了配置简便，Spring 使用了自定义配置来帮助我们自动注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> ，其注册过程就是在这里实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> registerOrEscalateApcAsRequired(**AnnotationAwareAspectJAutoProxyCreator**.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">        <span class="comment">// 如果已经存在了自动代理创建器且存在的自动代理创建器与现状的不一致那么需要根据优先级来判断</span></span><br><span class="line">        <span class="comment">// 到底需要使用哪个</span></span><br><span class="line">	<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="comment">// 	public static final String AUTO_PROXY_CREATOR_BEAN_NAME =</span></span><br><span class="line">            <span class="comment">//  "org.springframework.aop.config.internalAutoProxyCreator";</span></span><br><span class="line">		BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">		<span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">			<span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">			<span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">			<span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                     <span class="comment">// 改变 bean 最重要的就是改变 bean 所对应的 className 属性</span></span><br><span class="line">				apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">            <span class="comment">// 如果已经存在自动代理创建器并且与将要创建的一直，那么无需再次创建</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">	beanDefinition.setSource(source);</span><br><span class="line">	beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">	beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">	registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">	<span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中实现了自动注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类的功能，同时这里还涉及了一个优先级的问题，如果已经存在了自动代理创建器，而且存在的自动代理创建器与现在的不一致，那么需要根据优先级来判断到底需要使用哪个。</p>
<h4 id="处理-proxy-target-class-以及-expose-proxy-属性"><a href="#处理-proxy-target-class-以及-expose-proxy-属性" class="headerlink" title="处理 proxy-target-class 以及 expose-proxy 属性"></a>处理 proxy-target-class 以及 expose-proxy 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Element sourceElement)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对于 proxy-target-class 属性的处理</span></span><br><span class="line">		<span class="keyword">boolean</span> proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">		<span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">		&#125;</span><br><span class="line">            <span class="comment">// 对于 expose-proxy 属性的处理</span></span><br><span class="line">		<span class="keyword">boolean</span> exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">		<span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制使用的过程其实也是一个属性设置的过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceAutoProxyCreatorToUseClassProxying</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">		BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">		definition.getPropertyValues().add(<span class="string">"proxyTargetClass"</span>, Boolean.TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceAutoProxyCreatorToExposeProxy</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">		BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">		definition.getPropertyValues().add(<span class="string">"exposeProxy"</span>, Boolean.TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="proxy-target-class"><a href="#proxy-target-class" class="headerlink" title="proxy-target-class"></a>proxy-target-class</h5><p>Spring AOP 部分使用 <strong>JDK 动态代理</strong>或者 <strong>CGLIB</strong> 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理），<strong>如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。</strong>所有该目标类型实现的接口都将被代理。<strong>若该目标对象没有实现任何接口，则创建一个CGLIB代理。</strong>如果你希望强制使用CGLIB代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个问题。</p>
<ul>
<li>无法通知（advise）Final 方法，因为它们不能被覆写。</li>
<li>你需要将CGLIB二进制发行包放在classpath下面。</li>
</ul>
<p>如果需要强制使用 CGLIB 代理，则需要将 <code>&lt;aop:config&gt;</code> 的 <code>proxy-target-class</code> 属性设为 true:</p>
<p><code>&lt;aop:config proxy-target-class=&quot;true&quot;&gt; ... &lt;/aop:config&gt;</code></p>
<p>当需要使用 CGLIB 代理和 <code>@AspectJ</code> 自动代理支持，可以按照以下方式设置 <code>&lt;aop:aspectj-autoproxy&gt;</code> 的 <code>proxy-target-class</code> 属性：</p>
<p><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></p>
<h5 id="JDK-动态代理-vs-CGLIB-代理"><a href="#JDK-动态代理-vs-CGLIB-代理" class="headerlink" title="JDK 动态代理 vs CGLIB 代理"></a>JDK 动态代理 vs CGLIB 代理</h5><ul>
<li>JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。</li>
<li>CGLIB 代理：实现原理类似于 JDK 动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的Java字节码编辑类库）操作字节码实现的，性能比JDK强。</li>
</ul>
<p>具体可以看之前的博客 <a href="https://binglau7.github.io/2017/06/11/AOP%E7%9A%84%E9%81%93%E7%90%86/" target="_blank" rel="noopener">AOP 的道理</a></p>
<h5 id="expose-proxy"><a href="#expose-proxy" class="headerlink" title="expose-proxy"></a>expose-proxy</h5><p>有时候目标对象内部的自我调用将无法实施切面中的增强，如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl1</span> <span class="keyword">implements</span> <span class="title">AService</span></span>&#123;</span><br><span class="line">	<span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.b();</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的 this 指向目标对象，因此调用 <code>this.b()</code> 将不会执行 b 事务切面，即不会执行事务增强，因此 b 方法的事务定义<code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>将不会实施，为了解决这个问题，我们可以这样做：</p>
<p><code>&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;/&gt;</code></p>
<p>然后将以上代码中的 <code>this.b();</code> 修改为 <code>((AService) AopContext.currentProxy()).b();</code> 即可。通过以上的修改便可以完成对 a 和 b 方法的同时增强。</p>
<p>最后注册组件并通知，便于监听器做进一步处理，这里就不再一一赘述了。</p>
<h2 id="创建-AOP-代理"><a href="#创建-AOP-代理" class="headerlink" title="创建 AOP 代理"></a>创建 AOP 代理</h2><p>上文讲解了通过自定义配置完成了对 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类型的自动注册，那么这个类到底做了什么工作来完成 AOP 的操作呢？</p>
<p>首先让我们看看 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类的层次结构</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_41/AnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg?raw=true" alt="AnnotationAwareAspectJAutoProxyCreator类的层次结构图"></p>
<p>我们看到 <code>AnnotationAwareAspectJAutoProxyCreator</code> 实现了 <code>BeanPostProcessor</code> 接口，而实现了该接口之后，当 Spring 加载这个 Bean 时会在实例化之前调用其 <code>postProcessAfterInitialization</code> 方法，其逻辑也由此开始。</p>
<p>其父类 <code>AbstractAutoProxyCreator#postProcessAfterInitialization</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据给定的 bean 的 class 和 name 构建出个 key，格式: beanClassName_beanName</span></span><br><span class="line">	Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 bean 不存在的一些处理或者这个 bean 无需增强</span></span><br><span class="line">	<span class="keyword">if</span> (beanName == <span class="keyword">null</span> || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">            <span class="comment">// 跳过一些特殊的类</span></span><br><span class="line">		<span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line">	<span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line">	<span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">	<span class="keyword">if</span> (beanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">		TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">		<span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">                 <span class="comment">// 如果存在增强方法则创建代理</span></span><br><span class="line">			Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">                 <span class="comment">// 创建代理</span></span><br><span class="line">			Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			<span class="keyword">return</span> proxy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致主流程氛围三步（判断条件走完之后）：</p>
<ol>
<li>获取需要增强的 targetSource</li>
<li>获取增强器</li>
<li>根据需要增强的 targetSource 和增强器创建代理​</li>
</ol>
<h3 id="获取-targetSource"><a href="#获取-targetSource" class="headerlink" title="获取 targetSource"></a>获取 targetSource</h3><blockquote>
<p> 这部分代码与书上不符，属于多出来的步骤</p>
</blockquote>
<p>这里顺便贴出 TargetSource 的说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> TargetSource&#125; is used to obtain the current "target" of</span></span><br><span class="line"><span class="comment"> * an AOP invocation, which will be invoked via reflection if no around</span></span><br><span class="line"><span class="comment"> * advice chooses to end the interceptor chain itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a &#123;<span class="doctag">@code</span> TargetSource&#125; is "static", it will always return</span></span><br><span class="line"><span class="comment"> * the same target, allowing optimizations in the AOP framework. Dynamic</span></span><br><span class="line"><span class="comment"> * target sources can support pooling, hot swapping, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Application developers don't usually need to work with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> TargetSources&#125; directly: this is an AOP framework interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这里可以看，TargetSource 是用来获取调用 AOP 的那个当前『目标』。每当AOP代理处理一个方法调用时都会向TargetSource 的实现请求一个目标实例。</p>
<p>使用 Spring AOP 的开发者通常不需要直接和 TargetSource 打交道，但这提供了一种强大的方式来支持池化（pooling），热交换（hot swappable）和其它高级目标。 例如，一个使用池来管理实例的 TargetSource 可以为每个调用返回一个不同的目标实例。</p>
<p>如果你不指定一个TargetSource，一个缺省实现将被使用，它包装一个本地对象。对于每次调用它将返回相同的目标（像你期望的那样）。</p>
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-targetsource" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a target source for bean instances. Uses any TargetSourceCreators if set.</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> null&#125; if no custom TargetSource should be used.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation uses the "customTargetSourceCreators" property.</span></span><br><span class="line"><span class="comment"> * Subclasses can override this method to use a different mechanism.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the class of the bean to create a TargetSource for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a TargetSource for this bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setCustomTargetSourceCreators</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TargetSource <span class="title">getCustomTargetSource</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// We can't create fancy target sources for directly registered singletons.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.customTargetSourceCreators != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">			<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.beanFactory.containsBean(beanName)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (TargetSourceCreator tsc : <span class="keyword">this</span>.customTargetSourceCreators) &#123;</span><br><span class="line">			TargetSource ts = tsc.getTargetSource(beanClass, beanName);</span><br><span class="line">			<span class="keyword">if</span> (ts != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Found a matching TargetSource.</span></span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"TargetSourceCreator ["</span> + tsc +</span><br><span class="line">							<span class="string">" found custom TargetSource for bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> ts;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No custom TargetSource found.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取增强器"><a href="#获取增强器" class="headerlink" title="获取增强器"></a>获取增强器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">	List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于指定 bean 的增强方法的获取一定是包含两个步骤的，获取所有的增强以及寻找所有增强中适用于 bean 的增强并应用，那么 <code>findCandidateAdvisors</code> 与 <code>findAdvisorsThatCanApply</code> 便是做了这两件事情。当然，如果无法找到对应的增强器便返回  null。</p>
<p>由于我们分析的是使用注解进行的 AOP，所以对于 <code>findCandidateAdvisors</code> 的实现其实是由 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类完成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">        <span class="comment">// 当使用注解方式配置 AOP 的时候并不是丢弃了对 XML 配置的支持</span></span><br><span class="line">        <span class="comment">// 在这里调用父类方法加载配置文件中的 AOP 声明</span></span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">	<span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">	advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code> 间接继承了 <code>AbstractAdvisorAutoProxyCreator</code>，在实现获取增强的方法中除了保留父类的获取配置文件中定义的增强外，同时添加了获取 Bean 的注解增强的功能，那么其实现正是由<code>this.aspectJAdvisorsBuilder.buildAspectJAdvisors()</code>来实现的。</p>
<p>首先在没有接触代码的情况下，让我们理一下思路，看看增强器解析步骤</p>
<ol>
<li>获取所有 beanName，这一步骤中所有再 beanFactory 中注册的 Bean 都会被提取出来</li>
<li>遍历所有 beanName，并找出声明 AspectJ 注解的类，进行进一步处理</li>
<li>对标记为 AspectJ 注解的类进行增强器的提取</li>
<li>将提取结果加入缓存</li>
</ol>
<p>接下来看看实现，首先是对 Spring 中所有类进行分析，提取 Advisor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look for AspectJ-annotated aspect beans in the current bean factory,</span></span><br><span class="line"><span class="comment"> * and return to a list of Spring AOP Advisors representing them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Creates a Spring Advisor for each AspectJ advice method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the list of &#123;<span class="doctag">@link</span> org.springframework.aop.Advisor&#125; beans</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isEligibleBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">			<span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">				List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">				aspectNames = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">                     <span class="comment">// 获取所有 beanName</span></span><br><span class="line">				String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">						<span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                     <span class="comment">// 循环所有的 beanName 找出对应的增强方法</span></span><br><span class="line">				<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                          <span class="comment">// 不合法的 bean 则略过，由子类定义规则，默认返回 true</span></span><br><span class="line">					<span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line">					<span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">                         <span class="comment">// 获取对应的 bean 的类型</span></span><br><span class="line">					Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">					<span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">                         <span class="comment">// 如果存在 Aspect 注解</span></span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">						aspectNames.add(beanName);</span><br><span class="line">						AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">						<span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">							MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">									<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                                  <span class="comment">// 解析标记 AspectJ 注解中的增强方法</span></span><br><span class="line">							List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">							<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">								<span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">							&#125;</span><br><span class="line">							advisors.addAll(classAdvisors);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="comment">// Per target or per this.</span></span><br><span class="line">							<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">								<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">										<span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">							&#125;</span><br><span class="line">							MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">									<span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">							<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">							advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">				<span class="keyword">return</span> advisors;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">	&#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 记录在缓存中</span></span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">		List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">		<span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisors.addAll(cachedAdvisors);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">			advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们已经完成了 Advisor 的提取，其中增强器获取的工作委托给了 <code>getAdvisors</code> 方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取标记为 AspectJ 的类</span></span><br><span class="line">	Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        <span class="comment">// 获取标记为 AspectJ 的 name</span></span><br><span class="line">	String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">        <span class="comment">// 验证</span></span><br><span class="line">	validate(aspectClass);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">	<span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">	MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">			<span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">		Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">		<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisors.add(advisor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">	<span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">         	 <span class="comment">// 如果寻找的增强器不为空而且又配置了增强延迟初始化那么需要在首位加入同步实例化增强器</span></span><br><span class="line">		Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">		advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find introduction fields.</span></span><br><span class="line">     	 <span class="comment">// 获取 DeclareParents 注解</span></span><br><span class="line">	<span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">		Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">		<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisors.add(advisor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAdvisorMethods</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> List&lt;Method&gt; methods = <span class="keyword">new</span> LinkedList&lt;Method&gt;();</span><br><span class="line">	ReflectionUtils.doWithMethods(aspectClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">			<span class="comment">// Exclude pointcuts</span></span><br><span class="line">                 <span class="comment">// 对声明为 pointcut 的方法不处理</span></span><br><span class="line">			<span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">				methods.add(method);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	Collections.sort(methods, METHOD_COMPARATOR);</span><br><span class="line">	<span class="keyword">return</span> methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普通增强器的获取"><a href="#普通增强器的获取" class="headerlink" title="普通增强器的获取"></a>普通增强器的获取</h4><p>普通增强器的获取逻辑通过 <code>getAdvisor</code> 方法实现，实现步骤包括对切点的注解的获取以及根据注解信息生成增强</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">     	 <span class="comment">// 切点信息获取</span></span><br><span class="line">	AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">			candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">	<span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">// 根据切点信息生成增强器</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">			<span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="切点信息获取"><a href="#切点信息获取" class="headerlink" title="切点信息获取"></a>切点信息获取</h5><p>所谓获取切点信息就是制定注解的表达式信息的获取，如 <code>@Before(&quot;test()&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取方法上的注解</span></span><br><span class="line">	AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">			AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">	<span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 AspectJExpressionPointcut 实例封装获取的信息</span></span><br><span class="line">	AspectJExpressionPointcut ajexp =</span><br><span class="line">			<span class="keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 提取得到的注解中的表达式，如</span></span><br><span class="line">        <span class="comment">// @Pointcut("execution(* *.*test*(..))") 中的 execution(* *.*test*(..))</span></span><br><span class="line">	ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">	ajexp.setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">	<span class="keyword">return</span> ajexp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">        <span class="comment">// 设置敏感的注解类</span></span><br><span class="line">	Class&lt;?&gt;[] classesToLookFor = <span class="keyword">new</span> Class&lt;?&gt;[] &#123;</span><br><span class="line">			Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class="line">		AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class="line">		<span class="keyword">if</span> (foundAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> foundAnnotation;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定方法上的注解并使用 AspectJAnnotation 封装</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;A extends Annotation&gt; <span class="function">AspectJAnnotation&lt;A&gt; <span class="title">findAnnotation</span><span class="params">(Method method, Class&lt;A&gt; toLookFor)</span> </span>&#123;</span><br><span class="line">	A result = AnnotationUtils.findAnnotation(method, toLookFor);</span><br><span class="line">	<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AspectJAnnotation&lt;A&gt;(result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="根据切点信息生成增强"><a href="#根据切点信息生成增强" class="headerlink" title="根据切点信息生成增强"></a>根据切点信息生成增强</h5><p>所有的增强都由 Advisor 的实现类 <code>InstantiationModelAwarePointcutAdvisorImpl</code> 统一封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(AspectJExpressionPointcut declaredPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">		Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">		MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     	 <span class="comment">// test()</span></span><br><span class="line">	<span class="keyword">this</span>.declaredPointcut = declaredPointcut;</span><br><span class="line">	<span class="keyword">this</span>.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class="line">	<span class="keyword">this</span>.methodName = aspectJAdviceMethod.getName();</span><br><span class="line">	<span class="keyword">this</span>.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class="line">     	 <span class="comment">// public void test.AspectJTest.beforeTest()</span></span><br><span class="line">	<span class="keyword">this</span>.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line">	<span class="keyword">this</span>.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line">	<span class="keyword">this</span>.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">        <span class="comment">// 0</span></span><br><span class="line">	<span class="keyword">this</span>.declarationOrder = declarationOrder;</span><br><span class="line">        <span class="comment">// test.AspectJTest</span></span><br><span class="line">	<span class="keyword">this</span>.aspectName = aspectName;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">		<span class="comment">// Static part of the pointcut is a lazy type.</span></span><br><span class="line">		Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class="line">				aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), <span class="keyword">this</span>.declaredPointcut);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span></span><br><span class="line">		<span class="comment">// If it's not a dynamic pointcut, it may be optimized out</span></span><br><span class="line">		<span class="comment">// by the Spring AOP infrastructure after the first evaluation.</span></span><br><span class="line">		<span class="keyword">this</span>.pointcut = <span class="keyword">new</span> PerTargetInstantiationModelPointcut(</span><br><span class="line">				<span class="keyword">this</span>.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line">		<span class="keyword">this</span>.lazy = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// A singleton aspect.</span></span><br><span class="line">		<span class="keyword">this</span>.pointcut = <span class="keyword">this</span>.declaredPointcut;</span><br><span class="line">		<span class="keyword">this</span>.lazy = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">this</span>.instantiatedAdvice = instantiateAdvice(<span class="keyword">this</span>.declaredPointcut);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在封装过程中只是简单地将信息封装在类的实例中，所有的信息单纯地赋值，在<strong>实例初始化的过程中还完成了对于增强器的初始化</strong>。因为不同的增强所体现的逻辑是不同的，比如<code>@Before(&quot;test()&quot;)</code>与@<code>After(&quot;test()&quot;</code>标签的不同就是增强器增强的位置不同，所以就需要不同的增强器来完成不同的逻辑，而根据注解中的信息初始化对应的增强器就是在<code>instantiateAdvice</code>函数中实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Advice <span class="title">instantiateAdvice</span><span class="params">(AspectJExpressionPointcut pcut)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdvisorFactory.getAdvice(<span class="keyword">this</span>.aspectJAdviceMethod, pcut,</span><br><span class="line">			<span class="keyword">this</span>.aspectInstanceFactory, <span class="keyword">this</span>.declarationOrder, <span class="keyword">this</span>.aspectName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">		MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">	validate(candidateAspectClass);</span><br><span class="line"></span><br><span class="line">	AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">			AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">	<span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we get here, we know we have an AspectJ method.</span></span><br><span class="line">	<span class="comment">// Check that it's an AspectJ-annotated class</span></span><br><span class="line">	<span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line">				<span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">				candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AbstractAspectJAdvice springAdvice;</span><br><span class="line"></span><br><span class="line">     	 <span class="comment">// 根据不同的注解类型封装不同的增强器</span></span><br><span class="line">	<span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">		<span class="keyword">case</span> AtBefore:</span><br><span class="line">			springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(</span><br><span class="line">					candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> AtAfter:</span><br><span class="line">			springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(</span><br><span class="line">					candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">			springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(</span><br><span class="line">					candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">			AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">				springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">			springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(</span><br><span class="line">					candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">			AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">				springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> AtAround:</span><br><span class="line">			springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(</span><br><span class="line">					candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> AtPointcut:</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">					<span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now to configure the advice...</span></span><br><span class="line">	springAdvice.setAspectName(aspectName);</span><br><span class="line">	springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">	String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">	<span class="keyword">if</span> (argNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">		springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">	&#125;</span><br><span class="line">	springAdvice.calculateArgumentBindings();</span><br><span class="line">	<span class="keyword">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这里书上描述得有些奇怪，直接进入了 <code>MethodBeforeAdviceInterceptor</code> 解析了，但是我们并不知道这与 <code>AspectJMethodBeforeAdvice</code> 有何关系。后面查阅了一下网上资料。</p>
<p> <a href="http://lgbolgger.iteye.com/blog/2117214" target="_blank" rel="noopener">http://lgbolgger.iteye.com/blog/2117214</a></p>
<p> <a href="https://www.dengxiangxing.com/post/16229" target="_blank" rel="noopener">https://www.dengxiangxing.com/post/16229</a></p>
<p> <a href="http://www.voidcn.com/article/p-erexljic-bqk.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-erexljic-bqk.html</a></p>
</blockquote>
<p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_41/Advice%20%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?raw=true" alt="Advice 结构图"></p>
<p>这里我们可以看出，<code>AspectJMethodBeforeAdvice</code> 和 <code>AspectJAfterReturningAdvice</code> 均没有实现  <code>MethodInterceptor</code> ，但是我们会发现 <code>AspectJMethodBeforeAdvice#before</code> 方法是被 <code>MethodBeforeAdviceInterceptor#invoke</code> 调用的（通过 idea 的 <code>call Hierarchy</code>），所以根据网上资料推测 <code>MethodInterceptor</code> 的 <code>invoke</code> 方法是直接调用的整个 AOP 流程的，而 <code>AspectJMethodBeforeAdvice</code> 虽然没有实现 <code>MethodInterceptor</code> 但是通过了 <code>MethodBeforeAdviceInterceptor</code> 适配器来适配解决了这个问题。而这二者的适配器分别是 <code>MethodBeforeAdviceAdapter</code>, <code>AfterReturningAdviceAdapter</code>。</p>
<blockquote>
<p> 不如我们后面开个 Spring 中的设计模式专题吧？</p>
</blockquote>
<p>这里我们后面再说其适配的时机。</p>
<h4 id="增加同步实例化增强器"><a href="#增加同步实例化增强器" class="headerlink" title="增加同步实例化增强器"></a>增加同步实例化增强器</h4><p>如果寻找的增强器不为空而且又配置了增强延迟初始化，那么就需要在首位加入同步实例增强器。同步实例化增强器 <code>SyntheticInstantiationAdvisor</code> 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntheticInstantiationAdvisor</span> <span class="keyword">extends</span> <span class="title">DefaultPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SyntheticInstantiationAdvisor</span><span class="params">(<span class="keyword">final</span> MetadataAwareAspectInstanceFactory aif)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(aif.getAspectMetadata().getPerClausePointcut(), <span class="keyword">new</span> MethodBeforeAdvice() &#123;</span><br><span class="line">             	 <span class="comment">// 目标方法前调用，类似 @Before</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// Simply instantiate the aspect</span></span><br><span class="line">				aif.getAspectInstance();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取-DeclareParents-注解"><a href="#获取-DeclareParents-注解" class="headerlink" title="获取 DeclareParents 注解"></a>获取 <code>DeclareParents</code> 注解</h4><p><code>DeclareParents</code> 主要用于引介增强的注解形式的实现，而其实现方式与普遍增强很类似，只不过使用 <code>DeclareParentsAdvisor</code> 对功能进行封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build a &#123;<span class="doctag">@link</span> org.springframework.aop.aspectj.DeclareParentsAdvisor&#125;</span></span><br><span class="line"><span class="comment"> * for the given introduction field.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Resulting Advisors will need to be evaluated for targets.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> introductionField the field to introspect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> null&#125; if not an Advisor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Advisor <span class="title">getDeclareParentsAdvisor</span><span class="params">(Field introductionField)</span> </span>&#123;</span><br><span class="line">	DeclareParents declareParents = introductionField.getAnnotation(DeclareParents.class);</span><br><span class="line">	<span class="keyword">if</span> (declareParents == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Not an introduction field</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (DeclareParents.class == declareParents.defaultImpl()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"'defaultImpl' attribute must be set on DeclareParents"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DeclareParentsAdvisor(</span><br><span class="line">			introductionField.getType(), declareParents.value(), declareParents.defaultImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找匹配的增强器"><a href="#寻找匹配的增强器" class="headerlink" title="寻找匹配的增强器"></a>寻找匹配的增强器</h3><p>前面的函数中已经完成了所有增强器的解析，但是对于所有增强器来讲，并不一定都适用于当前的 Bean，还要挑取适合的增强器，也就是满足我们配置的通配符的增强器。具体实现在 <code>findAdvisorsThatCanApply</code> 中。</p>
<p>还记得之前说过 <code>AnnotationAwareAspectJAutoProxyCreator</code> 间接继承了 <code>AbstractAdvisorAutoProxyCreator</code>，而 <code>findAdvisorsThatCanApply</code> 就是在 <code>AbstractAdvisorAutoProxyCreator</code> 中被调用的(其调用链可追溯到<code>postProcessAfterInitialization</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Search the given candidate Advisors to find all Advisors that</span></span><br><span class="line"><span class="comment"> * can apply to the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidateAdvisors the candidate Advisors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the target's bean class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the target's bean name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the List of applicable Advisors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ProxyCreationContext#getCurrentProxiedBeanName()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 过滤已经得到的 advisors</span></span><br><span class="line">		<span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看 <code>findAdvisorsThatCanApply</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the sublist of the &#123;<span class="doctag">@code</span> candidateAdvisors&#125; list</span></span><br><span class="line"><span class="comment"> * that is applicable to the given class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidateAdvisors the Advisors to evaluate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz the target class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> sublist of Advisors that can apply to an object of the given class</span></span><br><span class="line"><span class="comment"> * (may be the incoming List as-is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">        <span class="comment">// 首先处理引介增强</span></span><br><span class="line">	<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">	<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">            <span class="comment">// 引介增强已被处理</span></span><br><span class="line">		<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">			<span class="comment">// already processed</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">         	 <span class="comment">// 对于普通 bean 的处理</span></span><br><span class="line">		<span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findAdvisorsThatCanApply</code> 函数的主要功能是寻找所有增强器中适用于当前 class 的增强器。引介增强与普通的增强是处理不一样的，所以分开处理。而对于真正的匹配在 <code>canApply</code> 中实现。</p>
<h3 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h3><p><code>AbstractAutoProxyCreator#createProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an AOP proxy for the given bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment"> * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSource the TargetSource for the proxy,</span></span><br><span class="line"><span class="comment"> * already pre-configured to access the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the AOP proxy for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #buildAdvisors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 获取当前类中相关属性</span></span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">            <span class="comment">// 决定对于给定的 bean 是否应该使用 targetClass 而不是他的接口代理</span></span><br><span class="line">         	 <span class="comment">// 检查 proxyTargetClass 设置以及 preserveTargetClass 属性</span></span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 添加代理接口</span></span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// 加入增强器</span></span><br><span class="line">		proxyFactory.addAdvisor(advisor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置要代理的类</span></span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">        <span class="comment">// 定制代理</span></span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来控制代理工程被配置之后，是否还允许修改通知</span></span><br><span class="line">        <span class="comment">// 缺省值为 false(即在代理被配置之后，不允许修改代理的配置)</span></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于代理类的创建及处理， Spring 委托给了 <code>ProxyFactory</code> 去处理，而在此函数中主要是对 <code>ProxyFactory</code> 的初始化操作，进而对真正的创建代理做准备，这些初始化操作包括如下内容：</p>
<ol>
<li>获取当前类的属性</li>
<li>添加代理接口</li>
<li>封装 Advisor 并加入到 ProxyFactory 中</li>
<li>设置要代理的类</li>
<li>当然在 Spring 中还为子类提供了定制的函数 <code>customizeProxyFactory</code>，子类可以在此函数中进行对 <code>ProxyFactory</code> 的进一步封装</li>
<li>进行获取代理操作</li>
</ol>
<p>其中，封装 Advisor 并加入到 <code>ProxyFactory</code> 中以及创建代理是两个相对繁琐的过程，可以通过 <code>ProxyFactory</code> 提供的 <code>addAdvisor</code> 方法直接将增强器置入代理创建工程中，但是拦截器封装为增强器还是急需要一定的逻辑的。</p>
<h4 id="封装-Advisor-并加入到-ProxyFactory-中"><a href="#封装-Advisor-并加入到-ProxyFactory-中" class="headerlink" title="封装 Advisor 并加入到 ProxyFactory 中"></a>封装 Advisor 并加入到 ProxyFactory 中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the advisors for the given bean, including the specific interceptors</span></span><br><span class="line"><span class="comment"> * as well as the common interceptor, all adapted to the Advisor interface.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment"> * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the list of Advisors for the given bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Advisor[] buildAdvisors(String beanName, Object[] specificInterceptors) &#123;</span><br><span class="line">	<span class="comment">// Handle prototypes correctly...</span></span><br><span class="line">	Advisor[] commonInterceptors = resolveInterceptorNames();</span><br><span class="line"></span><br><span class="line">	List&lt;Object&gt; allInterceptors = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">	<span class="keyword">if</span> (specificInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加入拦截器</span></span><br><span class="line">		allInterceptors.addAll(Arrays.asList(specificInterceptors));</span><br><span class="line">		<span class="keyword">if</span> (commonInterceptors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.applyCommonInterceptorsFirst) &#123;</span><br><span class="line">				allInterceptors.addAll(<span class="number">0</span>, Arrays.asList(commonInterceptors));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				allInterceptors.addAll(Arrays.asList(commonInterceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">int</span> nrOfCommonInterceptors = commonInterceptors.length;</span><br><span class="line">		<span class="keyword">int</span> nrOfSpecificInterceptors = (specificInterceptors != <span class="keyword">null</span> ? specificInterceptors.length : <span class="number">0</span>);</span><br><span class="line">		logger.debug(<span class="string">"Creating implicit proxy for bean '"</span> + beanName + <span class="string">"' with "</span> + nrOfCommonInterceptors +</span><br><span class="line">				<span class="string">" common interceptors and "</span> + nrOfSpecificInterceptors + <span class="string">" specific interceptors"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = <span class="keyword">new</span> Advisor[allInterceptors.size()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allInterceptors.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 拦截器进行封装转化为 Advisor</span></span><br><span class="line">		advisors[i] = <span class="keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">wrap</span><span class="params">(Object adviceObject)</span> <span class="keyword">throws</span> UnknownAdviceTypeException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果要封装的对象本身就是 Advisor 类型的那么无需再做过多处理</span></span><br><span class="line">	<span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) &#123;</span><br><span class="line">		<span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 因为此封装方法只对 Advisor 与 Advice 两种类型的数据有效，如果不是将不能封装</span></span><br><span class="line">	<span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(adviceObject);</span><br><span class="line">	&#125;</span><br><span class="line">	Advice advice = (Advice) adviceObject;</span><br><span class="line">	<span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">		<span class="comment">// So well-known it doesn't even need an adapter.</span></span><br><span class="line">            <span class="comment">// 如果是 MethodInterceptor 类型则使用 DefaultPointcutAdvisor 封装</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 如果存在 Advisor 的适配器那么也同样需要进行封装</span></span><br><span class="line">	<span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">		<span class="comment">// Check that it is supported.</span></span><br><span class="line">		<span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前上文所说的适配器流程便在这里了。</p>
<p>由于 Spring 中涉及过多的拦截器、增强器、增强方法等方式来对逻辑进行增强，所以非常有必要统一封装成 Advisor 来进行代理的创建，完成了增强的封装过程，那么解析最重要的一步就是代理的创建与获取了。</p>
<p><code>ProxyFactory#getProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建代理-1"><a href="#创建代理-1" class="headerlink" title="创建代理"></a>创建代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses should call this to get a new AOP proxy. They should &lt;b&gt;not&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * create an AOP proxy with &#123;<span class="doctag">@code</span> this&#125; as an argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="comment">// 见下文描述</span></span><br><span class="line">	<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">		<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">					<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 if 语句可以看出有三个方面影响 Spring 选择 JDKProxy or CglibProxy：</p>
<ul>
<li>optimize: 用来控制通过 CGLIB 创建的代理是否使用激进的优化策略。除非完全了解 AOP 代理如何处理优化，否则不推荐用户使用这个设置。目前这个属性仅用于 CGLIB 代理，对于 JDK 动态代理（缺省代理）无效。</li>
<li>proxyTargetClass：这个属性为 true 时，目标类本身被代理而不是目标类的接口。如果这个属性值被设为 true，CGLIB 代理将被创建，设置方式： <code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;</code></li>
<li>hasNoUserSuppliedProxyInterfaces: 是否存在代理接口</li>
</ul>
<h5 id="对-JDK-与-Cglib-方式的总结"><a href="#对-JDK-与-Cglib-方式的总结" class="headerlink" title="对 JDK 与 Cglib 方式的总结"></a>对 JDK 与 Cglib 方式的总结</h5><ul>
<li>如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP</li>
<li>如果目标对象实现了接口，可以强制使用 CGLIB 实现 AOP</li>
<li>如果目标对象没有实现接口，必须采用 CGLIB 库，Spring 会自动在 JDK 动态代理和 CGLIB 之间转换</li>
</ul>
<h6 id="如何强制使用-CGLIB-实现-AOP"><a href="#如何强制使用-CGLIB-实现-AOP" class="headerlink" title="如何强制使用 CGLIB 实现 AOP"></a>如何强制使用 CGLIB 实现 AOP</h6><ol>
<li>添加 CGLIB 库</li>
<li>在 Spring 配置文件中加入 <code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;</code></li>
</ol>
<h6 id="JDK-动态代理和-CGLIB-字节码生成的区别"><a href="#JDK-动态代理和-CGLIB-字节码生成的区别" class="headerlink" title="JDK 动态代理和 CGLIB 字节码生成的区别"></a>JDK 动态代理和 CGLIB 字节码生成的区别</h6><ul>
<li>JDK 动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成 final</li>
</ul>
<h4 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h4><p>确定了使用哪种代理方式后便可以进行代理的创建了，但是创建之前我们有必要回顾一下两种方式的使用方法。这里可以参考我之前的<a href="https://binglau7.github.io/2017/06/11/AOP%E7%9A%84%E9%81%93%E7%90%86/" target="_blank" rel="noopener">AOP的道理</a>。</p>
<h5 id="JDK-代理分析"><a href="#JDK-代理分析" class="headerlink" title="JDK 代理分析"></a>JDK 代理分析</h5><p>继续之前的跟踪，可达 <code>JdkDynamicAopProxy#getProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前文章中分析过 JDK 动态代理的关键是创建自定义的 <code>InvocationHandler</code>，而 <code>InvocationHandler</code> 中包含了需要覆盖的函数 <code>getProxy</code>，而当前方法正是完成了这个操作。</p>
<p>既然<code>JdkDynamicAopProxy</code> 实现了 <code>InvocationHandler</code> 那它肯定有 <code>invoke</code> 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of &#123;<span class="doctag">@code</span> InvocationHandler.invoke&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span></span><br><span class="line"><span class="comment"> * unless a hook method throws an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	MethodInvocation invocation;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">	Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// equals 方法的处理</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">			<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">            <span class="comment">// hash 方法的处理</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">			<span class="keyword">return</span> hashCode();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">			<span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">			<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">		&#125;</span><br><span class="line">            <span class="comment">// isAssignableFrom(Class cls) 方法如果调用这个方法的 class 或者接口与其参数</span></span><br><span class="line">            <span class="comment">// 表示的类或接口相同或者是参数 cls 表示的类或接口的父类，则返回 true</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">				method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">			<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">			<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// May be null. Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">		<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">			targetClass = target.getClass();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">            <span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">		<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">			<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">			<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                 <span class="comment">// 如果拦截器链为空直接调用切点方法</span></span><br><span class="line">			retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">                 <span class="comment">// 将拦截器封装在 ReflectiveMethodInvocation，以便于使用其 proceed </span></span><br><span class="line">                 <span class="comment">// 进行链接表用拦截器</span></span><br><span class="line">			invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">			<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">                 <span class="comment">// 执行拦截器链</span></span><br><span class="line">			retVal = invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">		Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">				returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">			<span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">			<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">			<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">			retVal = proxy;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">					<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// Restore old proxy.</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数中最主要的工作就是创建了一个拦截器链，并使用 <code>ReflectiveMethodInvocation</code> 类进行了链的封装，而在 <code>ReflectiveMethodInvocation</code> 类的 <code>proceed</code> 方法中实现了拦截器的逐一调用，那么我们继续来探究，在 <code>proceed</code> 方法中是怎么实现前置增强的目标方法前调用后置增强在目标方法后调用的逻辑呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">        <span class="comment">// 执行完所有增强后执行切点方法</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下一个要执行的拦截器</span></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">	<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">		<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">		<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">            <span class="comment">// 动态匹配</span></span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">			<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">                 <span class="comment">// 不匹配则不执行拦截器</span></span><br><span class="line">			<span class="keyword">return</span> proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">		<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 普通拦截器，直接调用拦截器，比如：</span></span><br><span class="line"><span class="comment">            * ExposeInvocationInterceptor</span></span><br><span class="line"><span class="comment">            * DelegatePerTargetObjectIntroductionInterceptor,</span></span><br><span class="line"><span class="comment">            * MethodBeforeAdviceInterceptor</span></span><br><span class="line"><span class="comment">            * AspectJAroundAdvice</span></span><br><span class="line"><span class="comment">            * AspectJAfterAdvice</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="comment">// 将 this 作为参数传递以保证当前实例中调用链的执行</span></span><br><span class="line">		<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReflectiveMethodInvocation</code> 中的主要职责是维护了链接调用的计数器，记录着当前调用链接的位置，以便链可以有序地进行下去，那么在这个方法中并没有我们之前设想的维护各种增强的顺序，而是将此工作委托给了各个增强器，使各个增强器在内部进行逻辑实现。</p>
<h5 id="CGLIB-代理分析"><a href="#CGLIB-代理分析" class="headerlink" title="CGLIB 代理分析"></a>CGLIB 代理分析</h5><p>我们参考上述知道其入口也是在 getProxy 方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating CGLIB proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">		Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">			proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">			Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">				<span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">            <span class="comment">// 验证 class</span></span><br><span class="line">		validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">            <span class="comment">// 配置及设置 Enhancer</span></span><br><span class="line">		Enhancer enhancer = createEnhancer();</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">			enhancer.setClassLoader(classLoader);</span><br><span class="line">			<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">				enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置拦截器</span></span><br><span class="line">		Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">		Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">			types[x] = callbacks[x].getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">				<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">		enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">		<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CodeGenerationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line">				<span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line">				<span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line">				<span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line">				<span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类以及创建代理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">	enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line">	enhancer.setCallbacks(callbacks);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> ?</span><br><span class="line">			enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span><br><span class="line">			enhancer.create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上函数完整地阐述了一个创建 Spring 中的 Enhancer 的过程，这里最重要的是通过 getCallbacks 方法设置拦截器链</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// Parameters used for optimization choices...</span></span><br><span class="line">	<span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</span><br><span class="line">	<span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</span><br><span class="line">	<span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Choose an "aop" interceptor (used for AOP calls).</span></span><br><span class="line">        <span class="comment">// 将拦截器封装在 DynamicAdvisedInterceptor</span></span><br><span class="line">	Callback aopInterceptor = <span class="keyword">new</span> DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Choose a "straight to target" interceptor. (used for calls that are</span></span><br><span class="line">	<span class="comment">// unadvised but can return this). May be required to expose the proxy.</span></span><br><span class="line">	Callback targetInterceptor;</span><br><span class="line">	<span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">		targetInterceptor = isStatic ?</span><br><span class="line">				<span class="keyword">new</span> StaticUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">				<span class="keyword">new</span> DynamicUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		targetInterceptor = isStatic ?</span><br><span class="line">				<span class="keyword">new</span> StaticUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">				<span class="keyword">new</span> DynamicUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Choose a "direct to target" dispatcher (used for</span></span><br><span class="line">	<span class="comment">// unadvised calls to static targets that cannot return this).</span></span><br><span class="line">	Callback targetDispatcher = isStatic ?</span><br><span class="line">			<span class="keyword">new</span> StaticDispatcher(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) : <span class="keyword">new</span> SerializableNoOp();</span><br><span class="line"></span><br><span class="line">	Callback[] mainCallbacks = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">                 <span class="comment">// 将拦截器链加入 Callback 中</span></span><br><span class="line">			aopInterceptor,  <span class="comment">// for normal advice</span></span><br><span class="line">			targetInterceptor,  <span class="comment">// invoke target without considering advice, if optimized</span></span><br><span class="line">			<span class="keyword">new</span> SerializableNoOp(),  <span class="comment">// no override for methods mapped to this</span></span><br><span class="line">			targetDispatcher, <span class="keyword">this</span>.advisedDispatcher,</span><br><span class="line">			<span class="keyword">new</span> EqualsInterceptor(<span class="keyword">this</span>.advised),</span><br><span class="line">			<span class="keyword">new</span> HashCodeInterceptor(<span class="keyword">this</span>.advised)</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	Callback[] callbacks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the target is a static one and the advice chain is frozen,</span></span><br><span class="line">	<span class="comment">// then we can make some optimizations by sending the AOP calls</span></span><br><span class="line">	<span class="comment">// direct to the target using the fixed chain for that method.</span></span><br><span class="line">	<span class="keyword">if</span> (isStatic &amp;&amp; isFrozen) &#123;</span><br><span class="line">		Method[] methods = rootClass.getMethods();</span><br><span class="line">		Callback[] fixedCallbacks = <span class="keyword">new</span> Callback[methods.length];</span><br><span class="line">		<span class="keyword">this</span>.fixedInterceptorMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(methods.length);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> small memory optimization here (can skip creation for methods with no advice)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; methods.length; x++) &#123;</span><br><span class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</span><br><span class="line">			fixedCallbacks[x] = <span class="keyword">new</span> FixedChainStaticTargetInterceptor(</span><br><span class="line">					chain, <span class="keyword">this</span>.advised.getTargetSource().getTarget(), <span class="keyword">this</span>.advised.getTargetClass());</span><br><span class="line">			<span class="keyword">this</span>.fixedInterceptorMap.put(methods[x].toString(), x);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now copy both the callbacks from mainCallbacks</span></span><br><span class="line">		<span class="comment">// and fixedCallbacks into the callbacks array.</span></span><br><span class="line">		callbacks = <span class="keyword">new</span> Callback[mainCallbacks.length + fixedCallbacks.length];</span><br><span class="line">		System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</span><br><span class="line">		System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</span><br><span class="line">		<span class="keyword">this</span>.fixedInterceptorOffset = mainCallbacks.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		callbacks = mainCallbacks;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 getCallback 中 Spring 考虑了很多情况，但是对于我们来说，只需要理解最常用的就可以了，比如将 advised 属性封装在 <code>DynamicAdvisedInterceptor</code> 并加入在 callbacks 中，这么做的目的是什么呢？然后调用呢?</p>
<p>就我们所知，CGLIB 对于方法的拦截是通过将自定义的拦截器（实现 <code>MethodInterceptor</code> 接口）加入 Callback 中并在调用代理时直接激活拦截器中的 intercept 方法来实现的，那么在 getCallback 中正式实现了这样一个目的，<code>DynamicAdvisedInterceptor</code> 继承自 <code>MethodInterceptor</code> ，加入 Callback 中后，在再次调用代理时会直接调用 <code>DynamicAdvisedInterceptor</code> 中的 intercept 方法，由此推断，对于 CGLIB 方式实现的代理，其核心逻辑必然在 <code>DynamicAdvisedInterceptor</code> 中的 <code>intercept</code> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">	Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// May be null. Get as late as possible to minimize the time we</span></span><br><span class="line">		<span class="comment">// "own" the target, in case it comes from a pool...</span></span><br><span class="line">		target = getTarget();</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">			targetClass = target.getClass();</span><br><span class="line">		&#125;</span><br><span class="line">                <span class="comment">// 获取拦截器链</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">		Object retVal;</span><br><span class="line">		<span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">		<span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">			<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">			<span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">			<span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">			<span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">                    <span class="comment">// 如果拦截器链为空则直接激活原方法</span></span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">                    <span class="comment">// 进入链</span></span><br><span class="line">			retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">			releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// Restore old proxy.</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述实现与 JDK 方式实现代理中的 invoke 方法大同小异，首先是构造链，然后封装此链进行串联调用，稍有区别的是 JDK 中直接构建 <code>ReflectiveMethodInvocation</code> ，而再 cglib 中使用 <code>CglibMethodInvocation</code> 。<code>CglibMethodInvocation</code> 继承自 <code>ReflectiveMethodInvocation</code>，但是 <code>proceed</code> 方法并没有重写。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/18/Kafka生产者分析——KafkaProducer/" rel="next" title="Kafka生产者分析——KafkaProducer">
                <i class="fa fa-chevron-left"></i> Kafka生产者分析——KafkaProducer
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/24/Kafka生产者分析——RecordAccumulator/" rel="prev" title="Kafka生产者分析——RecordAccumulator">
                Kafka生产者分析——RecordAccumulator <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/BingLau7/blog/blob/master/images/drunktocat.jpg?raw=true"
               alt="刘冰鉴" />
          <p class="site-author-name" itemprop="name">刘冰鉴</p>
           
              <p class="site-description motion-element" itemprop="description">Res severa est verum gaudium.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#动态-AOP-使用示例"><span class="nav-number">1.</span> <span class="nav-text">动态 AOP 使用示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态-AOP-自定义标签"><span class="nav-number">2.</span> <span class="nav-text">动态 AOP 自定义标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注册-AnnotationAwareAspectJAutoProxyCreator"><span class="nav-number">2.1.</span> <span class="nav-text">注册 AnnotationAwareAspectJAutoProxyCreator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注册或者升级-AnnotationAwareAspectJAutoProxyCreator"><span class="nav-number">2.1.1.</span> <span class="nav-text">注册或者升级 AnnotationAwareAspectJAutoProxyCreator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-proxy-target-class-以及-expose-proxy-属性"><span class="nav-number">2.1.2.</span> <span class="nav-text">处理 proxy-target-class 以及 expose-proxy 属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#proxy-target-class"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">proxy-target-class</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK-动态代理-vs-CGLIB-代理"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">JDK 动态代理 vs CGLIB 代理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#expose-proxy"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">expose-proxy</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-AOP-代理"><span class="nav-number">3.</span> <span class="nav-text">创建 AOP 代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取-targetSource"><span class="nav-number">3.1.</span> <span class="nav-text">获取 targetSource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取增强器"><span class="nav-number">3.2.</span> <span class="nav-text">获取增强器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#普通增强器的获取"><span class="nav-number">3.2.1.</span> <span class="nav-text">普通增强器的获取</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#切点信息获取"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">切点信息获取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#根据切点信息生成增强"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">根据切点信息生成增强</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增加同步实例化增强器"><span class="nav-number">3.2.2.</span> <span class="nav-text">增加同步实例化增强器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取-DeclareParents-注解"><span class="nav-number">3.2.3.</span> <span class="nav-text">获取 DeclareParents 注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找匹配的增强器"><span class="nav-number">3.3.</span> <span class="nav-text">寻找匹配的增强器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建代理"><span class="nav-number">3.4.</span> <span class="nav-text">创建代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#封装-Advisor-并加入到-ProxyFactory-中"><span class="nav-number">3.4.1.</span> <span class="nav-text">封装 Advisor 并加入到 ProxyFactory 中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建代理-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">创建代理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对-JDK-与-Cglib-方式的总结"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">对 JDK 与 Cglib 方式的总结</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#如何强制使用-CGLIB-实现-AOP"><span class="nav-number">3.4.2.1.1.</span> <span class="nav-text">如何强制使用 CGLIB 实现 AOP</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#JDK-动态代理和-CGLIB-字节码生成的区别"><span class="nav-number">3.4.2.1.2.</span> <span class="nav-text">JDK 动态代理和 CGLIB 字节码生成的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取代理"><span class="nav-number">3.4.3.</span> <span class="nav-text">获取代理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK-代理分析"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">JDK 代理分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CGLIB-代理分析"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">CGLIB 代理分析</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘冰鉴</span>
</div>

        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
