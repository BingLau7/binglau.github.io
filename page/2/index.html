<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="issue">
<meta property="og:type" content="website">
<meta property="og:title" content="村里最好的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="村里最好的博客">
<meta property="og:description" content="issue">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="村里最好的博客">
<meta name="twitter:description" content="issue">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>村里最好的博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">村里最好的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/Akka-基础功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/Akka-基础功能/" itemprop="url">Akka 基础功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:54:31+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Akka-基础功能"><a href="#Akka-基础功能" class="headerlink" title="Akka 基础功能"></a>Akka 基础功能</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_25/actor_lifecycle.png?raw=true" alt="生命周期"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorSystem</span>, <span class="type">OneForOneStrategy</span>, <span class="type">Props</span>, <span class="type">SupervisorStrategy</span>&#125;</span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"><span class="keyword">import</span> akka.pattern.&#123;<span class="type">Backoff</span>, <span class="type">BackoffSupervisor</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration.<span class="type">Duration</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeCycle</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Actor 对象被创建后启动前该方法会被调用</span></span><br><span class="line">  <span class="comment">// Actor 对象是通过异步方式创建的</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    log.info(<span class="string">"preStart"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Actor 对象停止运行时，该方法会被调用</span></span><br><span class="line">  <span class="comment">// 当 ActorSystem 或 ActorContext 对象（Actor 对象中会</span></span><br><span class="line">  <span class="comment">// 含有一个 ActorContext 对象，可通过 context 方法获得）中的</span></span><br><span class="line">  <span class="comment">// stop(ActorRef) 方法被调用是,Actor对象会以一部方式停止运行.</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postStop</span></span>(): <span class="type">Unit</span> =  &#123;</span><br><span class="line">    log.info(<span class="string">"postStop"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过失效监督策略可以重启失效的子 Actor 对象。在</span></span><br><span class="line">  <span class="comment">// 执行重启操作的过程中，可以在重启 Actor 对象前调用该方法。</span></span><br><span class="line">  <span class="comment">// 该方法默认的实现代码会处理 Actor 对象停止运行前使用的资源，</span></span><br><span class="line">  <span class="comment">// 处理 Actor 对象的所有子对象。执行完清理操作后，postStop() 方法会自动被调用。</span></span><br><span class="line">  <span class="comment">// 通常不必重写</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preRestart</span></span>(reason: <span class="type">Throwable</span>, message: <span class="type">Option</span>[<span class="type">Any</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    log.info(<span class="string">s"preRestart e: <span class="subst">$&#123;reason.getMessage&#125;</span>, message: <span class="subst">$&#123;message.toString&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">super</span>.preRestart(reason, message)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Actor 对象重启后回调用这个方法，使 Actor 对象能够在失效</span></span><br><span class="line">  <span class="comment">// 并重启后被初始化。该方法默认的执行代码会调用 preStart() 方法。</span></span><br><span class="line">  <span class="comment">// 通常不必重写</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">postRestart</span></span>(reason: <span class="type">Throwable</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    log.info(<span class="string">s"postRestart e: <span class="subst">$&#123;reason.getMessage&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">super</span>.postRestart(reason)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Restart"</span> =&gt;</span><br><span class="line">      log.info(<span class="string">"Restart"</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; log.info(<span class="string">"receive something"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LifeCycleDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"demo"</span>)</span><br><span class="line">    <span class="keyword">val</span> lifeCycle = <span class="type">Props</span>(classOf[<span class="type">LifeCycle</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> supervisor = <span class="type">BackoffSupervisor</span>.props(</span><br><span class="line">      <span class="type">Backoff</span>.onStop(</span><br><span class="line">        lifeCycle,</span><br><span class="line">        childName = <span class="string">"myDemo"</span>,</span><br><span class="line">        minBackoff = <span class="type">Duration</span>.create(<span class="number">3</span>, <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>),</span><br><span class="line">        maxBackoff = <span class="type">Duration</span>.create(<span class="number">30</span>, <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>),</span><br><span class="line">        randomFactor = <span class="number">0.2</span> <span class="comment">// adds 20% "noise" to vary the intervals slightly</span></span><br><span class="line">      ).withSupervisorStrategy(</span><br><span class="line">        <span class="type">OneForOneStrategy</span>() &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">NullPointerException</span> =&gt; <span class="type">SupervisorStrategy</span>.<span class="type">Restart</span></span><br><span class="line">          <span class="keyword">case</span> _ =&gt; <span class="type">SupervisorStrategy</span>.<span class="type">Escalate</span></span><br><span class="line">        &#125;</span><br><span class="line">      ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> actor = system.actorOf(lifeCycle, <span class="string">"lifeCycle"</span>)</span><br><span class="line">    system.actorOf(supervisor, <span class="string">"lifeCycleSupervisor"</span>)</span><br><span class="line">    actor ! <span class="string">"Test"</span></span><br><span class="line">    actor ! <span class="string">"Restart"</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    actor ! <span class="string">"Test"</span></span><br><span class="line"></span><br><span class="line">    system.terminate()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:53.376] [demo-akka.actor.default-dispatcher-3] [akka://demo/user/lifeCycle] preStart</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:53.376] [demo-akka.actor.default-dispatcher-3] [akka://demo/user/lifeCycle] receive something</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:53.376] [demo-akka.actor.default-dispatcher-3] [akka://demo/user/lifeCycle] Restart</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:53.377] [demo-akka.actor.default-dispatcher-2] [akka://demo/user/lifeCycleSupervisor/myDemo] preStart</span></span><br><span class="line"><span class="comment">[ERROR] [09/12/2017 00:36:53.398] [demo-akka.actor.default-dispatcher-3] [akka://demo/user/lifeCycle] null</span></span><br><span class="line"><span class="comment">java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">	at io.binglau.scala.akka.demo.LifeCycle$$anonfun$receive$1.applyOrElse(LifeCycle.scala:49)</span></span><br><span class="line"><span class="comment">	at akka.actor.Actor.aroundReceive(Actor.scala:513)</span></span><br><span class="line"><span class="comment">	at akka.actor.Actor.aroundReceive$(Actor.scala:511)</span></span><br><span class="line"><span class="comment">	at io.binglau.scala.akka.demo.LifeCycle.aroundReceive(LifeCycle.scala:11)</span></span><br><span class="line"><span class="comment">	at akka.actor.ActorCell.receiveMessage(ActorCell.scala:527)</span></span><br><span class="line"><span class="comment">	at akka.actor.ActorCell.invoke(ActorCell.scala:496)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.processMailbox(Mailbox.scala:257)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.run(Mailbox.scala:224)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.exec(Mailbox.scala:234)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:53.410] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/lifeCycle] preRestart e: null, message: Some(Restart)</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:53.411] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/lifeCycle] postStop</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:53.413] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/lifeCycle] postRestart e: null</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:53.413] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/lifeCycle] preStart</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:54.380] [demo-akka.actor.default-dispatcher-4] [akka://demo/user/lifeCycle] receive something</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:54.419] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/lifeCycle] postStop</span></span><br><span class="line"><span class="comment">[INFO] [09/12/2017 00:36:54.426] [demo-akka.actor.default-dispatcher-2] [akka://demo/user/lifeCycleSupervisor/myDemo] postStop</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h3 id="更改状态"><a href="#更改状态" class="headerlink" title="更改状态"></a>更改状态</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// become(...) 使用该函数可以通过指定偏函数设置 Actor 对象的当前行为。</span></span><br><span class="line"><span class="comment">// 该函数有两个参数，第二个参数为 discardOld, 默认为 true。当该参数为 true 时，</span></span><br><span class="line"><span class="comment">// 在设置当前行为前，Actor 对象的上个行为会被丢弃。当该参数为 false 时，</span></span><br><span class="line"><span class="comment">// Actor 对象的上一个行为仍旧被保存在堆栈中，当前设置的 Actor 对象行为也会被推入</span></span><br><span class="line"><span class="comment">// 堆栈，并位于上一个行为条目的上方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unbecome 在上一个行为存在的情况下，使用该函数可以使 Actor 对象从当前行为</span></span><br><span class="line"><span class="comment">// 切换到上一个行为</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusSwap</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  <span class="keyword">import</span> context._</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">angry</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"foo"</span> =&gt; log.info(<span class="string">"I am already angry?"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"bar"</span> =&gt;</span><br><span class="line">      become(happy)</span><br><span class="line">      log.info(<span class="string">"angry become happy"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"return"</span> =&gt;</span><br><span class="line">      unbecome()</span><br><span class="line">      log.info(<span class="string">"angry unbecome"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">happy</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"bar"</span> =&gt; log.info(<span class="string">"I am already happy :-)"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"foo"</span> =&gt;</span><br><span class="line">      become(angry, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">//      become(angry)</span></span><br><span class="line">      log.info(<span class="string">"happy become angry"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"return"</span> =&gt;</span><br><span class="line">      unbecome()</span><br><span class="line">      log.info(<span class="string">"happy unbecome"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"foo"</span> =&gt;</span><br><span class="line">      log.info(<span class="string">"become angry"</span>)</span><br><span class="line">      become(angry)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"bar"</span> =&gt;</span><br><span class="line">      log.info(<span class="string">"become happy"</span>)</span><br><span class="line">      become(happy)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The App trait can be used to quickly turn objects into executable programs.</span></span><br><span class="line"><span class="comment">// Here, object Main inherits the main method of App.</span></span><br><span class="line"><span class="comment">// args returns the current command line arguments as an array.</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StatusDemo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"><span class="comment">//  Console.println("Hello World: " + (args mkString ", "))</span></span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"demo"</span>)</span><br><span class="line">  <span class="keyword">val</span> statusSwap = system.actorOf(<span class="type">Props</span>(classOf[<span class="type">StatusSwap</span>]), <span class="string">"statusSwap"</span>)</span><br><span class="line"></span><br><span class="line">  statusSwap ! <span class="string">"bar"</span> <span class="comment">// happy</span></span><br><span class="line">  statusSwap ! <span class="string">"bar"</span></span><br><span class="line">  statusSwap ! <span class="string">"foo"</span> <span class="comment">// angry</span></span><br><span class="line">  statusSwap ! <span class="string">"foo"</span></span><br><span class="line">  statusSwap ! <span class="string">"return"</span> <span class="comment">// happy</span></span><br><span class="line">  statusSwap ! <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">  system.terminate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[INFO] [09/13/2017 23:23:03.776] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/statusSwap] become happy</span></span><br><span class="line"><span class="comment">[INFO] [09/13/2017 23:23:03.777] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/statusSwap] I am already happy :-)</span></span><br><span class="line"><span class="comment">[INFO] [09/13/2017 23:23:03.778] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/statusSwap] happy become angry</span></span><br><span class="line"><span class="comment">[INFO] [09/13/2017 23:23:03.778] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/statusSwap] I am already angry?</span></span><br><span class="line"><span class="comment">[INFO] [09/13/2017 23:23:03.778] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/statusSwap] angry unbecome</span></span><br><span class="line"><span class="comment">[INFO] [09/13/2017 23:23:03.778] [demo-akka.actor.default-dispatcher-5] [akka://demo/user/statusSwap] I am already happy :-)</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h3 id="监督"><a href="#监督" class="headerlink" title="监督"></a>监督</h3><p>任何创建了子 Actor 对象的 Actor 对象，都会自动变为其子 Actor 对象的监督者。如果子 Actor 对象崩溃了（例如抛出了异常），那么它的父 Actor 对象就必须在执行下列操作之间做出选择：</p>
<ul>
<li>使子对象继续运行</li>
<li>重启子对象</li>
<li>停止子对象</li>
<li>使失效情况升级（将控制权移交给祖父对象）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">SupervisorStrategy</span>.&#123;<span class="type">Escalate</span>, <span class="type">Restart</span>, <span class="type">Resume</span>, <span class="type">Stop</span>&#125;</span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorRef</span>, <span class="type">ActorSystem</span>, <span class="type">OneForOneStrategy</span>, <span class="type">Props</span>&#125;</span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration.<span class="type">DurationInt</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SupervisorChild</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"null"</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"arith"</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ArithmeticException</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"illegal"</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"unsupport"</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"exception"</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; log.info(<span class="string">"unknow"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Supervisor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> context._</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">var</span> child: <span class="type">ActorRef</span> = <span class="type">Actor</span>.noSender</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个 SupervisorStrategy 子类 (AllForOneStrategy / OneForOneStrategy)。</span></span><br><span class="line">  <span class="comment">// 通常只是声明 OneForOneStrategy 子类，因为该策略仅会应用于崩溃的子 Actor 对象。</span></span><br><span class="line">  <span class="comment">// 使用 AllForOneStrategy 子类的情况比较少，因为它会对所有子 Actor 对象产生 Decider 偏</span></span><br><span class="line">  <span class="comment">// 函数效果（将失效情况与处理手段对应起来），而不是仅对崩溃的子 Actor 对象生效</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy =</span><br><span class="line">    <span class="type">OneForOneStrategy</span>(</span><br><span class="line">      maxNrOfRetries = <span class="number">5</span>, <span class="comment">// 运行 Actor 对象崩溃的次数, -1 为次数不限</span></span><br><span class="line">      withinTimeRange = <span class="number">1</span> minute <span class="comment">// 放弃 Actor 对象前重新启动该对象的时限</span></span><br><span class="line">    ) &#123; <span class="comment">// Decider 偏函数</span></span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">NullPointerException</span> =&gt; <span class="type">Restart</span> <span class="comment">// 重启</span></span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">ArithmeticException</span> =&gt; <span class="type">Resume</span> <span class="comment">// 保持原状态继续运行</span></span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">IllegalArgumentException</span> =&gt; <span class="type">Stop</span> <span class="comment">// 停止</span></span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">UnsupportedOperationException</span> =&gt; <span class="type">Stop</span> <span class="comment">// 停止</span></span><br><span class="line">      <span class="keyword">case</span> _: <span class="type">Exception</span> =&gt; <span class="type">Escalate</span> <span class="comment">// 失效，处理权移交给祖父对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">input</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> msg: <span class="type">String</span> =&gt; child ! msg</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; log.info(<span class="string">"unknow"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"A"</span> =&gt;</span><br><span class="line">      child = context.actorOf(<span class="type">Props</span>[<span class="type">SupervisorChild</span>], <span class="string">"childA"</span>)</span><br><span class="line">      become(input)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SupervisorDemo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"demo"</span>)</span><br><span class="line">  <span class="keyword">val</span> supervisor = system.actorOf(<span class="type">Props</span>(classOf[<span class="type">Supervisor</span>]), <span class="string">"supervisor"</span>)</span><br><span class="line"></span><br><span class="line">  supervisor ! <span class="string">"A"</span></span><br><span class="line">  supervisor ! <span class="string">"abc"</span></span><br><span class="line">  supervisor ! <span class="string">"arith"</span></span><br><span class="line">  supervisor ! <span class="string">"null"</span></span><br><span class="line">  <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">  supervisor ! <span class="string">"abc"</span></span><br><span class="line">  supervisor ! <span class="string">"illegal"</span></span><br><span class="line">  supervisor ! <span class="string">"abc"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[INFO] [09/14/2017 00:20:28.573] [demo-akka.actor.default-dispatcher-3] [akka://demo/user/supervisor/childA] unknow</span></span><br><span class="line"><span class="comment">[WARN] [09/14/2017 00:20:28.581] [demo-akka.actor.default-dispatcher-4] [akka://demo/user/supervisor/childA] null</span></span><br><span class="line"><span class="comment">[ERROR] [09/14/2017 00:20:28.584] [demo-akka.actor.default-dispatcher-3] [akka://demo/user/supervisor/childA] null</span></span><br><span class="line"><span class="comment">java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">	at io.binglau.scala.akka.demo.SupervisorChild$$anonfun$receive$1.applyOrElse(Supervisor.scala:12)</span></span><br><span class="line"><span class="comment">	at akka.actor.Actor.aroundReceive(Actor.scala:513)</span></span><br><span class="line"><span class="comment">	at akka.actor.Actor.aroundReceive$(Actor.scala:511)</span></span><br><span class="line"><span class="comment">	at io.binglau.scala.akka.demo.SupervisorChild.aroundReceive(Supervisor.scala:9)</span></span><br><span class="line"><span class="comment">	at akka.actor.ActorCell.receiveMessage(ActorCell.scala:527)</span></span><br><span class="line"><span class="comment">	at akka.actor.ActorCell.invoke(ActorCell.scala:496)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.processMailbox(Mailbox.scala:257)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.run(Mailbox.scala:224)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.exec(Mailbox.scala:234)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[INFO] [09/14/2017 00:20:29.572] [demo-akka.actor.default-dispatcher-4] [akka://demo/user/supervisor/childA] unknow</span></span><br><span class="line"><span class="comment">[ERROR] [09/14/2017 00:20:29.573] [demo-akka.actor.default-dispatcher-3] [akka://demo/user/supervisor/childA] null</span></span><br><span class="line"><span class="comment">java.lang.IllegalArgumentException</span></span><br><span class="line"><span class="comment">	at io.binglau.scala.akka.demo.SupervisorChild$$anonfun$receive$1.applyOrElse(Supervisor.scala:14)</span></span><br><span class="line"><span class="comment">	at akka.actor.Actor.aroundReceive(Actor.scala:513)</span></span><br><span class="line"><span class="comment">	at akka.actor.Actor.aroundReceive$(Actor.scala:511)</span></span><br><span class="line"><span class="comment">	at io.binglau.scala.akka.demo.SupervisorChild.aroundReceive(Supervisor.scala:9)</span></span><br><span class="line"><span class="comment">	at akka.actor.ActorCell.receiveMessage(ActorCell.scala:527)</span></span><br><span class="line"><span class="comment">	at akka.actor.ActorCell.invoke(ActorCell.scala:496)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.processMailbox(Mailbox.scala:257)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.run(Mailbox.scala:224)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.Mailbox.exec(Mailbox.scala:234)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)</span></span><br><span class="line"><span class="comment">	at akka.dispatch.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[INFO] [09/14/2017 00:20:29.579] [demo-akka.actor.default-dispatcher-3] [akka://demo/user/supervisor/childA] Message [java.lang.String] from Actor[akka://demo/user/supervisor#347975802] to Actor[akka://demo/user/supervisor/childA#794249311] was not delivered. [1] dead letters encountered. This logging can be turned off or adjusted with configuration settings 'akka.log-dead-letters' and 'akka.log-dead-letters-during-shutdown'.</span></span><br><span class="line"><span class="comment">[INFO] [09/14/2017 00:20:53.607] [Thread-0] [CoordinatedShutdown(akka://demo)] Starting coordinated shutdown from JVM shutdown hook</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h3 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h3><p>当 Actor 系统被创建时，有几个 Actor 对象会随着它一起被创建。其中包括：</p>
<ul>
<li>root 守护对象</li>
<li>user 守护对象（应用程序创建的 Actor 对象上方）</li>
<li>system 守护对象</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// will look up this absolute path</span></span><br><span class="line">context.actorSelection(<span class="string">"/user/serviceA/aggregator"</span>)</span><br><span class="line"><span class="comment">// will look up sibling beneath same supervisor</span></span><br><span class="line">context.actorSelection(<span class="string">"../joe"</span>)</span><br><span class="line"><span class="comment">// remote</span></span><br><span class="line">context.actorSelection(<span class="string">"akka.tcp://app@otherhost:1234/user/serviceB"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h3><p>三个分类器：</p>
<ul>
<li><p>LookupClassification：通过匹配指定的事件类型，支持简单的查询操作。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// must define a full order over the subscribers, expressed as expected from</span></span><br><span class="line"><span class="comment">// `java.lang.Comparable.compare`  </span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">compareSubscribers</span></span>(a: <span class="type">Subscriber</span>, b: <span class="type">Subscriber</span>): <span class="type">Int</span> =</span><br><span class="line">  a.compareTo(b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>SubchannelClassification：通过匹配事件的类型和子类型，支持子通道层次结构</p>
</li>
<li><p>ScanningClassification：在某个事件落入两个或多个通道，并且需要将该事件发布给所有合法订阅者，因而需要扫描 EventBus 类的全部分类时，应混入该特征。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is needed for determining matching classifiers and storing them in an</span></span><br><span class="line"><span class="comment">// ordered collection</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">compareClassifiers</span></span>(a: <span class="type">Classifier</span>, b: <span class="type">Classifier</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) <span class="number">-1</span> <span class="keyword">else</span> <span class="keyword">if</span> (a == b) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// is needed for storing subscribers in an ordered collection  </span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">compareSubscribers</span></span>(a: <span class="type">Subscriber</span>, b: <span class="type">Subscriber</span>): <span class="type">Int</span> =</span><br><span class="line">  a.compareTo(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// determines whether a given classifier shall match a given event; it is invoked</span></span><br><span class="line"><span class="comment">// for each subscription for all received events, hence the name of the classifier  </span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">matches</span></span>(classifier: <span class="type">Classifier</span>, event: <span class="type">Event</span>): <span class="type">Boolean</span> =</span><br><span class="line">  event.length &lt;= classifier</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">ActorRef</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"><span class="keyword">import</span> akka.event.&#123;<span class="type">EventBus</span>, <span class="type">SubchannelClassification</span>&#125;</span><br><span class="line"><span class="keyword">import</span> akka.util.<span class="type">Subclassification</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgEnvelope</span>(<span class="params">topic: <span class="type">String</span>, payload: <span class="type">Any</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StartsWithSubClassification</span> <span class="keyword">extends</span> <span class="title">Subclassification</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">Boolean</span> = x == y</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isSubclass</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">Boolean</span> = x.startsWith(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubChannel</span> <span class="keyword">extends</span> <span class="title">EventBus</span> <span class="keyword">with</span> <span class="title">SubchannelClassification</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要处理的订阅事件</span></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">Event</span> </span>= <span class="type">MsgEnvelope</span></span><br><span class="line">  <span class="comment">// 分类器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">Classifier</span> </span>= <span class="type">String</span></span><br><span class="line">  <span class="comment">// 发布器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">Subscriber</span> </span>= <span class="type">ActorRef</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供两种方法 isEqual 和 isSubClass，将分类器作为一个参数 x 与 classify 返回的值作为另一个参数传入,</span></span><br><span class="line">  <span class="comment">// 两个方法返回任意 true 则可进入</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">subclassification</span></span>: <span class="type">Subclassification</span>[<span class="type">Classifier</span>] = <span class="keyword">new</span> <span class="type">StartsWithSubClassification</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅事件哪部分作为分类信息</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">classify</span></span>(event: <span class="type">Event</span>): <span class="type">Classifier</span> = event.topic</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分类之后的发布操作</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">publish</span></span>(event: <span class="type">Event</span>, subscriber: <span class="type">Subscriber</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    subscriber ! event.payload</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SubchannelDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"Test"</span>)</span><br><span class="line">    <span class="keyword">val</span> print = system.actorOf(<span class="type">Props</span>(classOf[<span class="type">Print</span>]), <span class="string">"print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> subchannelBus = <span class="keyword">new</span> <span class="type">SubChannel</span></span><br><span class="line">    <span class="comment">// 设置发布器和分类器</span></span><br><span class="line">    subchannelBus.subscribe(print, <span class="string">"abc"</span>)</span><br><span class="line">    subchannelBus.publish(<span class="type">MsgEnvelope</span>(<span class="string">"xyzabc"</span>, <span class="string">"x"</span>))</span><br><span class="line">    subchannelBus.publish(<span class="type">MsgEnvelope</span>(<span class="string">"bcdef"</span>, <span class="string">"b"</span>))</span><br><span class="line">    subchannelBus.publish(<span class="type">MsgEnvelope</span>(<span class="string">"abc"</span>, <span class="string">"c"</span>))</span><br><span class="line">    subchannelBus.publish(<span class="type">MsgEnvelope</span>(<span class="string">"abcdef"</span>, <span class="string">"d"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[INFO] [09/14/2017 23:42:47.268] [Test-akka.actor.default-dispatcher-5] [akka://Test/user/print] receive c</span></span><br><span class="line"><span class="comment">[INFO] [09/14/2017 23:42:47.269] [Test-akka.actor.default-dispatcher-5] [akka://Test/user/print] receive d</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h3 id="Dispatchers"><a href="#Dispatchers" class="headerlink" title="Dispatchers"></a>Dispatchers</h3><blockquote>
<p> 添加配置在 /src/main/resources 中添加一份 application.conf</p>
<p> An Akka <code>MessageDispatcher</code> is what makes Akka Actors “tick”, it is the engine of the machine so to speak. All <code>MessageDispatcher</code> implementations are also an <code>ExecutionContext</code>, which means that they can be used to execute arbitrary code, for instance <a href="http://doc.akka.io/docs/akka/current/scala/futures.html" target="_blank" rel="noopener">Futures</a>.</p>
</blockquote>
<h4 id="通过下面代码可以得到一个配置的-Dispatcher"><a href="#通过下面代码可以得到一个配置的-Dispatcher" class="headerlink" title="通过下面代码可以得到一个配置的 Dispatcher"></a>通过下面代码可以得到一个配置的 Dispatcher</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for use with Futures, Scheduler, etc.</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> executionContext = system.dispatchers.lookup(<span class="string">"my-dispatcher"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="设置-Dispatcher"><a href="#设置-Dispatcher" class="headerlink" title="设置 Dispatcher"></a>设置 Dispatcher</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-dispatcher &#123;</span><br><span class="line">  # Dispatcher is the name of the event-based dispatcher</span><br><span class="line">  type = Dispatcher</span><br><span class="line">  # What kind of ExecutionService to use</span><br><span class="line">  executor = &quot;fork-join-executor&quot;</span><br><span class="line">  # Configuration for the fork join pool</span><br><span class="line">  fork-join-executor &#123;</span><br><span class="line">    # Min number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-min = 2</span><br><span class="line">    # Parallelism (threads) ... ceil(available processors * factor)</span><br><span class="line">    parallelism-factor = 2.0</span><br><span class="line">    # Max number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-max = 10</span><br><span class="line">  &#125;</span><br><span class="line">  # Throughput defines the maximum number of messages to be</span><br><span class="line">  # processed per actor before the thread jumps to the next actor.</span><br><span class="line">  # Set to 1 for as fair as possible.</span><br><span class="line">  throughput = 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置Actor使用一个特定的disptacher:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">val</span> myActor = context.actorOf(<span class="type">Props</span>[<span class="type">MyActor</span>], <span class="string">"myactor"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">akka.actor.deployment &#123;</span><br><span class="line">  /myactor &#123;</span><br><span class="line">    dispatcher = my-dispatcher</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者在代码中设置</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.<span class="type">Props</span></span><br><span class="line"><span class="keyword">val</span> myActor =</span><br><span class="line">  context.actorOf(<span class="type">Props</span>[<span class="type">MyActor</span>].withDispatcher(<span class="string">"my-dispatcher"</span>), <span class="string">"myactor1"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul>
<li><p><strong>Dispatcher</strong></p>
<p>This is an event-based dispatcher that binds a set of Actors to a thread pool. It is the default dispatcher used if one is not specified.</p>
<ul>
<li>可共享性: 无限制</li>
<li>邮箱: 任何一种类型，为每一个Actor创建一个</li>
<li>使用场景: 默认派发器，Bulkheading</li>
<li>底层使用: <code>java.util.concurrent.ExecutorService</code><br>可以指定“executor”使用“fork-join-executor”, “thread-pool-executor” 或者 the FQCN(类名的全称) of an akka.dispatcher.ExecutorServiceConfigurator</li>
</ul>
</li>
<li><p><strong>PinnedDispatcher</strong></p>
<p>This dispatcher dedicates a unique thread for each actor using it; i.e. each actor will have its own thread pool with only one thread in the pool.</p>
<ul>
<li>可共享性: 无</li>
<li>邮箱: 任何一种类型，为每个Actor创建一个</li>
<li>使用场景: Bulkheading</li>
<li>底层使用: 任何 akka.dispatch.ThreadPoolExecutorConfigurator<br>缺省为一个 “thread-pool-executor”</li>
</ul>
</li>
<li><p><strong>CallingThreadDispatcher</strong></p>
<p>This dispatcher runs invocations on the current thread only. This dispatcher does not create any new threads, but it can be used from different threads concurrently for the same actor. See <a href="http://doc.akka.io/docs/akka/current/scala/testing.html#callingthreaddispatcher" target="_blank" rel="noopener">CallingThreadDispatcher</a> for details and restrictions.</p>
<ul>
<li>可共享性: 无限制</li>
<li>邮箱: 任何一种类型，每Actor每线程创建一个（需要时）</li>
<li>使用场景: 测试</li>
<li>底层使用: 调用的线程 (duh)</li>
</ul>
</li>
</ul>
<h3 id="确保送达机制"><a href="#确保送达机制" class="headerlink" title="确保送达机制"></a>确保送达机制</h3><p><code>at-least-once-delivery</code></p>
<blockquote>
<p> To send messages with at-least-once delivery semantics to destinations you can mix-in <code>AtLeastOnceDelivery</code> trait to your <code>PersistentActor</code> on the sending side. It takes care of re-sending messages when they have not been confirmed within a configurable timeout.</p>
<p> 结合持久化保证一定时间被确认（发送端）</p>
<p> The state of the sending actor, including which messages have been sent that have not been confirmed by the recipient must be persistent so that it can survive a crash of the sending actor or JVM. The <code>AtLeastOnceDelivery</code> trait does not persist anything by itself. It is your responsibility to persist the intent that a message is sent and that a confirmation has been received.</p>
<p> AtLeastOnceDelivery 不会持久化任何东西，你需要去持久化试图发送的消息并处理确认信息</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorSelection</span>&#125;</span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"><span class="keyword">import</span> akka.persistence.&#123;<span class="type">AtLeastOnceDelivery</span>, <span class="type">PersistentActor</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span>(<span class="params">deliveryId: <span class="type">Long</span>, s: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Confirm</span>(<span class="params">deliveryId: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">sealed</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">其修饰的trait，class只能在当前文件里面被继承</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">用sealed修饰这样做的目的是告诉scala编译器在检查模式匹配的时候，</span></span></span><br><span class="line"><span class="class"><span class="title">//</span>   <span class="title">让scala知道这些case的所有情况，scala就能够在编译的时候进行检查，</span></span></span><br><span class="line"><span class="class"><span class="title">//</span>   <span class="title">看你写的代码是否有没有漏掉什么没case到，减少编程的错误。</span></span></span><br><span class="line"><span class="class"><span class="title">sealed</span> <span class="title">trait</span> <span class="title">Evt</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">MsgSent</span>(<span class="params">s: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Evt</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">MsgConfirmed</span>(<span class="params">deliveryId: <span class="type">Long</span></span>) <span class="keyword">extends</span> <span class="title">Evt</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyPersistentActor</span>(<span class="params">destination: <span class="type">ActorSelection</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">PersistentActor</span> <span class="keyword">with</span> <span class="title">AtLeastOnceDelivery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在任何情况下，从主题 / 队列持久性 Actor 对象接收消息的持久性视图 Actor 实例，</span></span><br><span class="line">  <span class="comment">// 都会将它的  persistenceId 作为相应主题 / 队列持久性 Actor 对象标识符</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">persistenceId</span></span>: <span class="type">String</span> = <span class="string">"persistence-id"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 receiveCommand 来接受新消息</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveCommand</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="comment">// To send messages to the destination path, use the **deliver** method after</span></span><br><span class="line">    <span class="comment">// you have persisted the intent to send the message.</span></span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">String</span>           =&gt; persist(<span class="type">MsgSent</span>(s))(updateState)</span><br><span class="line">    <span class="comment">// The destination actor must send back a confirmation message.</span></span><br><span class="line">    <span class="comment">// When the sending actor receives this confirmation message you should</span></span><br><span class="line">    <span class="comment">// persist the fact that the message was delivered successfully</span></span><br><span class="line">    <span class="comment">// and then call the confirmDelivery method.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Confirm</span>(deliveryId) =&gt; persist(<span class="type">MsgConfirmed</span>(deliveryId))(updateState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送确认回执</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveRecover</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> evt: <span class="type">Evt</span> =&gt; updateState(evt)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">updateState</span></span>(evt: <span class="type">Evt</span>): <span class="type">Unit</span> = evt <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="comment">// deliver自动产生一个deliveryId，这个deliveryId是发送方与接收方沟通的标志</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">MsgSent</span>(s) =&gt;</span><br><span class="line">      deliver(destination)(deliveryId =&gt; <span class="type">Msg</span>(deliveryId, s))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">MsgConfirmed</span>(deliveryId) =&gt; confirmDelivery(deliveryId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDestination</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Msg</span>(deliveryId, s) =&gt;</span><br><span class="line">      log.info(s)</span><br><span class="line">      sender() ! <span class="type">Confirm</span>(deliveryId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 也可参考 Stream 相关内容</p>
</blockquote>
<h3 id="应用Demo"><a href="#应用Demo" class="headerlink" title="应用Demo"></a>应用Demo</h3><h4 id="请求—回复模式"><a href="#请求—回复模式" class="headerlink" title="请求—回复模式"></a>请求—回复模式</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorRef</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>(<span class="params">what: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Reply</span>(<span class="params">what: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">StartWith</span>(<span class="params">server: <span class="type">ActorRef</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">方式</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> 1. <span class="title">发送消息带上</span> <span class="title">server</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> 2. <span class="title">初始化带上</span> <span class="title">server</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StartWith</span>(server) =&gt;</span><br><span class="line">      println(<span class="string">"Client: is starting..."</span>)</span><br><span class="line">      server ! <span class="type">Request</span>(<span class="string">"REQ-1"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Reply</span>(what) =&gt;</span><br><span class="line">      println(<span class="string">"Client: received response: "</span> + what)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      println(<span class="string">"Client: received unexpected message"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 一个 Actor 对象可以通过下列方式获得其他 Actor 对象的地址</span></span><br><span class="line"><span class="comment">  * 1. 一个 Actor 对象创建了另一个 Actor 对象</span></span><br><span class="line"><span class="comment">  * 2. 一个 Actor 对象收到消息，包含其他 Actor 对象地址</span></span><br><span class="line"><span class="comment">  * 3. 有时 Actor 对象可以根据名称（selection）查询 Actor，但是这么做会带来不合适的定义和实现束缚</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Request</span>(what) =&gt;</span><br><span class="line">      println(<span class="string">"Server: received request value: "</span> + what)</span><br><span class="line">      sender ! <span class="type">Reply</span>(<span class="string">"RESP-1 for "</span> + what)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      println(<span class="string">"Server: received unexpected message"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RequestReplyDemo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"demo"</span>)</span><br><span class="line">  <span class="keyword">val</span> client = system.actorOf(<span class="type">Props</span>[<span class="type">Client</span>], <span class="string">"client"</span>)</span><br><span class="line">  <span class="keyword">val</span> server = system.actorOf(<span class="type">Props</span>[<span class="type">Server</span>], <span class="string">"server"</span>)</span><br><span class="line">  client ! <span class="type">StartWith</span>(server)</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"RequestReply: is completed."</span>)</span><br><span class="line">  system.terminate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管道与过滤器"><a href="#管道与过滤器" class="headerlink" title="管道与过滤器"></a>管道与过滤器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorRef</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessIncomingOrder</span>(<span class="params">orderInfo: <span class="type">Array</span>[<span class="type">Byte</span>]</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Authenticator</span>(<span class="params">nextFilter: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> message: <span class="type">ProcessIncomingOrder</span> =&gt;</span><br><span class="line">      <span class="keyword">val</span> text = <span class="keyword">new</span> <span class="type">String</span>(message.orderInfo)</span><br><span class="line">      println(<span class="string">s"Authenticator: processing <span class="subst">$text</span>"</span>)</span><br><span class="line">      <span class="keyword">val</span> orderText = text.replace(<span class="string">"(certificate)"</span>, <span class="string">""</span>)</span><br><span class="line">      nextFilter ! <span class="type">ProcessIncomingOrder</span>(orderText.toCharArray.map(_.toByte))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decrypter</span>(<span class="params">nextFilter: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> message: <span class="type">ProcessIncomingOrder</span> =&gt;</span><br><span class="line">      <span class="keyword">val</span> text = <span class="keyword">new</span> <span class="type">String</span>(message.orderInfo)</span><br><span class="line">      println(<span class="string">s"Decrypter: processing <span class="subst">$text</span>"</span>)</span><br><span class="line">      <span class="keyword">val</span> orderText = text.replace(<span class="string">"(encryption)"</span>, <span class="string">""</span>)</span><br><span class="line">      nextFilter ! <span class="type">ProcessIncomingOrder</span>(orderText.toCharArray.map(_.toByte))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deduplicator</span>(<span class="params">nextFilter: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> processedOrderIds = scala.collection.mutable.<span class="type">Set</span>[<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">orderIdFrom</span></span>(orderText: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> orderIdIndex = orderText.indexOf(<span class="string">"id='"</span>) + <span class="number">4</span></span><br><span class="line">    <span class="keyword">val</span> orderIdLastIndex = orderText.indexOf(<span class="string">"'"</span>, orderIdIndex)</span><br><span class="line">    orderText.substring(orderIdIndex, orderIdLastIndex)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> message: <span class="type">ProcessIncomingOrder</span> =&gt;</span><br><span class="line">      <span class="keyword">val</span> text = <span class="keyword">new</span> <span class="type">String</span>(message.orderInfo)</span><br><span class="line">      println(<span class="string">s"Deduplicator: processing <span class="subst">$text</span>"</span>)</span><br><span class="line">      <span class="keyword">val</span> orderId = orderIdFrom(text)</span><br><span class="line">      <span class="keyword">if</span> (processedOrderIds.add(orderId)) &#123;</span><br><span class="line">        nextFilter ! message</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">s"Deduplicator: found duplicate order <span class="subst">$orderId</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderAcceptanceEndpoint</span>(<span class="params">nextFilter: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> rawOrder: <span class="type">Array</span>[<span class="type">Byte</span>] =&gt;</span><br><span class="line">      <span class="keyword">val</span> text = <span class="keyword">new</span> <span class="type">String</span>(rawOrder)</span><br><span class="line">      println(<span class="string">s"OrderAcceptanceEndpoint: processing <span class="subst">$text</span>"</span>)</span><br><span class="line">      nextFilter ! <span class="type">ProcessIncomingOrder</span>(rawOrder)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderManagementSystem</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> message: <span class="type">ProcessIncomingOrder</span> =&gt;</span><br><span class="line">      <span class="keyword">val</span> text = <span class="keyword">new</span> <span class="type">String</span>(message.orderInfo)</span><br><span class="line">      println(<span class="string">s"OrderManagementSystem: processing unique order: <span class="subst">$text</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PipesAndFilterDemo</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"demo"</span>)</span><br><span class="line">  <span class="keyword">val</span> orderText = <span class="string">"(encryption)(certificate)&lt;order id='123'&gt;...&lt;/order&gt;"</span></span><br><span class="line">  <span class="keyword">val</span> rawOrderBytes = orderText.toCharArray.map(_.toByte)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链式过滤器</span></span><br><span class="line">  <span class="keyword">val</span> filter5 = system.actorOf(<span class="type">Props</span>[<span class="type">OrderManagementSystem</span>], <span class="string">"orderManagementSystem"</span>)</span><br><span class="line">  <span class="keyword">val</span> filter4 = system.actorOf(<span class="type">Props</span>(classOf[<span class="type">Deduplicator</span>], filter5), <span class="string">"deduplicator"</span>)</span><br><span class="line">  <span class="keyword">val</span> filter3 = system.actorOf(<span class="type">Props</span>(classOf[<span class="type">Authenticator</span>], filter4), <span class="string">"authenticator"</span>)</span><br><span class="line">  <span class="keyword">val</span> filter2 = system.actorOf(<span class="type">Props</span>(classOf[<span class="type">Decrypter</span>], filter3), <span class="string">"decrypter"</span>)</span><br><span class="line">  <span class="keyword">val</span> filter1 = system.actorOf(<span class="type">Props</span>(classOf[<span class="type">OrderAcceptanceEndpoint</span>], filter2), <span class="string">"orderAcceptanceEndpoint"</span>)</span><br><span class="line"></span><br><span class="line">  filter1 ! rawOrderBytes</span><br><span class="line">  filter1 ! rawOrderBytes</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"PipesAndFilters: is completed."</span>)</span><br><span class="line"></span><br><span class="line">  system.terminate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息有效期"><a href="#消息有效期" class="headerlink" title="消息有效期"></a>消息有效期</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorRef</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration.<span class="type">Duration</span></span><br><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将过期判断操作信息加入消息中</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ExpiringMessage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> occurredOn = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">  <span class="keyword">val</span> timeToLive: <span class="type">Long</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isExpired</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> elapsed = <span class="type">System</span>.currentTimeMillis() - occurredOn</span><br><span class="line"></span><br><span class="line">    elapsed &gt; timeToLive</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrder</span>(<span class="params">id: <span class="type">String</span>, itemId: <span class="type">String</span>, price: <span class="type">Double</span>, timeToLive: <span class="type">Long</span></span>) <span class="keyword">extends</span> <span class="title">ExpiringMessage</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">模拟各种原因导致的消息传输协议延迟</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PurchaseRouter</span>(<span class="params">purchaseAgent: <span class="type">ActorRef</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> random = <span class="keyword">new</span> <span class="type">Random</span>((<span class="keyword">new</span> <span class="type">Date</span>()).getTime)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> message: <span class="type">Any</span> =&gt;</span><br><span class="line">      <span class="keyword">val</span> millis = random.nextInt(<span class="number">100</span>) + <span class="number">1</span></span><br><span class="line">      println(<span class="string">s"PurchaseRouter: delaying delivery of <span class="subst">$message</span> for <span class="subst">$millis</span> milliseconds"</span>)</span><br><span class="line">      <span class="keyword">val</span> duration = <span class="type">Duration</span>.create(millis, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">      context.system.scheduler.scheduleOnce(duration, purchaseAgent, message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurchaseAgent</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> placeOrder: <span class="type">PlaceOrder</span> =&gt;</span><br><span class="line">      <span class="keyword">if</span> (placeOrder.isExpired) &#123;</span><br><span class="line">        context.system.deadLetters ! placeOrder</span><br><span class="line">        println(<span class="string">s"PurchaseAgent: delivered expired <span class="subst">$placeOrder</span> to dead letters"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">s"PurchaseAgent: placing order for <span class="subst">$placeOrder</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> message: <span class="type">Any</span> =&gt;</span><br><span class="line">      println(<span class="string">s"PurchaseAgent: received unexpected: <span class="subst">$message</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MessageExpirationDemo</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"demo"</span>)</span><br><span class="line">  <span class="keyword">val</span> purchaseAgent = system.actorOf(<span class="type">Props</span>[<span class="type">PurchaseAgent</span>], <span class="string">"purchaseAgent"</span>)</span><br><span class="line">  <span class="keyword">val</span> purchaseRouter = system.actorOf(<span class="type">Props</span>(classOf[<span class="type">PurchaseRouter</span>], purchaseAgent), <span class="string">"purchaseRouter"</span>)</span><br><span class="line"></span><br><span class="line">  purchaseRouter ! <span class="type">PlaceOrder</span>(<span class="string">"1"</span>, <span class="string">"11"</span>, <span class="number">50.00</span>, <span class="number">1000</span>)</span><br><span class="line">  purchaseRouter ! <span class="type">PlaceOrder</span>(<span class="string">"2"</span>, <span class="string">"22"</span>, <span class="number">250.00</span>, <span class="number">100</span>)</span><br><span class="line">  purchaseRouter ! <span class="type">PlaceOrder</span>(<span class="string">"3"</span>, <span class="string">"33"</span>, <span class="number">32.95</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">Thread</span>.sleep(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">  println(<span class="string">"MessageExpiration: is completed."</span>)</span><br><span class="line">  system.terminate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://wiki.fnil.net/index.php?title=Clojure%E5%B9%B6%E5%8F%91" target="_blank" rel="noopener"></a></p>
<p><a href="http://doc.akka.io/docs/akka/current/scala/index-actors.html" target="_blank" rel="noopener">Akka 官方文档</a><br>《响应式架构——消息模式 Actor 实现与 Scala、Akka 应用集成》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/并发的姿势/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/并发的姿势/" itemprop="url">并发的姿势</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:54:03+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发的姿势"><a href="#并发的姿势" class="headerlink" title="并发的姿势"></a>并发的姿势</h2><h4 id="并行还是并发？"><a href="#并行还是并发？" class="headerlink" title="并行还是并发？"></a>并行还是并发？</h4><p>并发：<strong>同一时间应对</strong>多件事情的能力</p>
<p>并行：<strong>同一时间动手</strong>做多件事情的能力</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_24/1.jpg?raw=true" alt="并发与并行"></p>
<p>并发：两队列人享有一台咖啡机，每列都能获得咖啡</p>
<p>并行：一队列人享有独有的咖啡机，互不干扰</p>
<p>而获取咖啡从局部来看又是串行，每个人都需要等前面人使用完成后才能使用（并发中也可能需要不定等别队列的人来获取）</p>
<h3 id="Java-的线程与锁模型"><a href="#Java-的线程与锁模型" class="headerlink" title="Java 的线程与锁模型"></a>Java 的线程与锁模型</h3><p>线程：Java 并发中的基本单元，可以将一个线程看做一个控制流，线程之间通过共享内存进行通信。</p>
<p>使用锁来达到在使用共享内存时，线程之间的使用形成互斥的目的。</p>
<p>简单的哲学家问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.binglau.bean.Chopstick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述: 哲学家问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Chopstick left, right;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 死锁：当所有人都持有一只筷子并等待另一个放开一只筷子</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">100</span>) * <span class="number">10</span>); <span class="comment">// 思考时间</span></span><br><span class="line">                <span class="comment">// 获取对象锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (left) &#123; <span class="comment">// 拿起筷子 1</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (right)  &#123; <span class="comment">// 拿起筷子 2</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"-ok"</span>);</span><br><span class="line">                        Thread.sleep(random.nextInt(<span class="number">100</span>) * <span class="number">10</span>); <span class="comment">// 进餐时间</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick();</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick();</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick();</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Philosopher(c1, c2)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Philosopher(c2, c3)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Philosopher(c3, c4)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Philosopher(c4, c1)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程与所模型带来的三个主要危害：</p>
<ul>
<li>静态条件</li>
<li>死锁</li>
<li>内存可见性（Java 内存模型定义了何时一个线程对内存的修改对另一个线程可见，这样两个线程都需要进行同步的情况下，线程获得的一个值可能已经是一个失效的值）</li>
</ul>
<p>优势：</p>
<ul>
<li>普遍，更接近本质，能解决几乎所有粒度的所有问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>难以维护</li>
<li>难以测试（共享内存决定的不确定性）</li>
</ul>
<h3 id="『天然』的并发，函数式编程"><a href="#『天然』的并发，函数式编程" class="headerlink" title="『天然』的并发，函数式编程"></a>『天然』的并发，函数式编程</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;用于延时执行某个函数</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> make-heavy [f]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [&amp; args]</span><br><span class="line">    (<span class="name">Thread/sleep</span> <span class="number">1000</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">apply</span></span> f args)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">time</span></span> (<span class="name"><span class="builtin-name">doall</span></span> (<span class="name"><span class="builtin-name">map</span></span> (<span class="name">make-heavy</span> inc) [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>])))</span><br><span class="line">(<span class="name"><span class="builtin-name">time</span></span> (<span class="name"><span class="builtin-name">doall</span></span> (<span class="name">pmap</span> (<span class="name">make-heavy</span> inc) [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment">;"Elapsed time: 5012.47372 msecs"</span></span><br><span class="line"><span class="comment">;"Elapsed time: 1012.144992 msecs"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;pmap并行地将make-heavy包装后的inc作用在集合的5个元素上，总耗时就接近于于单个调用的耗时，也就是一秒。</span></span><br><span class="line"><span class="comment">;pmap的并行，从实现上来说，是集合有多少个元素就使用多少个线程</span></span><br></pre></td></tr></table></figure>
<p>容易推理，便于测试，消除并发与串行的区别</p>
<h3 id="通信顺序进程"><a href="#通信顺序进程" class="headerlink" title="通信顺序进程"></a>通信顺序进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrency</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文件描述：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine 使用时候的一些问题</span></span><br><span class="line"><span class="comment">// 1. 主 goroutine 结束后 子 goroutine 也会结束</span></span><br><span class="line"><span class="comment">// 2. 容易发生死锁，就是即使所有工作已经完成了但</span></span><br><span class="line"><span class="comment">// 主 goroutine 无法获得工作 goroutine 的 完成状态。</span></span><br><span class="line"><span class="comment">// 死锁的另一个情况就是，当两个不同的 goroutine (或者线程)</span></span><br><span class="line"><span class="comment">// 都锁定了受保护的资源而且同时尝试去获取对方资源的时候</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 解决办法:</span></span><br><span class="line"><span class="comment">// 1. 下面所示主 goroutine 在一个 done 通道上等待</span></span><br><span class="line"><span class="comment">// 2. 使用 sync.WaitGroup 来让每个工作 goroutine 报告自己</span></span><br><span class="line"><span class="comment">// 的完成状态。但是，使用 sync.WaitGroup 本身也会产生死锁，</span></span><br><span class="line"><span class="comment">// 特别是当所有工作 goroutine 都处于锁定状态的时候（等待接收</span></span><br><span class="line"><span class="comment">// 通道的数据）调用 sync.WaitGroup.Wait()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通道为并发运行的 goroutine 之间提供了一种无锁的通信方式（尽管</span></span><br><span class="line"><span class="comment">// 内部实现可能使用了锁，但我们无需关系）。当一个通道发生通信时，发</span></span><br><span class="line"><span class="comment">// 送通道和接收通道（包括它们对应的 goroutine）都处于同步状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 语言并不保证在通道里发送指针或者引用类型（如切片或映射）的安全性，</span></span><br><span class="line"><span class="comment">// 因为指针指向的内容或者所引用的值可能在对方接收到时已被发送方修改。</span></span><br><span class="line"><span class="comment">// 所有，当涉及到指针和引用时，我们必须保证这些值在任何时候只能被一</span></span><br><span class="line"><span class="comment">// 个 goroutine 访问得到，也就是说，对这些值的访问必须是串行进行的。</span></span><br><span class="line"><span class="comment">// 除非文档特别声明传递这个指针是安全的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用并发最简单的方式就是用一个 goroutine 来准备工作</span></span><br><span class="line"><span class="comment">// 然后让另一个 goroutine 来执行处理，让主 goroutine 和</span></span><br><span class="line"><span class="comment">// 一些通道来安排一切事情</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	jobList := <span class="built_in">make</span>([]Job, <span class="number">10</span>)  <span class="comment">// 任务列表</span></span><br><span class="line">	jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> Job)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="built_in">len</span>(jobList))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 创建 goroutine</span></span><br><span class="line">		<span class="keyword">for</span> _, job := <span class="keyword">range</span> jobList &#123; <span class="comment">// 遍历 jobList 然后将每个工作发送到 jobs 通道</span></span><br><span class="line">			jobs &lt;- job <span class="comment">// 通道没有缓冲，所以马上阻塞，等待别的 goroutine 接收</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(jobs) <span class="comment">// 发完任务之后关闭通道</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123; <span class="comment">// 接收上面的 goroutine 传来的 job (从 jobs 通道)</span></span><br><span class="line">			job.Id = <span class="number">1</span></span><br><span class="line">			job.Name = <span class="string">"Name"</span></span><br><span class="line">			fmt.Println(job)</span><br><span class="line">			done &lt;- <span class="literal">true</span> <span class="comment">// 发送完成表示等待主 goroutine 接收</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(jobList); i++ &#123;</span><br><span class="line">		&lt;- done <span class="comment">// 阻塞，等待接收</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于通道的使用，我们有两个经验。</span></span><br><span class="line">	<span class="comment">// 一. 我们只有在后面要检查通道是否关闭（例如在一个 for ... range 循环</span></span><br><span class="line">	<span class="comment">// 里，或者 select, 或者使用 &lt;- 操作符来检查是否可以接收等）的时候才需要</span></span><br><span class="line">	<span class="comment">// 显式地关闭通道；</span></span><br><span class="line">	<span class="comment">// 二. 应该由发送端的 goroutine 关闭通道，而不是由接收端的 goroutine 来完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>Actor 是一种计算实体，它会对收到的消息做出回应，并且可以做下列事情：</p>
<ul>
<li>向其他 Actor 对象发送一定数量的消息</li>
<li>创建一定数量的新 Actor 对象</li>
<li>设定对下一条消息做出的回应方式</li>
</ul>
<h5 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h5><p>以前的我，使用过一种类似于 Actor 发送消息的并发模式，使用消息队列来做并发，最典型的莫过于使用 <code>rabbitmq</code> 的 <code>celery</code></p>
<p>一般是这样的，写一个 <code>worker</code> 在一个进程跑着，通过 <code>celery</code> 来调用 <code>worker</code></p>
<blockquote>
<p> <strong>Celery is used in production systems to process millions of tasks a day.</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> celery_demo.worker <span class="keyword">import</span> demo_worker</span><br><span class="line"></span><br><span class="line"><span class="comment"># celery_app.py</span></span><br><span class="line"><span class="comment"># celery -A celery_demo.worker.celery_app worker -l info</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">RABBITMQ_DSN = <span class="string">'amqp://guest@127.0.0.1'</span></span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'worker'</span>,</span><br><span class="line">             broker=RABBITMQ_DSN,</span><br><span class="line">             include=[<span class="string">'celery_demo.worker.demo_worker'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo_worker.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery_demo.worker.celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    result = x + y</span><br><span class="line">    log.app.info(<span class="string">f'result: <span class="subst">&#123;result&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  </span><br><span class="line"><span class="comment"># demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery_demo.worker <span class="keyword">import</span> demo_worker</span><br><span class="line"><span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    demo_worker.add.delay(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    log.app.info(<span class="string">'end'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># log</span></span><br><span class="line">[INFO app <span class="number">2017</span><span class="number">-09</span><span class="number">-09</span> <span class="number">11</span>:<span class="number">53</span>:<span class="number">28</span>,<span class="number">992</span>] end</span><br><span class="line">[INFO app <span class="number">2017</span><span class="number">-09</span><span class="number">-09</span> <span class="number">11</span>:<span class="number">53</span>:<span class="number">31</span>,<span class="number">997</span>] result: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h5 id="Akka"><a href="#Akka" class="headerlink" title="Akka"></a>Akka</h5><blockquote>
<p> Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala</p>
<ul>
<li>Simpler Concurrent &amp; Distributed Systems</li>
<li>Resilient by Design</li>
<li>High Performance</li>
<li>Elastic &amp; Decentralized</li>
<li>Reactive Streaming Data</li>
</ul>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binglau.scala.akka.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"><span class="keyword">import</span> akka.event.<span class="type">Logging</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActorPrint</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> log = <span class="type">Logging</span>(context.system, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> msg : <span class="type">String</span> =&gt; log.info(<span class="string">"receive &#123;&#125;"</span>, msg)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; log.info(<span class="string">"receive unknow message"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ActorDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"demo"</span>)</span><br><span class="line">    <span class="keyword">val</span> printActor = system.actorOf(<span class="type">Props</span>[<span class="type">ActorPrint</span>], <span class="string">"print"</span>)</span><br><span class="line"></span><br><span class="line">    printActor ! <span class="string">"Test"</span></span><br><span class="line">    printActor ! <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    system.terminate()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Actor-系统和-Actor-对象具有的特点："><a href="#Actor-系统和-Actor-对象具有的特点：" class="headerlink" title="Actor 系统和 Actor 对象具有的特点："></a>Actor 系统和 Actor 对象具有的特点：</h5><ul>
<li><p>直接通过异步消息传递方式进行通信</p>
<p>同一个 Actor 对象发送保证顺序，但是不同的 Actor 对象之间的发送不能保证顺序</p>
</li>
<li><p>状态机</p>
<p>当 Actor 对象转换为某个预设状态时，就能够改变对未来接收到的消息的处理模式。通过变为另一种消息处理器，Actor对象就成了一种有限状态机。</p>
</li>
<li><p>无共享</p>
<p>一个 Actor 对象不会与其他 Actor 对象或相关组件共享可变状态</p>
</li>
<li><p>无锁的并发处理方式</p>
<p>因为 Actor 对象不会共享它们的可变状态，而且它们在同一时刻仅会接收一条消息，所以在对消息做出回应前，Actor 对象永远都不需要尝试锁定它们的状态。</p>
</li>
<li><p>并行性</p>
<p>当等级较高的 Actor 对象能够将多个任务分派给多个下级 Actor 对象，或者任务重含有复杂的处理层级时，就适合通过 Actor 模型使用并行处理方式。</p>
</li>
<li><p>Actor 对象的系统性</p>
<p>Actor 对象的量级都非常轻，因此在单个系统中添加许多 Actor 对象是受推荐的处理方式。任何问题都可以通过添加 Actor 对象来解决。</p>
</li>
</ul>
<h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><p><a href="http://wiki.fnil.net/index.php?title=Clojure%E5%B9%B6%E5%8F%91" target="_blank" rel="noopener">Clojure并发</a><br><a href="http://doc.akka.io/docs/akka/current/scala/index-actors.html" target="_blank" rel="noopener">Akka 官方文档</a><br>《七周七并发模式》<br>《响应式架构——消息模式 Actor 实现与 Scala、Akka 应用集成》<br>《Go 语言程序设计》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/MySQL-EXPLAIN-注/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/MySQL-EXPLAIN-注/" itemprop="url">MySQL-EXPLAIN 注</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:53:32+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="EXPLAIN-中列的含义"><a href="#EXPLAIN-中列的含义" class="headerlink" title="EXPLAIN 中列的含义"></a>EXPLAIN 中列的含义</h3><ul>
<li><strong>id：</strong> 标识 <code>SELECT</code> 所属的行。如果在语句中没有子查询或联合，那么只会有唯一的 <code>SELECT</code>，于是每一行在这个列中都将显示一个 1。否则，内层 <code>SELECT</code> 语句一般会顺序编号，对应于其在原始语句中的位置。</li>
<li><strong>select_type：</strong> 显示了对应行是简单还是复杂 <code>SELECT</code>（如果是后者，那么是三种复杂类型中的哪一种）。<ul>
<li><code>SIMPLE</code>：查询中不包含子查询和 <code>UNION</code></li>
<li><code>PRIMARY</code>：有任何复杂的子部分</li>
<li><code>SUBQUERY</code>：包含在 <code>SELECT</code> 列表中的子查询的 <code>SELECT</code>（换句话说，不在 <code>FROM</code> 子句中）</li>
<li><code>DERIVED</code>：表示包含在 <code>FROM</code> 子句的子查询中的 <code>SELECT</code>，MySQL 会递归执行并将结果放在一个临时表中。服务器内部称为『派生表』，因为该临时表是从子查询中派生来的。</li>
<li><code>UNION</code>：在 <code>UNION</code> 中的第二个和随后的 <code>SELECT</code> 被标记为 <code>UNION</code>。第一个 <code>SELECT</code> 被标记就好像它以部分外查询来执行。</li>
<li><code>UNION RESULT</code>：用来从 UNION 的匿名临时表检索结果的 <code>SELECT</code> 被标记为 <code>UNION RESULT</code>。</li>
</ul>
</li>
<li><strong>table：</strong> 显示对应行正在访问哪个表。当 FROM 子句中有子查询或有 <code>UNION</code> 时，由于 MySQL 创建的匿名临时表仅在查询执行过程中存在。<ul>
<li>当在 <code>FROM</code> 子句中有子查询时，table 列是 <code>&lt;derivedN&gt;</code> 的形式，其中 N 是子查询的 id、这总是『向前引用』—— 换言之，N 指向 <code>EXPLAIN</code> 输出中后面的一行。</li>
<li>当有 <code>UNION</code> 时，<code>UNION RESULT</code> 的 table 列包含一个参与 <code>UNION</code> 的 id 列表。这总是『向后引用』，因为 <code>UNION RESULT</code> 出现在 <code>UNION</code> 中所有参与行之后。</li>
</ul>
</li>
<li><strong>partitions：</strong> 代表给定表所使用的分区。</li>
<li><strong>type：</strong> 访问类型——换言之就是 MySQL 决定如何查找表中的行。下面是最重要的访问方法，依次从最差到最优：<ul>
<li>ALL：全表扫描，通常意味着 MySQL 必须扫描整张表，从头到尾，去找到需要的行。（例外是使用了 LIMIT 或者在 Extra 列中显示 “Using distinct/not exists”）</li>
<li>index： 这个跟全表扫描一样，只是 MySQL 扫描表时按索引次序进行而不是行。它的主要优点是避免了排序；最大的缺点是要承担按索引次序读取整个表的开销。这通常意味着若是按随机次序访问行，开销将会非常大。如果在 Extra 列中看到 “Using index”，说明 MySQL 正在使用覆盖索引，它只扫描索引的数据，而不是按索引次序的每一行。它比按索引次序全表扫描的开销要少很多。</li>
<li>range： 范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。它比全索引扫描好一些，因为它用不着遍历全部索引。显而易见的范围扫描是带有 <code>BETWEEN</code> 或在 <code>WHERE</code> 子句中带有 &gt; 的查询。当 MySQL 使用索引去查找一系列值时，例如 <code>IN()</code> 和 <code>OR</code> 列表，也会显示为范围扫描。<strong>然而，这两者其实是相当不同的访问类型</strong>，在性能上有重要的差异。具体可查看 《高性能 MySQL》 第五章文章『什么是范围条件』。</li>
<li>ref：这是一种索引访问（有时也叫做索引查找），它返回所有匹配某个单个值的行。然而，它有可能会找到多个符合条件的行，因此，它是查找和扫描的混合体。此类索引访问只有当使用<strong>非唯一性索引</strong>或者<strong>唯一性索引的非唯一性前缀</strong>时才会发生。把它叫做 ref 是因为索引要跟某个参考值相比较。ref_or_null 是 ref 智商的一个变体，它意味着 MySQL 必须在初次查找的结果里进行第二次查找以找出 <code>NULL</code> 条目。</li>
<li>eq_ref：使用这种所有查找，MySQL 知道最多只返回一条符合条件的查询。这种访问方法可以在 MySQL 使用主键或者唯一性索引查找时看到，它会将它们与某个参考值做比较。</li>
<li>const, system：当 MySQL 能对查询的某部分进行优化并将其转换成一个常量时，它就会使用这些访问类型。举例来说，如果你通过将某一行的主键放入 <code>WHERE</code> 子句里的方式来选取此行的主键，MySQL 就能把这个查询转换为一个常量。然后就可以高效地将表从联接执行中移除。</li>
<li>NULL：这种访问方式意味着 MySQL 能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。例如，从一个索引列里选取最小值可以通过单独查找索引来完成，不需要再执行时访问表。</li>
</ul>
</li>
<li><strong>possible_keys：</strong> 显示了查询可以使用哪些索引，这是基于查询访问的列和使用的比较操作符来判断的。这个列表是在优化过程的早起创建的，因此有些罗列出来的索引可能对于后续优化过程是没用的。</li>
<li><strong>key：</strong> 显示了 MySQL 决定采用哪个索引来优化对该表的访问。如果该索引没有出现在 possible_keys 列中，那么 MySQL 选用它是出于另外的原因——例如，它可能选择了一个覆盖所有，哪怕没有 <code>WHERE</code> 子句。换句话说， possible_keys 揭示了哪一个索引能有助于高效地行查找，而 key 显示的是优化采用哪一个索引可以最小化查询成本。</li>
<li><strong>key_len：</strong> MySQL 在索引里使用的字节数。</li>
<li><strong>ref：</strong> 显示了之前表在 key 列记录的索引中查找值所用的列或常量。</li>
<li><strong>rows：</strong> MySQL 估计为了找到所需的行而要读取的行数。</li>
<li><strong>filtered：</strong> 针对表里符合某个条件（WHERE 子句或联接条件）的记录数的百分比所做的一个悲观估计。</li>
<li><strong>Extra：</strong> 包含的是不适用在其他列显示的额外信息。常见的最重要的值如下：<ul>
<li>Using index：使用了覆盖索引。</li>
<li>Using where：MySQL 服务器将在存储引擎检索行后再进行过滤。许多 <code>WHERE</code> 条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带 <code>WHERE</code> 子句的查询都会显示 “Using where” 。有时 “Using where” 的出现就是一个暗示：查询可受益于不同的索引。</li>
<li>Using temporary：意味着 MySQL 在对查询结果排序时会使用一个临时表。</li>
<li>Using filesort：这意味着 MySQL 会在结果使用一个外部索引排序，而不是按索引次序从表里读取行。MySQL 有两种文件排序算法，两种方式都可以在内存或磁盘上完成。EXPLAIN 不会告诉你 MySQL 将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。</li>
<li>Range checked for each record (index map: N)：这个值以为着没有好用的索引，新的索引将在联接的每一行上重新估计。N 是显示在 possible_keys 列中索引的位图，并且是冗余的。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/AOP的道理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/AOP的道理/" itemprop="url">AOP的道理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:53:04+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>在某些情况下，一个客户<strong>不想或者不能直接引用一个对象</strong>，此时可以<strong>通过一个称之为“代理”的第三者来实现 间接引用</strong>。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以<strong>通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务</strong>。</p>
<p>通过引入一个新的对象（如小图片和远程代理对象）来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p>
<h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_22/Proxy.png?raw=true" alt="Proxy UML"></p>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类ProxySubject.java的实现描述：<span class="doctag">TODO:</span>类实现描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bingjian.lbj 2016-09-17 下午6:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxySubject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类RealSubject.java的实现描述：<span class="doctag">TODO:</span>类实现描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bingjian.lbj 2016-09-17 下午6:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">ProxySubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestContent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealSubject</span><span class="params">(String requestContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestContent = requestContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealSubject request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 保存一个引用使得代理可以访问实体。若RealSubject和ProxySubject的接口相同, Proxy会引用ProxySubject。</span></span><br><span class="line"><span class="comment"> * 2. 提供一个与ProxySubject的接口相同的接口,这样代理就可以用来替代实体。</span></span><br><span class="line"><span class="comment"> * 3. 控制对实体的存取,并可能负责创建和删除它。</span></span><br><span class="line"><span class="comment"> * 4. 其他功能依赖于代理的类型:</span></span><br><span class="line"><span class="comment"> *      1) Remote Proxy负责对请求及其参数进行编码,并向不同地址空间中的实体发送已编码的请求。</span></span><br><span class="line"><span class="comment"> *      2) Virtual Proxy可以缓存实体的附加信息,以便延迟对它的访问。</span></span><br><span class="line"><span class="comment"> *      3) Protection Proxy检查调用者是否具有实现一个请求所必需的访问权限。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bingjian.lbj 2016-09-17 下午6:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ProxySubject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestContent;</span><br><span class="line">    <span class="keyword">private</span> RealSubject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(String requestContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestContent = requestContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subject = <span class="keyword">new</span> RealSubject(requestContent);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Proxy request"</span>);</span><br><span class="line">        subject.operation();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxySubject subject = <span class="keyword">new</span> Proxy(<span class="string">"test"</span>);</span><br><span class="line">        subject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h4><ul>
<li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li>
<li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li>
</ul>
<h3 id="Java-中的动态代理"><a href="#Java-中的动态代理" class="headerlink" title="Java 中的动态代理"></a>Java 中的动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.proxy.static_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;  <span class="comment">// 1. 公共接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.proxy.static_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123; <span class="comment">// 1. 委托类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello! "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.proxy.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.binglau.proxy.static_proxy.Hello;</span><br><span class="line"><span class="keyword">import</span> io.github.binglau.proxy.static_proxy.HelloImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要是解决静态代理中对于不同的接口都需要实现一个代理类的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         * 1. ClassLoader</span></span><br><span class="line"><span class="comment">         * 2. 该实现类的所有接口</span></span><br><span class="line"><span class="comment">         * 3. 动态代理对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">      </span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(hello);</span><br><span class="line">       </span><br><span class="line">        Hello helloProxy = dynamicProxy.getProxy(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        helloProxy.say(<span class="string">"Jack"</span>);</span><br><span class="line">        System.out.println(Proxy.getInvocationHandler(helloProxy)); <span class="comment">// 获得代理对象对应的调用处理器对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        Proxy 其他方法：</span></span><br><span class="line"><span class="comment">        Class getProxyClass(ClassLoader loader, Class[] interfaces): 根据类加载器和实现的接口获得代理类。</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Before</span></span><br><span class="line"><span class="comment">Hello! Jack</span></span><br><span class="line"><span class="comment">After</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h4 id="Java实现动态代理的大致步骤如下："><a href="#Java实现动态代理的大致步骤如下：" class="headerlink" title="Java实现动态代理的大致步骤如下："></a>Java实现动态代理的大致步骤如下：</h4><ol>
<li><p>定义一个委托类和公共接口。</p>
</li>
<li><p>自己定义一个类（调用处理器类，即实现 <code>InvocationHandler</code> 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类。</p>
</li>
<li><p>生成代理对象（当然也会生成代理类），需要为他指定：</p>
<ol>
<li>委托对象</li>
<li>实现的一系列接口(3)调用处理器类的实例。</li>
</ol>
<p>因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</p>
</li>
</ol>
<h3 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.binglau.proxy.static_proxy.Hello;</span><br><span class="line"><span class="keyword">import</span> io.github.binglau.proxy.static_proxy.HelloImpl;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代理没有接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Enhancer是CGLib的字节码增强器，可以方便的对类进行扩展，内部调用GeneratorStrategy.generate方法生成代理类的字节码</span></span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同 JDK 动态代理一样，每个方法的调用都会调用 intercept 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CGLibProxy cgLibProxy = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">        Hello helloProxy = cgLibProxy.getProxy(HelloImpl.class);</span><br><span class="line">        helloProxy.say(<span class="string">"Jack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Before</span></span><br><span class="line"><span class="comment">Hello! Jack</span></span><br><span class="line"><span class="comment">After</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h3 id="Spring-的-AOP"><a href="#Spring-的-AOP" class="headerlink" title="Spring 的 AOP"></a>Spring 的 AOP</h3><p>AOP 框架不会去修改字节码，而是在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理。具体可看上文介绍。</p>
<p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLib 来动态代理目标类。CGLib（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLib 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code> ，那么它是无法使用 CGLib 做动态代理的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.jobbole.com/105423/" target="_blank" rel="noopener">说说 cglib 动态代理</a></p>
<p><a href="http://www.importnew.com/24305.html" target="_blank" rel="noopener">Spring AOP的实现原理</a></p>
<p>《从零开始写 Java Web 框架》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/分析一波-Java-线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/分析一波-Java-线程池/" itemprop="url">分析一波 Java 线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:51:43+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Executors-executeCase"><a href="#Executors-executeCase" class="headerlink" title="Executors.executeCase"></a>Executors.executeCase</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a thread pool that reuses a fixed number of threads operating</span></span><br><span class="line"><span class="comment">         * off a shared unbounded queue, using the provided ThreadFactory to create</span></span><br><span class="line"><span class="comment">         * new threads when needed. At any point, at most nThreads threads will be</span></span><br><span class="line"><span class="comment">         * active processing tasks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">10</span>; <span class="comment">// Default</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDown = countDown;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span> + id + <span class="string">"("</span> +</span><br><span class="line">                (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">"Liftoff!"</span>) + <span class="string">"), "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(status());</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a thread pool that reuses a fixed number of threads</span></span><br><span class="line"><span class="comment"> * operating off a shared unbounded queue.  At any point, at most</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> nThreads&#125; threads will be active processing tasks.</span></span><br><span class="line"><span class="comment"> * If additional tasks are submitted when all threads are active,</span></span><br><span class="line"><span class="comment"> * they will wait in the queue until a thread is available.</span></span><br><span class="line"><span class="comment"> * If any thread terminates due to a failure during execution</span></span><br><span class="line"><span class="comment"> * prior to shutdown, a new one will take its place if needed to</span></span><br><span class="line"><span class="comment"> * execute subsequent tasks.  The threads in the pool will exist</span></span><br><span class="line"><span class="comment"> * until it is explicitly &#123;<span class="doctag">@link</span> ExecutorService#shutdown shutdown&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads the number of threads in the pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default rejected execution handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">    <span class="keyword">new</span> AbortPolicy();  <span class="comment">// 策略</span></span><br></pre></td></tr></table></figure>
<h4 id="ThreadFactory-Default"><a href="#ThreadFactory-Default" class="headerlink" title="ThreadFactory(Default)"></a>ThreadFactory(Default)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a default thread factory used to create new threads.</span></span><br><span class="line"><span class="comment"> * This factory creates all new threads used by an Executor in the</span></span><br><span class="line"><span class="comment"> * same &#123;<span class="doctag">@link</span> ThreadGroup&#125;. If there is a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.lang.SecurityManager&#125;, it uses the group of &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * System#getSecurityManager&#125;, else the group of the thread</span></span><br><span class="line"><span class="comment"> * invoking this &#123;<span class="doctag">@code</span> defaultThreadFactory&#125; method. Each new</span></span><br><span class="line"><span class="comment"> * thread is created as a non-daemon thread with priority set to</span></span><br><span class="line"><span class="comment"> * the smaller of &#123;<span class="doctag">@code</span> Thread.NORM_PRIORITY&#125; and the maximum</span></span><br><span class="line"><span class="comment"> * priority permitted in the thread group.  New threads have names</span></span><br><span class="line"><span class="comment"> * accessible via &#123;<span class="doctag">@link</span> Thread#getName&#125; of</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;pool-N-thread-M&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the sequence</span></span><br><span class="line"><span class="comment"> * number of this factory, and &lt;em&gt;M&lt;/em&gt; is the sequence number</span></span><br><span class="line"><span class="comment"> * of the thread created by this factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a thread factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor-构造器"><a href="#ThreadPoolExecutor-构造器" class="headerlink" title="ThreadPoolExecutor 构造器"></a>ThreadPoolExecutor 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters and default thread factory and rejected execution handler.</span></span><br><span class="line"><span class="comment"> * It may be more convenient to use one of the &#123;<span class="doctag">@link</span> Executors&#125; factory</span></span><br><span class="line"><span class="comment"> * methods instead of this general purpose constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">    * parameters.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">    *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">    *        pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">    *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">    *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">    *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">    *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">    *        creates a new thread</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">    *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">    *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">workQueue</span></span><br><span class="line"><span class="comment">用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</span></span><br><span class="line"><span class="comment">	1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</span></span><br><span class="line"><span class="comment">	2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</span></span><br><span class="line"><span class="comment">	3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；</span></span><br><span class="line"><span class="comment">	4、priorityBlockingQuene：具有优先级的无界阻塞队列；</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">handler</span></span><br><span class="line"><span class="comment">线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</span></span><br><span class="line"><span class="comment">	1、AbortPolicy：直接抛出异常，默认策略；</span></span><br><span class="line"><span class="comment">	2、CallerRunsPolicy：用调用者所在的线程来执行任务；</span></span><br><span class="line"><span class="comment">	3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</span></span><br><span class="line"><span class="comment">	4、DiscardPolicy：直接丢弃任务；</span></span><br><span class="line"><span class="comment">当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment">  * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment">  * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment">  * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment">  *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment">  *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">      * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">      * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">      * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">      * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">      * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">      * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">      * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">      * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">      * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">      * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">      * and so reject the task.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">//     private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：</span></span><br><span class="line"><span class="comment">1、RUNNING：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</span></span><br><span class="line"><span class="comment">2、SHUTDOWN： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</span></span><br><span class="line"><span class="comment">3、STOP ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</span></span><br><span class="line"><span class="comment">4、TIDYING ： 2 &lt;&lt; COUNT_BITS，即高3位为010；</span></span><br><span class="line"><span class="comment">5、TERMINATED： 3 &lt;&lt; COUNT_BITS，即高3位为011；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// workerCountOf方法根据ctl的低29位，得到线程池的当前线程数，如果线程数小于corePoolSize，则执行addWorker方法创建新的线程执行任务</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="comment">// 再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务，则执行reject方法处理任务</span></span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line">         <span class="comment">// 如果得到线程池数量等于0，则添加一条新线程,来替代当前线程,继续去执行队列中的任务.</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 执行addWorker方法创建新的线程执行任务, 如果addWoker执行失败，则执行reject方法处理任务</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Methods for creating, running and cleaning up after workers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 判断线程池的状态，如果线程池的状态值大于或等SHUTDOWN，则不处理提交的任务，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 通过参数core判断当前需要创建的线程是否为核心线程，如果core为true，且当前线程数小于corePoolSize，则跳出循环，开始创建新的线程</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Worker类来实现线程工作流程，具体实现看下一个代码块</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在ReentrantLock锁的保证下，将 Worker 实例插入 HaseSet(workers)</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行 Worker</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Class Worker mainly maintains interrupt control state for</span></span><br><span class="line"><span class="comment">   * threads running tasks, along with other minor bookkeeping.</span></span><br><span class="line"><span class="comment">   * This class opportunistically extends AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment">   * to simplify acquiring and releasing a lock surrounding each</span></span><br><span class="line"><span class="comment">   * task execution.  This protects against interrupts that are</span></span><br><span class="line"><span class="comment">   * intended to wake up a worker thread waiting for a task from</span></span><br><span class="line"><span class="comment">   * instead interrupting a task being run.  We implement a simple</span></span><br><span class="line"><span class="comment">   * non-reentrant mutual exclusion lock rather than use</span></span><br><span class="line"><span class="comment">   * ReentrantLock because we do not want worker tasks to be able to</span></span><br><span class="line"><span class="comment">   * reacquire the lock when they invoke pool control methods like</span></span><br><span class="line"><span class="comment">   * setCorePoolSize.  Additionally, to suppress interrupts until</span></span><br><span class="line"><span class="comment">   * the thread actually starts running tasks, we initialize lock</span></span><br><span class="line"><span class="comment">   * state to a negative value, and clear it upon start (in</span></span><br><span class="line"><span class="comment">   * runWorker).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 继承了AQS类，可以方便的实现工作线程的中止操作</span></span><br><span class="line">  <span class="comment">// 实现了Runnable接口，可以将自身作为一个任务在工作线程中执行；</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">       * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">      <span class="keyword">final</span> Thread thread;</span><br><span class="line">      <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">      Runnable firstTask;</span><br><span class="line">      <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 当前提交的任务firstTask作为参数传入Worker的构造方法</span></span><br><span class="line">      <span class="comment">// 从Woker类的构造方法实现可以发现：线程工厂在创建线程thread时，将Woker实例本身this作为参数传入，当执行start方法启动线程thread时，本质是执行了Worker的runWorker方法。</span></span><br><span class="line">      Worker(Runnable firstTask) &#123;</span><br><span class="line">          setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">          <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">          <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          runWorker(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Lock methods</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">      <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">          setState(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Thread t;</span><br><span class="line">          <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  t.interrupt();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="runWorker（线程执行核心处）"><a href="#runWorker（线程执行核心处）" class="headerlink" title="runWorker（线程执行核心处）"></a>runWorker（线程执行核心处）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment"> * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment"> * don't need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment"> * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment"> * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment"> * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment"> * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment"> * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment"> * other pool interrupts while the task is executing, and then we</span></span><br><span class="line"><span class="comment"> * ensure that unless pool is stopping, this thread does not have</span></span><br><span class="line"><span class="comment"> * its interrupt set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment"> * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment"> * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment"> * the task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment"> * gathering any of its thrown exceptions to send to afterExecute.</span></span><br><span class="line"><span class="comment"> * We separately handle RuntimeException, Error (both of which the</span></span><br><span class="line"><span class="comment"> * specs guarantee that we trap) and arbitrary Throwables.</span></span><br><span class="line"><span class="comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span></span><br><span class="line"><span class="comment"> * wrap them within Errors on the way out (to the thread's</span></span><br><span class="line"><span class="comment"> * UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment"> * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment"> * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment"> * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment"> * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment"> * and the thread's UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment"> * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment"> * user code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">  	<span class="comment">// 获取第一个任务firstTask</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 线程启动之后，通过unlock方法释放锁，设置AQS的state为0，表示运行中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在执行任务之前，会进行加锁操作，任务执行完会释放锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 在执行任务的前后，可以根据业务场景自定义beforeExecute和afterExecute方法；</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务的run方法</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 在执行任务的前后，可以根据业务场景自定义beforeExecute和afterExecute方法；</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取队列任务-getTaks"><a href="#获取队列任务-getTaks" class="headerlink" title="获取队列任务 getTaks()"></a>获取队列任务 getTaks()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment"> * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment"> * must exit because of any of:</span></span><br><span class="line"><span class="comment"> * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment"> *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment"> * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment"> * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment"> * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment"> *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment"> *    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment"> *    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment"> *         workerCount is decremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 整个getTask操作在自旋下完成</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                <span class="comment">// workQueue.poll：如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                <span class="comment">// workQueue.take：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；</span></span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Future和Callable实现"><a href="#Future和Callable实现" class="headerlink" title="Future和Callable实现"></a>Future和Callable实现</h3><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService execute = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    Future&lt;String&gt; future = execute.submit(<span class="keyword">new</span> Task());</span><br><span class="line">    System.out.println(<span class="string">"do other things"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = future.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is future case"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><ol>
<li>FutureTask在不同阶段拥有不同的状态state，初始化为NEW；</li>
<li>FutureTask类实现了Runnable接口，这样就可以通过Executor.execute方法提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Revision notes: This differs from previous versions of this</span></span><br><span class="line"><span class="comment">     * class that relied on AbstractQueuedSynchronizer, mainly to</span></span><br><span class="line"><span class="comment">     * avoid surprising users about retaining interrupt status during</span></span><br><span class="line"><span class="comment">     * cancellation races. Sync control in the current design relies</span></span><br><span class="line"><span class="comment">     * on a "state" field updated via CAS to track completion, along</span></span><br><span class="line"><span class="comment">     * with a simple Treiber stack to hold waiting threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Style note: As usual, we bypass overhead of using</span></span><br><span class="line"><span class="comment">     * AtomicXFieldUpdaters and instead directly use Unsafe intrinsics.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The run state of this task, initially NEW.  The run state</span></span><br><span class="line"><span class="comment">     * transitions to a terminal state only in methods set,</span></span><br><span class="line"><span class="comment">     * setException, and cancel.  During completion, state may take on</span></span><br><span class="line"><span class="comment">     * transient values of COMPLETING (while outcome is being set) or</span></span><br><span class="line"><span class="comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span></span><br><span class="line"><span class="comment">     * cancel(true)). Transitions from these intermediate to final</span></span><br><span class="line"><span class="comment">     * states use cheaper ordered/lazy writes because values are unique</span></span><br><span class="line"><span class="comment">     * and cannot be further modified.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Possible state transitions:</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line">    <span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    <span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment">     * given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask-get"><a href="#FutureTask-get" class="headerlink" title="FutureTask.get()"></a>FutureTask.get()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">// 记住这个 outcome</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部通过awaitDone方法对主线程进行阻塞，然后由 <code>report()</code> 返回具体实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed true if use timed waits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos time to wait, if timed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> state upon completion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果主线程被中断，则抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">// 判断FutureTask当前的state，如果大于COMPLETING，说明任务已经执行完成，则直接返回</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前state等于COMPLETING，说明任务已经执行完，这时主线程只需通过yield方法让出cpu资源，等待state变成NORMAL</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// 通过WaitNode类封装当前线程，并通过UNSAFE添加到waiters链表</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="comment">// 最终通过LockSupport的park或parkNanos挂起线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask-run-，上文分析的-execute-最终执行的方法"><a href="#FutureTask-run-，上文分析的-execute-最终执行的方法" class="headerlink" title="FutureTask.run()，上文分析的 execute 最终执行的方法"></a>FutureTask.run()，上文分析的 execute 最终执行的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过执行Callable任务的call方法</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 如果call执行有异常，则通过setException保存异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果call执行成功，则通过set方法保存结果</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask-set"><a href="#FutureTask-set" class="headerlink" title="FutureTask.set()"></a>FutureTask.set()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the result of this future to the given value unless</span></span><br><span class="line"><span class="comment"> * this future has already been set or has been cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is invoked internally by the &#123;<span class="doctag">@link</span> #run&#125; method</span></span><br><span class="line"><span class="comment"> * upon successful completion of the computation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v the value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">// 还记得那个 outcome 吗</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">// 通过UNSAFE修改FutureTask的状态，并执行finishCompletion方法通知主线程任务已经执行完成</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask-setException"><a href="#FutureTask-setException" class="headerlink" title="FutureTask.setException()"></a>FutureTask.setException()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes this future to report an &#123;<span class="doctag">@link</span> ExecutionException&#125;</span></span><br><span class="line"><span class="comment"> * with the given throwable as its cause, unless this future has</span></span><br><span class="line"><span class="comment"> * already been set or has been cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is invoked internally by the &#123;<span class="doctag">@link</span> #run&#125; method</span></span><br><span class="line"><span class="comment"> * upon failure of the computation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the cause of failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask-finishCompletion"><a href="#FutureTask-finishCompletion" class="headerlink" title="FutureTask.finishCompletion()"></a>FutureTask.finishCompletion()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// FutureTask任务执行完成后，通过UNSAFE设置waiters的值，并通过LockSupport类unpark方法唤醒主线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行FutureTask类的get方法时，会把主线程封装成WaitNode节点并保存在waiters链表中</span></span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/select，-poll，-epoll，-信号驱动-IO细讲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/select，-poll，-epoll，-信号驱动-IO细讲/" itemprop="url">select， poll， epoll， 信号驱动 IO细讲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:51:10+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>63章 其他备选的 IO 模型</p>
</blockquote>
<h3 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h3><p>实际上 I/O 多路复用，信号驱动 I/O 以及 epool 都是用来实现同一个目标的技术——同时检查多个文件描述符，看它们是否准备好了执行 I/O 操作（准确地说，是看 I/O 系统调用是否可以非阻塞地执行）。文件描述符就绪状态的转化是通过一些 I/O 事件来触发的，比如输入数据到达，套接字连接建立完成，或者是之前满载的套接字发送缓冲区在 TCP 将队列中的数据传送到对端之后由了剩余空间。同时检查多个文件描述符在类似网络服务器的应用中很有用处，或者是那么必须同事检查终端以及管道或套接字输入的应用程序。</p>
<p>需要注意的是这些技术都不会执行实际的 I/O 操作。它们只是告诉我们某个文件描述符已经处于就绪状态了，这时需要调用其他的系统调用来完成实际的 I/O 操作。</p>
<h4 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a>水平触发和边缘触发</h4><ul>
<li>水平触发通知：如果文件描述符上可以非阻塞地执行 I/O 系统调用，此时任务它已经就绪。</li>
<li>边缘触发通知：如果文件描述符自上次状态检查以来有了新的 I/O 活动（比如新的输入），此时需要触发通知。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">I/O 模式</th>
<th style="text-align:center">水平触发</th>
<th style="text-align:center">边缘触发</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">select(), pool()</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">信号驱动 I/O</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">epool</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p>当采用水平触发通知时，我们可以在任意时刻检查文件描述符的就绪状态。这表示当我们确定了文件描述符处于就绪态时（比如存在输入数据），就可以对其执行一些 I/O 操作，然后重复检查文件描述符，看看是否仍然处于就绪态（比如还有更多的输入数据），此时我们就能执行更多的 I/O，以此类推。换句话说，由于水平触发模式允许我们在任意时刻重复检查 I/O 状态，没有必要每次当文件描述符就绪后需要尽可能多地执行 I/O （也就是尽可能多地读取字节，亦或是根本不去执行任何 I/O）。</p>
<p>与此相反的是，当我们采用边缘触发时，只有当 I/O 事件发生时我们才会收到通知。在另一个 I/O 事件到来前我们不会收到任何新的通知。另外，当文件描述符收到 I/O 事件通知时，通常我们并不知道要处理多少 I/O（例如有多少字节可读）。因此，采用边缘触发通知的程序通常要按照如下规则来设计。</p>
<ul>
<li>在接收到一个 I/O 事件通知后，程序在某个时刻应该在相应的文件描述符上尽可能多地执行 I/O（比如尽可能多地读取字节）。如果程序没有这么做，那么就可能失去执行 I/O 的机会。因为直到产生另一个 I/O 事件位置，在此之前程序都不会再接收到通知了，因此也就不知道此时应该执行 I/O 操作。这将导致数据丢失或者程序中出现阻塞。</li>
<li>如果程序采用循环来对文件描述符执行尽可能多的 I/O ，而文件描述符又被置为可阻塞的，那么最终当没有更多的 I/O 可执行时，I/O 系统调用就会被阻塞。基于这个原因，每个被检查的文件描述符通常都应该置为非阻塞模式，在得到 I/O 事件通知后重复执行 I/O 操作，直到相应的系统调用(比如 write(), read()) 以错误码 EAGAIN 或 EWOULDBLOCK 的形式失联。</li>
</ul>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3><h4 id="select-系统调用"><a href="#select-系统调用" class="headerlink" title="select() 系统调用"></a>select() 系统调用</h4><p>系统调用 <code>select()</code> 会一直阻塞，直到一个或多个文件描述符集合成为就绪态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrun number of ready file descriptors, 0 on timeout, or -1 on error.</span></span><br></pre></td></tr></table></figure>
<p>参数 <code>readfds</code>, <code>writefds</code> 以及 <code>exceptfds</code> 都是指向文件描述符集合的指针，所指向的数据类型是 fd_set,。这些参数按照如下方式使用。</p>
<ul>
<li><p><code>readfds</code> 是用来检测输入是否就绪的文件描述符集合</p>
</li>
<li><p><code>writefds</code> 是用来检测输出是否就绪的文件描述符集合</p>
</li>
<li><p><code>exceotfds</code> 是用来检测异常情况是否发生的文件描述符集合</p>
<p> 在 Linux 上，一个异常情况只有下面两种情况下发生：</p>
<ul>
<li>连接到处于信号模式下的伪终端设备上的从设备状态发生了改变</li>
<li>流式套接字上接收到了带外数据</li>
</ul>
</li>
</ul>
<p>通常，数据类型 <code>fd_set</code> 以位掩码的形式来实现。但是是由下面四个宏来完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;             <span class="comment">// 初始化为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;      <span class="comment">// 将文件描述符 fd 添加入集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;      <span class="comment">// 将 fd 移除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;     <span class="comment">// fd 是否在集合中，是返回1，否则返回0</span></span><br></pre></td></tr></table></figure>
<p>文件描述符集合有一个最大容量限制，由常量 FD_SETSIZE 来决定。在 Linux 上，该常量的值为1024。</p>
<p>参数<code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 所指向的结构体都是保存结果值的地方。在调用 <code>select()</code> 之前，这些参数指向的结构体必须初始化（通过<code>FD_ZERO() 和 FD_SET()</code>），以包含我们感兴趣的文件描述符集合。之后 <code>select()</code> 调用会修改这些结构体，当 <code>select()</code> 返回时，它们包含的就是已处于就绪态的文件描述符集合了（值-结果参数）。（由于这些结构体会在调用中被修改，如果要在循环中反复调用<code>select()</code>，我们必须保证每次都要重新初始化它们。）之后这些结构体可以通过 <code>FD_ISSET()</code> 来检查。</p>
<p><strong>timeout 参数</strong></p>
<p>参数 <code>timeout</code> 控制着 <code>select()</code> 的阻塞行为。该参数可指定为 <code>NULL</code>，此时 <code>select()</code> 会一直阻塞。又或者是指向一个  <code>timeval</code> 结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="keyword">time_t</span>      tv_sec;      <span class="comment">/*Seconds */</span></span><br><span class="line">  <span class="keyword">suseconds_t</span> tv_usec;     <span class="comment">/* Microseconds (long int) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果结构体 <code>timeval</code> 的两个域都为0的话，此时 <code>select()</code> 不会阻塞，它只是简单地轮询指定的文件描述符集合，看看其中是否有就绪的文件描述符并立即返回。否则，<code>timeout</code> 将为 <code>select()</code> 指定一个等待时间的上限值。</p>
<p>当 <code>timeout</code> 设为 <code>NULL</code> ，或其指向的结构体字段非零时， <code>select()</code> 将阻塞直到有下列事件发生：</p>
<ul>
<li><code>readfds</code>、 <code>writefds</code> 或 <code>exceptfds</code> 中指定的文件描述符中至少有一个成为就绪态；</li>
<li>该调用被信号处理例程中断</li>
<li><code>timeout</code> 中指定的时间上限已超时</li>
</ul>
<p><code>select()</code> 返回所在3个集合中被标记为就绪态的文件描述符总数。如果返回 -1 则是错误发生，包括 <code>EBADF</code> 和 <code>EINTR</code>。如果返回 0 则说明超时。</p>
<h5 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"t_select.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">usageError(<span class="keyword">const</span> <span class="keyword">char</span> *progName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s &#123;timeout|-&#125; fd-num[rw]...\n"</span>, progName);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"    - means infinite timeout; \n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"    r = monitor for read\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"    w = monitor for write\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"    e.g.: %s - 0rw 1w\n"</span>, progName);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 介绍一下用法</span></span><br><span class="line"><span class="comment"> * ./basic 10 0r 1w 第一个10是超时秒数， 0是文件描述符号，r代表读文件，w 代表写文件</span></span><br><span class="line"><span class="comment"> * 文件描述符中，0是标准输入，1是标准输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">testSelect(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    fd_set readfds, writefds;</span><br><span class="line">    <span class="keyword">int</span> ready, nfds, fd, numRead, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">pto</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];                       <span class="comment">/* Large enough to hold "rw\0" */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageError(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Timeout for select() is specified in argv[1] */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        pto = <span class="literal">NULL</span>;                     <span class="comment">/* Infinite timeout */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pto = &amp;timeout;</span><br><span class="line">        <span class="comment">// 输入中获取时间</span></span><br><span class="line">        timeout.tv_sec = getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">"timeout"</span>);</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;            <span class="comment">/* No microseconds */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process remaining arguments to build file descriptor sets */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化读写描述符集合</span></span><br><span class="line">    nfds = <span class="number">0</span>;</span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_ZERO(&amp;writefds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别将读描述符和写描述符加入</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        numRead = <span class="built_in">sscanf</span>(argv[j], <span class="string">"%d%2[rw]"</span>, &amp;fd, buf);</span><br><span class="line">        <span class="keyword">if</span> (numRead != <span class="number">2</span>)</span><br><span class="line">            usageError(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= FD_SETSIZE)</span><br><span class="line">            cmdLineErr(<span class="string">"file descriptor exceeds limit (%d)\n"</span>, FD_SETSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= nfds)</span><br><span class="line">            nfds = fd + <span class="number">1</span>;              <span class="comment">/* Record maximum fd + 1 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(buf, <span class="string">'r'</span>) != <span class="literal">NULL</span>)</span><br><span class="line">            FD_SET(fd, &amp;readfds);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(buf, <span class="string">'w'</span>) != <span class="literal">NULL</span>)</span><br><span class="line">            FD_SET(fd, &amp;writefds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We've built all of the arguments; now call select() */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    ready = select(nfds, &amp;readfds, &amp;writefds, <span class="literal">NULL</span>, pto);</span><br><span class="line">    <span class="comment">/* Ignore exceptional events */</span></span><br><span class="line">    <span class="keyword">if</span> (ready == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"select"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Display results of select() */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ready = %d\n"</span>, ready);</span><br><span class="line">    <span class="keyword">for</span> (fd = <span class="number">0</span>; fd &lt; nfds; fd++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %s%s\n"</span>, fd, FD_ISSET(fd, &amp;readfds) ? <span class="string">"r"</span> : <span class="string">""</span>,</span><br><span class="line">               FD_ISSET(fd, &amp;writefds) ? <span class="string">"w"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pto != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"timeout after select(): %ld.%03ld\n"</span>,</span><br><span class="line">               (<span class="keyword">long</span>) timeout.tv_sec, (<span class="keyword">long</span>) timeout.tv_usec / <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="poll-系统调用"><a href="#poll-系统调用" class="headerlink" title="poll() 系统调用"></a><code>poll()</code> 系统调用</h4><p>系统调用 <code>poll()</code> 执行的任务同 <code>select()</code> 很相似。两者间主要的区别在于我们要如何制定待检查的文件描述符。在 <code>select()</code> 中，我们提供三个集合，在每个集合中标明我们感兴趣的文件描述符。而在  <code>poll()</code> 中我们提供一列文件描述符，并在每个文件描述符上标明我们感兴趣的事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns number of ready file descriptors, 0 on timeout, or -1 on error</span></span><br></pre></td></tr></table></figure>
<p>参数 <code>fds</code> 列出了我们需要 <code>poll()</code> 来检查的文件描述符。该参数为 <code>pollfd</code> 结构体数组，其定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>   fd;           <span class="comment">/* File descriptor */</span></span><br><span class="line">  <span class="keyword">short</span> events;       <span class="comment">/* Requested events bit mask */</span></span><br><span class="line">  <span class="keyword">short</span> revents;      <span class="comment">/* Returned events bit mask */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>pollfd</code> 结构体中的 <code>events</code> 和 <code>revents</code> 字段都是位掩码。调用者初始化 <code>events</code> 来指定需要为描述符 <code>fd</code> 做检查的事件。当 <code>poll()</code> 返回时，<code>revents</code> 被设定以此来表示该文件描述符上实际发生的事件。</p>
<p><strong>输入事件相关位掩码</strong></p>
<table>
<thead>
<tr>
<th>位掩码</th>
<th style="text-align:center">events 中的输入</th>
<th style="text-align:center">返回到 revents</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>POLLIN</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>可读取非高优先级的数据</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>等同于 POLLIN</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>可读取优先级数据（Linux 中不使用）</td>
</tr>
<tr>
<td>POLLPRI</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>可读取高优先级数据</td>
</tr>
<tr>
<td>POLLRDHUP</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>对端套接字关闭</td>
</tr>
</tbody>
</table>
<p><strong>输出事件相关位掩码</strong></p>
<table>
<thead>
<tr>
<th>位掩码</th>
<th style="text-align:center">events 中的输入</th>
<th style="text-align:center">返回到 revents</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>POLLOUT</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>普通数据可写</td>
</tr>
<tr>
<td>POLLWRNORM</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>等同于 POLLOUT</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>优先级数据可写入</td>
</tr>
</tbody>
</table>
<p><strong>返回有关文件描述符附加信息的位掩码</strong></p>
<table>
<thead>
<tr>
<th>位掩码</th>
<th style="text-align:center">events 中的输入</th>
<th style="text-align:center">返回到 revents</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>POLLERR</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td>有错误发生</td>
</tr>
<tr>
<td>POLLHUP</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td>出现挂断</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td>文件描述符未打开</td>
</tr>
</tbody>
</table>
<p><strong>timeout 参数</strong></p>
<ul>
<li>-1：阻塞直到有一个文件描述符达到就绪态或者捕获到一个信号</li>
<li>0: 不会阻塞，只是执行一次检查看看哪个文件描述符处于就绪态</li>
<li>大于0：至多阻塞 timeout 毫秒，知道 fds 列出的文件描述符中有一个达到就绪态，或者知道捕获到一个信号位置。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>-1：有错误</li>
<li>0：超时</li>
<li>大于0：表示数组 fds 重有用非零 revents 字段的 pollfd 结构体数量</li>
</ul>
<h5 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"poll_pipes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个程序创建了一些管道（每个管道使用一对连续的文件描述符），将</span></span><br><span class="line"><span class="comment"> * 字节写到随机选择的管道写端，然后通过 poll() 来检查看哪个管道中有数据可进行读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">testPoll(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> numPipes, j, ready, randPipe, numWrites;</span><br><span class="line">    <span class="keyword">int</span> (*pfds)[<span class="number">2</span>];                                 <span class="comment">/* File descriptors for all pipes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">pollFd</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">"%s num-pipes [num-writes]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管道数</span></span><br><span class="line">    numPipes = getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">"num-pipes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配读写管道文件描述符内存</span></span><br><span class="line">    pfds = <span class="built_in">calloc</span>(numPipes, <span class="keyword">sizeof</span>(<span class="keyword">int</span> [<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">if</span> (pfds == <span class="literal">NULL</span>)</span><br><span class="line">        errExit(<span class="string">"malloc"</span>);</span><br><span class="line">    <span class="comment">// 对于每对管道分配一个 pollFd 内存</span></span><br><span class="line">    pollFd = <span class="built_in">calloc</span>(numPipes, <span class="keyword">sizeof</span>(struct pollfd));</span><br><span class="line">    <span class="keyword">if</span> (pollFd == <span class="literal">NULL</span>)</span><br><span class="line">        errExit(<span class="string">"malloc"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numPipes; j++)</span><br><span class="line">        <span class="comment">// 创建管道, pfds[j][0] 是读管道，pfds[j][1] 是写管道</span></span><br><span class="line">        <span class="keyword">if</span> (pipe(pfds[j]) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"pipe %d"</span>, j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可写数据管道数</span></span><br><span class="line">    numWrites = (argc &gt; <span class="number">2</span>) ? getInt(argv[<span class="number">2</span>], GN_GT_0, <span class="string">"num-writes"</span>) : <span class="number">1</span>;</span><br><span class="line">    srandom((<span class="keyword">int</span>) time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numWrites; ++j) &#123;</span><br><span class="line">        randPipe = random() % numPipes;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Writing to fd: %3d (read fd: %3d)\n"</span>,</span><br><span class="line">                pfds[randPipe][<span class="number">1</span>], pfds[randPipe][<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 写数据进入管段</span></span><br><span class="line">        <span class="keyword">if</span> (write(pfds[randPipe][<span class="number">1</span>], <span class="string">"a"</span>, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"write %d"</span>, pfds[randPipe][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 pollFd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numPipes; ++j) &#123;</span><br><span class="line">        pollFd[j].fd = pfds[j][<span class="number">0</span>];</span><br><span class="line">        pollFd[j].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 poll</span></span><br><span class="line">    ready = poll(pollFd, numPipes, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ready == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"poll"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"poll() returned: %d\n"</span>, ready);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到哪些管段被写然后可读</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numPipes; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pollFd[j].revents &amp; POLLIN)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Readable: %d %3d\n"</span>, j, pollFd[j].fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件描述符何时就绪"><a href="#文件描述符何时就绪" class="headerlink" title="文件描述符何时就绪"></a>文件描述符何时就绪</h4><p><code>select()</code> 和 <code>poll()</code> 只会告诉我们 I/O 操作是否会阻塞，而不是告诉我们到底能否成功传输数据。</p>
<h5 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h5><p>代表普通文件的文件描述符总是被 <code>select()</code> 标记为可读和可写。对于 <code>poll()</code> 来说，则会在 <code>revents</code> 字段返回 POLLIN 和 POLLOUT 标志。原因如下：</p>
<ul>
<li><code>read()</code> 总是会立刻返回数据、文件结尾符或者错误</li>
<li><code>write()</code> 总是会立刻传输数据或者因出现某些错误而失败</li>
</ul>
<h5 id="终端和伪终端"><a href="#终端和伪终端" class="headerlink" title="终端和伪终端"></a>终端和伪终端</h5><p><strong>在终端和伪终端上 <code>select()</code> 和 <code>poll()</code> 所代表的含义</strong></p>
<table>
<thead>
<tr>
<th>条件或事件</th>
<th style="text-align:center"><code>select()</code></th>
<th style="text-align:center"><code>poll()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>有输入</td>
<td style="text-align:center">r</td>
<td style="text-align:center">POLLIN</td>
</tr>
<tr>
<td>可输出</td>
<td style="text-align:center">w</td>
<td style="text-align:center">POLLOUT</td>
</tr>
<tr>
<td>伪终端对端调用 <code>close()</code> 后</td>
<td style="text-align:center">rw</td>
<td style="text-align:center">POLLHUP</td>
</tr>
<tr>
<td>处于信包模式下的伪终端主设备检测到从设备端状态改变</td>
<td style="text-align:center">x</td>
<td style="text-align:center">POLLPRI</td>
</tr>
</tbody>
</table>
<h5 id="管道和-FIFO"><a href="#管道和-FIFO" class="headerlink" title="管道和 FIFO"></a>管道和 FIFO</h5><p><strong><code>select()</code> 和 <code>poll()</code> 在管道或 FIFO 读端上的通知</strong></p>
<table>
<thead>
<tr>
<th>条件或事件</th>
<th style="text-align:center"><code>select()</code></th>
<th style="text-align:center"><code>poll()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>管道无数据，写端没打开</td>
<td style="text-align:center">r</td>
<td style="text-align:center">POLLHUP</td>
</tr>
<tr>
<td>管道有数据，写端打开</td>
<td style="text-align:center">r</td>
<td style="text-align:center">POLLIN</td>
</tr>
<tr>
<td>管道有数据，写端没打开</td>
<td style="text-align:center">r</td>
<td style="text-align:center">POLLIN\</td>
<td>POLLHUP</td>
</tr>
</tbody>
</table>
<p><strong><code>select()</code> 和 <code>poll()</code> 在管道或 FIFO 写端上的通知</strong></p>
<table>
<thead>
<tr>
<th>条件或事件</th>
<th style="text-align:center"><code>select()</code></th>
<th style="text-align:center"><code>poll()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>没有 PIPE_BUF 个字节空间，读端没打开</td>
<td style="text-align:center">w</td>
<td style="text-align:center">POLLERR</td>
</tr>
<tr>
<td>有 PIPE_BUF 个字节空间，读端打开</td>
<td style="text-align:center">w</td>
<td style="text-align:center">POLLOUT</td>
</tr>
<tr>
<td>有 PIPE_BUF 个字节空间，读端没打开</td>
<td style="text-align:center">w</td>
<td style="text-align:center">POLLOUT\</td>
<td>POLLERR</td>
</tr>
</tbody>
</table>
<h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><table>
<thead>
<tr>
<th>条件或事件</th>
<th style="text-align:center"><code>select()</code></th>
<th style="text-align:center"><code>poll()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>有输入</td>
<td style="text-align:center">r</td>
<td style="text-align:center">POLLIN</td>
</tr>
<tr>
<td>可输出</td>
<td style="text-align:center">w</td>
<td style="text-align:center">POLLOUT</td>
</tr>
<tr>
<td>在监听套接字上建立连接</td>
<td style="text-align:center">r</td>
<td style="text-align:center">POLLIN</td>
</tr>
<tr>
<td>接收到带外数据（只限 TCP）</td>
<td style="text-align:center">x</td>
<td style="text-align:center">POLL</td>
</tr>
<tr>
<td>流套接字的对端关闭连接或执行了 <code>shutdown(SHUT_WR)</code></td>
<td style="text-align:center">rw</td>
<td style="text-align:center">POLLIN\</td>
<td>POLLOUT\</td>
<td>POLLRDHUP</td>
</tr>
</tbody>
</table>
<h4 id="比较-select-和-poll"><a href="#比较-select-和-poll" class="headerlink" title="比较 select() 和 poll()"></a>比较 <code>select()</code> 和 <code>poll()</code></h4><h5 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h5><p>在 Linux 内核层面，<code>select()</code> 和 <code>poll()</code> 都使用了相同的内核 <code>poll</code> 例程集合。这些例程有别于系统调用 <code>poll()</code> 本身。每个例程都返回有关单个文件描述符就绪的信息。这个就绪信息以位掩码的形式返回，其值同 <code>poll()</code> 系统调用中返回的 <code>revents</code> 字段中的比特值相关。 <code>poll()</code> 系统调用的实现包括为每个文件描述符调用内核 <code>poll</code> 例程，并将结果信息填到对应的 <code>revents</code> 字段中去。</p>
<h5 id="API-之间的区别"><a href="#API-之间的区别" class="headerlink" title="API 之间的区别"></a>API 之间的区别</h5><ul>
<li><code>select()</code> 有文件描述符上限</li>
<li>由于 <code>select()</code> 的参数 <code>fd_set</code> 同事也是保存调用结果的地方，如果要在循环中重复调用 <code>select()</code> 的话，我们必须每次都要重新初始化 <code>fd_set</code>。而<code>poll()</code>通过独立的两个字段<code>events</code> （针对输入）和 <code>revents</code> （针对输出）来处理，从而避免每次都要重新初始化参数。</li>
<li><code>select()</code> 提供的超时精度比较高</li>
<li>如果其中一个被检查的文件描述符关闭了，通过在对应的 <code>revents</code> 字段中设定 <code>POLLNVAL</code> 标记，<code>poll()</code> 会准确高数我们是哪一个文件描述符关闭了。与之相反，<code>select()</code> 只会返回 -1，并设错误码为 <code>EBADF</code>。通过在描述符上执行 I/O 系统调用并检查错误码，让我们自己来判断哪个文件描述符关闭了。</li>
</ul>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>当满足如下两条中任意一条时，<code>poll()</code> 和 <code>select()</code> 将具有相似的性能表现。</p>
<ul>
<li>待检查的文件描述符范围较小</li>
<li>有大量的文件描述符待检查，但是它们分布得很密集。</li>
</ul>
<p>然而，如果被检查的文件描述符集合很稀疏的话，<code>select()</code> 和 <code>poll()</code> 的性能差异将变得非常明显，在这种情况下，后者更优。</p>
<h4 id="select-和-poll-存在的问题"><a href="#select-和-poll-存在的问题" class="headerlink" title="select() 和 poll() 存在的问题"></a><code>select()</code> 和 <code>poll()</code> 存在的问题</h4><p>当检查大量的文件描述符时，这两个 API 都会遇到一些问题</p>
<ul>
<li>每次调用 <code>select()</code> 或 <code>poll()</code>，内核都必须检查所有被指定的文件描述符，看它们是否处于就绪态。当检查大量处于密集范围，该挫折耗费时间将大大超过接下来的操作。</li>
<li>每次调用 <code>select()</code> 或 <code>poll()</code>，程序都必须传递一个表示所有需要被检查的文件描述符的数据结构到内核，内核检查过描述符后，修改这个数据结构并返回给程序。（此外，对于<code>select()</code> 来说，我们还必须在每次调用前初始化这个数据结构。）对于 <code>poll()</code>来说，随着待检查的文件描述符数量的增加，传递给内核的数据结构大小也会随之增加。当检查大量文件描述符时，从用户控件到内核控件来回拷贝这个数据结构将占用大量的 CPU 时间。对于<code>select()</code> 来说，这个数据结构的大小固定为 <code>FD_SETSIZE</code>，与待检查的文件描述符数量无关。</li>
<li><code>select()</code> 或 <code>poll()</code> 调用完成后，程序必须检查返回的数据结构中的每个元素，以此查明哪个文件描述符处于就绪态了。</li>
</ul>
<h3 id="信号驱动-IO"><a href="#信号驱动-IO" class="headerlink" title="信号驱动 IO"></a>信号驱动 IO</h3><p>在信号驱动 I/O 中，当文件描述符上可执行 I/O 操作时，进程请求内核为自己发送一个信号。之后进程就可以执行任何其他的任务知道 I/O 就绪为止，此时内核会发送信号给进程。要使用信号驱动 I/O，程序需要按照如下步骤来执行。</p>
<ol>
<li><p>为内核发送的通知信号安装一个信号处理例程。默认情况下，这个通知信号为 <code>SIGIO</code>。</p>
</li>
<li><p>设定文件描述符的属主，也就是当文件描述符上可执行 I/O 时会接收到通知信号的进程或进程组。通常我们让调用进程成为属主。设定属主可通过 <code>fcntl()</code> 的 <code>F_SETOWN</code> 操作来完成:</p>
<p><code>fcntl(fd, F_SETOWN, pid);</code></p>
</li>
<li><p>通过设定 <code>O_NONBLOCK</code> 标志使能非阻塞 I/O。</p>
</li>
<li><p>通过打开 <code>O_ASYNC</code> 标志使能信号驱动 I/O。这可以和上一步合并为一个操作，因为它们都需要用到 <code>fcntl()</code> 的 <code>F_SETFL</code> 操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_ASYNC | ONONBLOCK);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用进程现在可以执行其他的任务了。当 I/O 操作就绪时，内核为进程发送一个信号，然后调用在第 1 步中安装好的信号处理例程。</p>
</li>
<li><p>信号驱动 I/O 提供的是边缘触发通知。这表示一旦进程被通知 I/O 就绪，它就应该尽可能多地执行 I/O （例如尽可能多地读取字节）。假设文件描述符是非阻塞式的，这表示需要在循环中执行 I/O 系统调用直到失败为止，此时错误码 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p>
</li>
</ol>
<h4 id="示例程序-2"><a href="#示例程序-2" class="headerlink" title="示例程序"></a>示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tty_functions.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> gotSigio = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sigioHandler(<span class="keyword">int</span> sig)</span><br><span class="line">&#123;</span><br><span class="line">    gotSigio = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">testSigio(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> flags, j, cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">origTermios</span>;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    Boolean done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = sigioHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGIO, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"sigaction"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"fcntl(F_SETOWN)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 &amp; 4</span></span><br><span class="line">    flags = fcntl(STDIN_FILENO, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (fcntl(STDIN_FILENO, F_SETFL, flags | O_ASYNC | O_NONBLOCK) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"fcntl(F_SETFL"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ttySetCbreak(STDIN_FILENO, &amp;origTermios) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"ttySetCbreak"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (done = FALSE, cnt = <span class="number">0</span>; !done; cnt++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10000000</span>; j++)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被触发</span></span><br><span class="line">        <span class="keyword">if</span> (gotSigio) &#123;</span><br><span class="line">            <span class="keyword">while</span> (read(STDIN_FILENO, &amp;ch, <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; !done) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"cnt=%d; read %c\n"</span>, cnt, ch);</span><br><span class="line">                done = ch == <span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gotSigio = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;origTermios) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"tcsetattr"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="何时发送『I-O-就绪』信号"><a href="#何时发送『I-O-就绪』信号" class="headerlink" title="何时发送『I/O 就绪』信号"></a>何时发送『I/O 就绪』信号</h4><h5 id="终端和伪终端-1"><a href="#终端和伪终端-1" class="headerlink" title="终端和伪终端"></a>终端和伪终端</h5><p>当产生新的输入时</p>
<h5 id="管道和-FIFO-1"><a href="#管道和-FIFO-1" class="headerlink" title="管道和 FIFO"></a>管道和 FIFO</h5><ul>
<li>读端：<ul>
<li>数据写入到管道中（即使已经有未读取的输入存在）</li>
<li>管道的写端关闭</li>
</ul>
</li>
<li>写端：<ul>
<li>对管道的读操作增加了管道中的空间大小，因此现在可以写入 PIPE_BUF 个字节而不被阻塞</li>
<li>管道的读端关闭</li>
</ul>
</li>
</ul>
<h5 id="套接字-1"><a href="#套接字-1" class="headerlink" title="套接字"></a>套接字</h5><ul>
<li>Unix 和 Internet 域下的数据报套接字<ul>
<li>一个输入数据报达到套接字（即使已经有未读取的数据报正等待读取）</li>
<li>套接字上发生了异步错误</li>
</ul>
</li>
<li>Unix 和 Internet 域下的流式套接字<ul>
<li>监听套接字上接收到新的连接</li>
<li>TCP <code>connect()</code> 请求完成，也就是 TCP 连接的主动端进入 <code>ESTABLISHED</code> 状态。</li>
<li>套接字上接收到了新的输入（即使已经有未读取的输入存在）</li>
<li>套接字对端使用 <code>showdown()</code> 关闭了写连接（半关闭），或者通过 <code>close()</code> 完全关闭</li>
<li>套接字上输出就绪</li>
<li>套接字上发生了异步错误</li>
</ul>
</li>
</ul>
<h5 id="inotify-文件描述符"><a href="#inotify-文件描述符" class="headerlink" title="inotify 文件描述符"></a>inotify 文件描述符</h5><p>当 inotify 文件描述符称为可读状态时会产生一个信号——也就是由 inotify 文件描述符监视的其中一个文件上有事件发生时。</p>
<h3 id="epoll-编程接口"><a href="#epoll-编程接口" class="headerlink" title="epoll 编程接口"></a>epoll 编程接口</h3><p><code>epoll</code>API  的主要优点如下：</p>
<ul>
<li>当检查大量的文件描述符时，<code>epoll</code> 的性能延展性比 <code>select()</code> 和 <code>poll()</code> 高很多。</li>
<li><code>epoll</code>API 既支持水平触发也支持边缘触发。与之相反，<code>select()</code> 和 <code>poll()</code> 只支持水平触发，而信号驱动 I/O 只支持边缘触发。</li>
<li>可以避免复杂的信号处理流程（比如信号队列溢出时的处理）。</li>
<li>灵活性高，可以指定我们希望检查的事件类型（例如，检查套接字文件描述符的读就绪，写就绪或者两者同时指定）。</li>
</ul>
<p><code>epoll</code>API 的核心数据结构称作 <code>epoll</code> 实例，它和一个打开的文件描述符相关联。这个文件描述符不是用来做 I/O 操作的，相反，它是内核数据结构的句柄，这些内核数据结构实现了两个目的。</p>
<ul>
<li>记录了在进程中声明过的感兴趣的文件描述符列表 —— interest list (兴趣列表)</li>
<li>维护了处于 I/O 就绪态的文件描述符列表 —— ready list (就绪列表)</li>
</ul>
<p>ready list 中的成员是 interest list 的子集。</p>
<p><code>epoll</code>API 由以下 3 个系统调用组成：</p>
<ul>
<li>系统调用 <code>epoll_create()</code> 创建一个 <code>epoll</code> 实例，返回代表该实例的文件描述符。</li>
<li>系统调用 <code>epoll_ctl()</code> 操作同 <code>epoll</code> 实例相关联的兴趣列表。通过 <code>epoll_ctl()</code>，我们可以增加新的描述符到列表中，将已有的文件描述符从该列表中移除，以及修改代表文件描述符上事件类型的位掩码。</li>
<li>系统调用 <code>epoll_wait()</code> 返回与 <code>epoll</code> 实例相关联的就绪列表中的成员。</li>
</ul>
<h4 id="创建-epoll-实例：-epoll-create"><a href="#创建-epoll-实例：-epoll-create" class="headerlink" title="创建 epoll 实例： epoll_create()"></a>创建 <code>epoll</code> 实例： <code>epoll_create()</code></h4><p>系统调用 <code>epoll_create()</code> 创建了一个新的 <code>epoll</code> 实例，其对应的兴趣列表初始化为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return file descriptor on success, or -1 on error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size 指定想要检查的文件描述符个数，该参数并不是上限，而是告诉内核应该如何为内部数据结构划分初始大小</span></span><br></pre></td></tr></table></figure>
<p>作为函数返回值，<code>epoll_create()</code> 返回了代表新创建的 <code>epoll()</code> 实例的文件描述符。这个文件描述符在其他几个 <code>epoll</code> 系统调用中用来表示 <code>epoll</code> 实例。当这个文件描述符不再需要时，应该通过 <code>close()</code> 来关闭。当所有与 <code>epoll</code> 实例相关的文件描述符都背关闭时，实例被销毁，相关的资源都返还给系统。</p>
<h4 id="修改-epoll-的兴趣列表：-epoll-ctl"><a href="#修改-epoll-的兴趣列表：-epoll-ctl" class="headerlink" title="修改 epoll 的兴趣列表： epoll_ctl()"></a>修改 <code>epoll</code> 的兴趣列表： <code>epoll_ctl()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return 0 on success, or -1 on error</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>fd</code> 指定要修改的文件描述符，它甚至可以是另一个 <code>epoll</code> 实例的文件描述符，但是，这里 <code>fd</code> 不能作为普通文件或目录的文件描述符</p>
</li>
<li><p><code>op</code> 指定需要执行的操作：</p>
<ul>
<li><code>EPOLL_CTL_ADD</code>，加入兴趣列表中</li>
<li><code>EPOLL_CTL_MOD</code>，修改 fd 上设定的时间，需要用到由 ev 所指向的结构体中的信息</li>
<li><code>EPOLL_CTL_DEL</code>，移除兴趣列表</li>
</ul>
</li>
<li><p><code>ev</code> 是指向结构体 <code>epoll_even</code>  的指针，结构体定义如下:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>     event;         <span class="comment">/* epoll events (bit mask) */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;          <span class="comment">/* User data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 其中 data 的字段如下</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">  <span class="keyword">void</span>       *ptr;           <span class="comment">/* Pointer to user-defined data */</span></span><br><span class="line">  <span class="keyword">int</span>        fd;             <span class="comment">/* File descriptor */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>   u32;            <span class="comment">/* 32-bit integer */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>   u64;            <span class="comment">/* 64-bit integer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 参数 <code>ev</code> 为文件描述符 <code>fd</code> 所做的设置如下：</p>
<ul>
<li>结构体 <code>epoll_event</code> 中的 <code>events</code> 字段是一个位掩码，它指定了我们为待检查的描述符 <code>fd</code> 上感兴趣的事件集合。</li>
<li><code>data</code> 字段是一个联合体，当描述符 <code>fd</code> 稍后称为就绪态时，联合体的成员可用来指定传回给调用进程的信息。</li>
</ul>
</li>
</ul>
<p><strong>使用 <code>epoll_create()</code> 和 <code>epoll_ctl()</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line"></span><br><span class="line">epfd = epoll_create(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (epfd == <span class="number">-1</span>)</span><br><span class="line">  errExit(<span class="string">"epoll_create"</span>);</span><br><span class="line"></span><br><span class="line">ev.data.fd = fd;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == <span class="number">-1</span>)</span><br><span class="line">  errExit(<span class="string">"epoll_ctl"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="事件等待：epoll-wait"><a href="#事件等待：epoll-wait" class="headerlink" title="事件等待：epoll_wait()"></a>事件等待：<code>epoll_wait()</code></h4><p>系统调用 <code>epoll_wait()</code> 返回 <code>epoll</code> 实例中处于就绪态的文件描述符信息。单个 <code>epoll_wait()</code> 调用能返回多个就绪态文件描述符的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *evlist, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return number of ready file descriptor, 0 on timeout, or -1 on error</span></span><br></pre></td></tr></table></figure>
<p>参数 <code>evlist</code> 所指向的结构体数组重返回的是有关就绪态文件描述符的信息。数组<code>evlist</code> 的空间由调用者负责申请，所包含的袁术个数在参数 <code>maxevents</code> 中指定。</p>
<p>在数组 <code>evlist</code> 中，每个元素返回的都是单个就绪态文件描述符的信息。<code>events</code> 字段返回了在该描述符上一届发生的事件掩码。<code>data</code> 字段返回的是我们在描述符下使用 <code>epoll_ctl</code> 注册感兴趣的事件时在 <code>ev.data</code> 中所指定的值。注意，<code>data</code> 字段是唯一一个可获知同这个事件相关的文件描述符号的途径。因此，当我面调用 <code>epoll_ctl()</code> 将文件描述符添加到兴趣列表中时，应该要么将 <code>ev.data.fd</code> 设为文件描述符号，要么将 <code>ev.data.ptr</code> 设为指定包含文件描述符号的结构体。</p>
<p>参数 <code>timeout</code> 用来确定 <code>epoll_wait()</code> 的阻塞行为，有如下几种:</p>
<ul>
<li>-1: 一直阻塞</li>
<li>0: 执行一次非阻塞式检查</li>
<li>>0: 调用将阻塞至多 timeout 毫秒，直到文件描述符上有事件发送，或者直到捕捉到一个信号为止</li>
</ul>
<h5 id="epoll-事件"><a href="#epoll-事件" class="headerlink" title="epoll 事件"></a><code>epoll</code> 事件</h5><p>当我们调用 <code>epoll_ctl()</code> 时可以在 <code>ev.events</code> 中指定的位掩码以及由 <code>epoll_wait()</code> 返回的 <code>evlist[].events</code> 中的值在下表给出：</p>
<p><strong><code>epoll</code> 中 <code>events</code> 字段的位掩码值</strong></p>
<table>
<thead>
<tr>
<th>位掩码</th>
<th style="text-align:center">作为 <code>epoll_ctl()</code> 的输入？</th>
<th style="text-align:center">作为 <code>epoll_wait()</code> 返回</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>EPOLLIN</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>可读取非高优先级的数据</td>
</tr>
<tr>
<td>EPOLLPRI</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>可读取高优先级的数据</td>
</tr>
<tr>
<td>EPOLLRDHUP</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>套接字对端关闭</td>
</tr>
<tr>
<td>EPOLLOUT</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>普通数据可写</td>
</tr>
<tr>
<td>EPOLLET</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td>采用边缘触发事件通知</td>
</tr>
<tr>
<td>EPOLLONESHOT</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td>在完成事件通知之后禁用检查</td>
</tr>
<tr>
<td>EPOLLERR</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td>有错误发生</td>
</tr>
<tr>
<td>EPOLLHUP</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td>出现挂断</td>
</tr>
</tbody>
</table>
<h5 id="EPOLLONESHOT-标志"><a href="#EPOLLONESHOT-标志" class="headerlink" title="EPOLLONESHOT 标志"></a><code>EPOLLONESHOT</code> 标志</h5><p>默认情况下，一旦通过 <code>epoll_ctl()</code> 的 <code>EPOLL_CTL_ADD</code> 操作将文件描述符添加到 <code>epoll</code> 实例的兴趣列表中后，它会保持激活状态（即，之后对 <code>epoll_wait()</code> 的调用会在描述符处于就绪态时通知我们） 直到我们显示地通知 <code>epoll_ctl()</code> 的 <code>EPOLL_CTL_DEL</code> 操作将其从列表中移除。如果我们希望在某个特定的文件描述符上只得到<strong>一次通知</strong>，那么可以在传给 <code>epoll_ctl()</code> 的 <code>ev.events</code> 中指定 <code>EPOLLONESHOT</code> 标志。如果指定了这个标志，那么在下一个 <code>epoll_wait()</code> 调用通知我们对应的文件描述符处于就绪态之后，这个描述符就会在兴趣列表中被标记为非激活态，之后的 <code>epoll_wait()</code> 调用都不会再通知我们有关这个描述符的状态了。如果需要，我们可以稍后通过 <code>epoll_ctl()</code> 的 <code>EPOLL_CTL_MOD</code> 操作重新激活对这个文件描述符的检查。</p>
<h4 id="示例程序-3"><a href="#示例程序-3" class="headerlink" title="示例程序"></a>示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tlpi_hdr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUF      1000         <span class="comment">/* Maximum bytes fetched by a single read() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS   5            <span class="comment">/* Maximum number of events to be returned from a signle epoll_wait() call */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">testEpoll(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> epfd, ready, fd, s, j, numOpenFds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evlist</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">"%s file ...\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 epoll 实例</span></span><br><span class="line">    epfd = epoll_create(argc - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"epoll_create"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开由命令行参数指定的每个文件，以此作为输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        fd = open(argv[j], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Opened \"%s\" on fd %d\n"</span>, argv[j], fd);</span><br><span class="line"></span><br><span class="line">        ev.events = EPOLLIN;           <span class="comment">/* Only interested in input events */</span></span><br><span class="line">        ev.data.fd = fd;</span><br><span class="line">        <span class="comment">// 将得到的文件描述符添加到 epoll 实例的兴趣列表中</span></span><br><span class="line">        <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numOpenFds = argc - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一个循环</span></span><br><span class="line">    <span class="keyword">while</span> (numOpenFds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Fetch up to MAX_EVENTS items from the ready list */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"About to epoll_wait()\n"</span>);</span><br><span class="line">        <span class="comment">// 循环中调用 epoll_wait() 来检查 epoll 实例的兴趣列表中的文件描述符，</span></span><br><span class="line">        <span class="comment">// 并处理每个调用返回的事件</span></span><br><span class="line">        ready = epoll_wait(epfd, evlist, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ready == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 被信号打断处理</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                errExit(<span class="string">"epoll_wait"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Ready: %d\n"</span>, ready);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Deal with returned list of events */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 epoll_wait() 调用成功，程序就再执行一个内层循环检查 evlist</span></span><br><span class="line">        <span class="comment">// 中每个已就绪的元素。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ready; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" fd=%d; events: %s%s%s\n"</span>, evlist[j].data.fd,</span><br><span class="line">                    <span class="comment">// 对于 evlist 中的每个元素，程序不只是检查 events 字段中的 EPOLLIN 标记</span></span><br><span class="line">                   (evlist[j].events &amp; EPOLLIN) ? <span class="string">"EPOLLIN"</span> : <span class="string">""</span>,</span><br><span class="line">                   <span class="comment">// EPOLLHUP、EPOLLERR 也要检查</span></span><br><span class="line">                   (evlist[j].events &amp; EPOLLHUP) ? <span class="string">"EPOLLHUP"</span> : <span class="string">""</span>,</span><br><span class="line">                   (evlist[j].events &amp; EPOLLERR) ? <span class="string">"EPOLLERR"</span> : <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (evlist[j].events &amp; EPOLLIN) &#123;</span><br><span class="line">                s = read(evlist[j].data.fd, buf, MAX_BUF);</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">                    errExit(<span class="string">"read"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"    read %d bytes: %.*s\n"</span>, s, s, buf);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evlist[j].events &amp; (EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">                <span class="comment">/* If EPOLLIN and EPOLLHUP were both set, then there might</span></span><br><span class="line"><span class="comment">                 * be more than MAX_BUF bytes to read. Therefore, we close</span></span><br><span class="line"><span class="comment">                 * the file descriptor only if EPOLLIN was not set.</span></span><br><span class="line"><span class="comment">                 * We'll read further bytes after the next epoll_wait(). */</span></span><br><span class="line">                <span class="comment">// 当所有打开的文件描述符都关闭后，循环终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"    closing fd %d\n"</span>, evlist[j].data.fd);</span><br><span class="line">                <span class="keyword">if</span> (close(evlist[j].data.fd) == <span class="number">-1</span>)</span><br><span class="line">                    errExit(<span class="string">"close"</span>);</span><br><span class="line">                numOpenFds--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"All file descriptors closed; bye\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深入探究-epoll-的语义"><a href="#深入探究-epoll-的语义" class="headerlink" title="深入探究 epoll 的语义"></a>深入探究 <code>epoll</code> 的语义</h4><p>当我面通过 <code>epoll_create()</code> 创建一个 <code>epoll</code> 实例时，内核在内存中创建了一个新的 <code>i-node</code> 并打开文件描述（文件描述符表示的是一个打开文件的上下文信息（大小、内容、编码等与文件有关的信息），这部分实际是由内核来维护的。），随后在调用进程中为打开的这个文件描述分配一个新的文件描述符。同 <code>epoll</code> 实例的兴趣列表相关联的是打开的文件描述，而不是 <code>epoll</code> 文件描述符。这将产生下列结果：</p>
<ul>
<li>如果我们使用 <code>dup()</code> （或类似的函数）复制一个 <code>epoll</code> 文件描述符，那么被复制的描述符所指代的 <code>epoll</code> 兴趣列表和就绪列表同原始的 <code>epoll</code> 文件描述符相同。若要修改兴趣列表，在 <code>epoll_ctl()</code> 的参数 <code>epfd</code> 上设定文件描述符可以是原始的也可以是复制的。</li>
<li>上条观点同意也适用于 <code>fork()</code> 调用之后的情况。此时子进程通过继承复制了父进程的 <code>epoll</code> 文件描述符，而这个复制的文件描述符所指向的 <code>epoll</code> 数据结果同原始的描述符相同。</li>
</ul>
<p>当我们执行 <code>epoll_ctl()</code> 的 <code>EPOLL_CTL_ADD</code> 操作时，内核在 <code>epoll</code> 兴趣列表中添加了一个元素，这个元素同时记录了需要检查的文件描述符数量以及对应的打开文件描述的引用。 <code>epoll_wait()</code> 调用的目的就是让内核负责监视打开的文件描述符。这表示我们必须对之前的观点做改进：如果一个文件描述符是 <code>epoll</code> 兴趣列表中的成员，当关闭它后会自动从列表中删除。改进版应该是这样的：一旦所有指向打开文件描述的文件描述符都被关闭后，这个打开的文件描述符将从<code>epoll</code> 的兴趣列表中移除。这表示如果我们通过 <code>dup()</code> （或类似的函数）或者 <code>fork()</code> 为打开的文件创建了描述符副本，那么这个打开的文件只会在原始的描述符以及所有其他的副本都被关闭时才会移除。</p>
<h4 id="epoll-同-I-O-多路复用的性能对比"><a href="#epoll-同-I-O-多路复用的性能对比" class="headerlink" title="epoll 同 I/O 多路复用的性能对比"></a><code>epoll</code> 同 I/O 多路复用的性能对比</h4><p><strong><code>poll()</code>、<code>select()</code> 以及 <code>epoll</code> 进行 100000 次监视操作所花费的时间</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">被监视的文件描述符数量（N）</th>
<th style="text-align:center"><code>poll()</code> 所占用的 CPU 时间（秒）</th>
<th style="text-align:center"><code>select()</code> 所占用的 CPU 时间（秒）</th>
<th style="text-align:center"><code>epoll</code>  所占用的 CPU 时间（秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0.61</td>
<td style="text-align:center">0.73</td>
<td style="text-align:center">0.41</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">2.9</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">0.42</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">35</td>
<td style="text-align:center">35</td>
<td style="text-align:center">0.53</td>
</tr>
<tr>
<td style="text-align:center">10000</td>
<td style="text-align:center">990</td>
<td style="text-align:center">930</td>
<td style="text-align:center">0.66</td>
</tr>
</tbody>
</table>
<p>为什么：</p>
<ul>
<li>每次调用 <code>select()</code> 和 <code>poll()</code> 时，内核必须检查所有在调用中指定的文件描述符。与之相反，当通过 <code>epoll_ctl()</code> 指定了需要监视的文件描述符时，内核会在与打开的文件描述上下文相关联的列表中记录该描述符。之后每当执行 I/O 操作使得文件描述符成为就绪态时，内核就在 <code>epoll</code> 描述符的就绪列表中添加一个元素。（单个打开的文件描述上下文中一次 I/O 事件可能导致与之相关的多个文件描述符成为就绪态。）之后的 <code>epoll_wait()</code> 调用从就绪列表中简单地取出这些元素。</li>
<li>每次调用 <code>select()</code> 或 <code>poll()</code> 时，我传递一个标记了所有待监视的文件描述符的数据结构给内核，调用返回时，内核将所有标记为就绪态的文件描述符的数据结构再传回给我们。与之相反，在 <code>epoll</code> 中我们使用 <code>epoll_ctl()</code> 在内核控件中建立一个数据结构，该数据结构会将待监视的文件描述符都记录下来。一旦这个数据结构建立完成，稍后每次调用 <code>epoll_wait()</code> 时就不需要再传递任何与文件描述符有关的信息给内核了，而调用返回的信息中只包含那些已经处于就绪态的描述符。</li>
</ul>
<h4 id="边缘触发通知"><a href="#边缘触发通知" class="headerlink" title="边缘触发通知"></a>边缘触发通知</h4><p><code>epoll</code> API 还能以边缘触发方式进行通知——也就是说，会告诉我们自从上一次调用 <code>epoll_wait()</code> 以来文件描述符上是否已经有 I/O 活动了（或者由于描述符被打开了，如果之前没有调用的话）。使用 <code>epoll</code> 的边缘触发通知在语义上类似于信号驱动 I/O ，只是如果有多个 I/O 事件发生的话，<code>epoll</code> 会将它们合并成一次单独的通知，通过 <code>epoll_wait()</code> 返回，而再信号驱动 I/O 中则可能会产生多个信号。</p>
<p>采用 <code>epoll</code> 的边缘触发通知机制的程序基本框架如下：</p>
<ol>
<li>让所有监视的文件描述符都称为非阻塞的。</li>
<li>通过 <code>epoll_ctl()</code> 构建 <code>epoll</code> 的兴趣列表。</li>
<li>通过如下的循环处理 I/O 事件：<ol>
<li>通过 <code>epoll_wait()</code> 取得处于就绪态的描述符列表</li>
<li>针对每一个处于就绪态的文件描述符，不断进行 I/O 处理知道相关的系统调用（例如 <code>read(), write(), recv(), send()</code> 或 <code>accept()</code>）返回 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code> 错误。</li>
</ol>
</li>
</ol>
<h4 id="当采用边缘触发通知时避免出现文件描述符饥饿现象"><a href="#当采用边缘触发通知时避免出现文件描述符饥饿现象" class="headerlink" title="当采用边缘触发通知时避免出现文件描述符饥饿现象"></a>当采用边缘触发通知时避免出现文件描述符饥饿现象</h4><p>假设其中一个就绪态文件描述符又大量输入，如果使用非阻塞式读操作将所有输入都读取，那么此时就会有使其他的文件描述符处于饥饿状态的风险存在（即，在我们再次检查这些文件描述符是否处于就绪态并执行 I/O 操作前会有很长的一段处理时间）。该问题的一个解决方案是让应用程序维护一个列表，列表中存放着已经被通知为就绪态的文件描述符。通过一个循环按照如下方式不断处理。</p>
<ol>
<li>调用 <code>epoll_wait()</code> 监视文件描述符，并将处于就绪态的描述符添加到应用程序维护的列表中。如果这个文件描述符已经注册到应用程序维护的列表中了，那么这次监视操作的超时时间应该设为较小的值或者是0。这样如果没有新的文件描述符成为就绪态，应用程序就可以迅速进行到下一步，去处理那些已经处于就绪态的文件描述符了。</li>
<li>在应用程序维护的列表中，只在那些已经注册为就绪态的文件描述符上进行一定限度的 I/O 操作（可能是以轮转调度（round-robin）方式循环处理，而不是每次 <code>epoll_wait()</code> 调用后从列表头开始处理 ）。当相关的非阻塞 I/O 系统调用出现 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code> 错误时，文件描述符就可以在应用程序维护的列表中移除了。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Linux/Unix 系统编程手册》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/Python整型对象创建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/Python整型对象创建/" itemprop="url">Python整型对象创建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:50:44+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>Python3 中无论整数还是长整数统统使用 PyLongObject 类型来代替</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Long integer representation.</span></span><br><span class="line"><span class="comment">   The absolute value of a number is equal to</span></span><br><span class="line"><span class="comment">   	SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)</span></span><br><span class="line"><span class="comment">   Negative numbers are represented with ob_size &lt; 0;</span></span><br><span class="line"><span class="comment">   zero is represented by ob_size == 0.</span></span><br><span class="line"><span class="comment">   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant</span></span><br><span class="line"><span class="comment">   digit) is never zero.  Also, in all cases, for all valid i,</span></span><br><span class="line"><span class="comment">   	0 &lt;= ob_digit[i] &lt;= MASK.</span></span><br><span class="line"><span class="comment">   The allocation function takes care of allocating extra memory</span></span><br><span class="line"><span class="comment">   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   CAUTION:  Generic code manipulating subtypes of PyVarObject has to</span></span><br><span class="line"><span class="comment">   aware that ints abuse  ob_size's sign bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">	PyObject_VAR_HEAD</span><br><span class="line">	digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_VAR_HEAD      PyVarObject ob_base;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Nothing is actually declared to be a PyObject, but every pointer to</span></span><br><span class="line"><span class="comment"> * a Python object can be cast to a PyObject*.  This is inheritance built</span></span><br><span class="line"><span class="comment"> * by hand.  Similarly every pointer to a variable-size Python object can,</span></span><br><span class="line"><span class="comment"> * in addition, be cast to PyVarObject*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span>           \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_EXTRA_INIT 0, 0,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_EXTRA_INIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>由于<code>Py_TRACE_REFS</code>在release状态下是不会定义的，所以整个数据结构就会特别简单:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>小数优化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</span></span><br><span class="line"><span class="comment">/* Small integers are preallocated in this array so that they</span></span><br><span class="line"><span class="comment">   can be shared.</span></span><br><span class="line"><span class="comment">   The integers that are preallocated are those in the range</span></span><br><span class="line"><span class="comment">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">Py_ssize_t quick_int_allocs, quick_neg_int_allocs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">get_small_int(sdigit ival)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS);</span><br><span class="line">    v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="keyword">if</span> (ival &gt;= <span class="number">0</span>)</span><br><span class="line">        quick_int_allocs++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        quick_neg_int_allocs++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_SMALL_INT(ival) \</span></span><br><span class="line">    <span class="function"><span class="keyword">do</span> <span class="title">if</span> <span class="params">(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS)</span> </span>&#123; \</span><br><span class="line">        <span class="keyword">return</span> get_small_int((sdigit)ival); \</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>创建函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PyLongObject *</span><br><span class="line">_PyLong_New(Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *result;</span><br><span class="line">    <span class="comment">/* Number of bytes needed is: offsetof(PyLongObject, ob_digit) +</span></span><br><span class="line"><span class="comment">       sizeof(digit)*size.  Previous incarnations of this code used</span></span><br><span class="line"><span class="comment">       sizeof(PyVarObject) instead of the offsetof, but this risks being</span></span><br><span class="line"><span class="comment">       incorrect in the presence of padding between the PyVarObject header</span></span><br><span class="line"><span class="comment">       and the digits. */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">"too many digits in integer"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// offsetof(type, member-designator) 会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的。</span></span><br><span class="line">    result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) +</span><br><span class="line">                             size*<span class="keyword">sizeof</span>(digit));</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyLongObject*)PyObject_INIT_VAR(result, &amp;PyLong_Type, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>PyObject_MALLOC</code>是与 <code>WITH_PYMALLOC</code>定义相关</p>
<blockquote>
<p> Pymalloc, a specialized object allocator written by Vladimir Marangozov, was a feature added to Python 2.1. Pymalloc is intended to be faster than the system malloc() and to have less memory overhead for allocation patterns typical of Python programs. The allocator uses C’s malloc() function to get large pools of memory and then fulfills smaller memory requests from these pools.</p>
<p> In 2.1 and 2.2, pymalloc was an experimental feature and wasn’t enabled by default; you had to explicitly enable it when compiling Python by providing the <strong>–with-pymalloc</strong> option to the <strong>configure</strong> script. In 2.3, pymalloc has had further enhancements and is now enabled by default; you’ll have to supply<strong>–without-pymalloc</strong> to disable it.</p>
</blockquote>
<p>可以看出这东西是默认开启的，所以从代码可知调用的是<code>_PyObject_Malloc</code>方法，再追踪源码发现其最终调用的是如下方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">PyObject_Malloc(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (<span class="keyword">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyObject.<span class="built_in">malloc</span>(_PyObject.ctx, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_PyObject_Malloc(<span class="keyword">void</span> *ctx, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_Alloc(<span class="number">0</span>, ctx, <span class="number">1</span>, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc.  Note that nbytes==0 tries to return a non-NULL pointer, distinct</span></span><br><span class="line"><span class="comment"> * from all other currently live pointers.  This may not be possible.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The basic blocks are ordered by decreasing execution frequency,</span></span><br><span class="line"><span class="comment"> * which minimizes the number of jumps in the most common cases,</span></span><br><span class="line"><span class="comment"> * improves branching prediction and instruction scheduling (small</span></span><br><span class="line"><span class="comment"> * block allocations typically result in a couple of instructions).</span></span><br><span class="line"><span class="comment"> * Unless the optimizer reorders everything, being too smart...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_PyObject_Alloc(<span class="keyword">int</span> use_calloc, <span class="keyword">void</span> *ctx, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> elsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    解释一下 ctx, 这是 PyMemAllocatorEx 的 ctx，</span></span><br><span class="line"><span class="comment">   static PyMemAllocatorEx _PyObject = &#123;</span></span><br><span class="line"><span class="comment">#ifdef Py_DEBUG</span></span><br><span class="line"><span class="comment">    &amp;_PyMem_Debug.obj, PYDBG_FUNCS</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">    NULL, PYOBJ_FUNCS</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">     来定义，可以看出，这个是为了 Debug 来操作的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> nbytes;</span><br><span class="line">    block *bp;</span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录分配了一块 block</span></span><br><span class="line">    _Py_AllocatedBlocks++;</span><br><span class="line"></span><br><span class="line">    assert(nelem &lt;= PY_SSIZE_T_MAX / elsize);</span><br><span class="line">    <span class="comment">// 创建对象个数乘以创建每个对象所需要的字节数</span></span><br><span class="line">    nbytes = nelem * elsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否开启 valgrind 来调试程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_VALGRIND</span></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(running_on_valgrind == <span class="number">-1</span>))</span><br><span class="line">        running_on_valgrind = RUNNING_ON_VALGRIND;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(running_on_valgrind))</span><br><span class="line">        <span class="keyword">goto</span> redirect;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nelem == <span class="number">0</span> || elsize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> redirect;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小块内存与大块内存分配分界处</span></span><br><span class="line">    <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">        <span class="comment">// 这里有些不能理解，看注释是</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Locking</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * To reduce lock contention, it would probably be better to refine the</span></span><br><span class="line"><span class="comment">         * crude function locking with per size class locking. I'm not positive</span></span><br><span class="line"><span class="comment">         * however, whether it's worth switching to such locking policy because</span></span><br><span class="line"><span class="comment">         * of the performance penalty it might introduce.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The following macros describe the simplest (should also be the fastest)</span></span><br><span class="line"><span class="comment">         * lock object on a particular platform and the init/fini/lock/unlock</span></span><br><span class="line"><span class="comment">         * operations on it. The locks defined here are not expected to be recursive</span></span><br><span class="line"><span class="comment">         * because it is assumed that they will always be called in the order:</span></span><br><span class="line"><span class="comment">         * INIT, [LOCK, UNLOCK]*, FINI.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Python's threads are serialized, so object malloc locking is disabled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 但是不能理解其加锁方式</span></span><br><span class="line">        LOCK();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Most frequent paths first</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 得到 size_class_index</span></span><br><span class="line">        size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">        <span class="comment">// 从 userdpool 中找到匹配的pool然后准备存到里面去</span></span><br><span class="line">        pool = usedpools[size + size];</span><br><span class="line">        <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">            <span class="comment">// 这个是最终都要进入的地方</span></span><br><span class="line">            <span class="comment">// 如果 usedpool  中有可用的 pool</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * There is a used pool for this size class.</span></span><br><span class="line"><span class="comment">             * Pick up the head block of its free list.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ++pool-&gt;ref.count;</span><br><span class="line">            bp = pool-&gt;freeblock;</span><br><span class="line">            assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                    <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Reached the end of the free list, try to extend it.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">                <span class="comment">/* There is room for another block. */</span></span><br><span class="line">                pool-&gt;freeblock = (block*)pool +</span><br><span class="line">                                  pool-&gt;nextoffset;</span><br><span class="line">                pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">                *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                    <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Pool is full, unlink from used pools. */</span></span><br><span class="line">            next = pool-&gt;nextpool;</span><br><span class="line">            pool = pool-&gt;prevpool;</span><br><span class="line">            next-&gt;prevpool = pool;</span><br><span class="line">            pool-&gt;nextpool = next;</span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">            <span class="comment">// bp 返回的实际是一个地址，这个地址之后有将近 4KB 的内存实际上都是可用的，</span></span><br><span class="line">            <span class="comment">// 但是可用肯定申请内存的函数只会使用[bp, bp+size] 这个区间的内存，</span></span><br><span class="line">            <span class="comment">// 这是由 size class index 可用保证的。</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//usedpools中无可用pool，尝试获取empty状态pool</span></span><br><span class="line">        <span class="comment">/* There isn't a pool of the right size class immediately</span></span><br><span class="line"><span class="comment">         * available:  use a free pool.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果usable_arenas链表为空，则创建链表</span></span><br><span class="line">            <span class="comment">/* No arena has a free pool:  allocate a new arena. */</span></span><br><span class="line">        <span class="comment">// WITH_MEMORY_LIMITS 编译时候打开会激活 SMALL_MEMORY_LIMIT 符号，该符号限制了 arena 的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_MEMORY_LIMITS</span></span><br><span class="line">            <span class="keyword">if</span> (narenas_currently_allocated &gt;= MAX_ARENAS) &#123;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">goto</span> redirect;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">// 申请新的arena_object，并放入usable_arenas链表</span></span><br><span class="line">            usable_arenas = new_arena();</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">goto</span> redirect;</span><br><span class="line">            &#125;</span><br><span class="line">            usable_arenas-&gt;nextarena =</span><br><span class="line">                usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Try to get a cached free pool. */</span></span><br><span class="line">        <span class="comment">// 从usable_arenas链表中第一个arena的freepools中抽取一个可用的pool</span></span><br><span class="line">        pool = usable_arenas-&gt;freepools;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Unlink from cached pools. */</span></span><br><span class="line">            usable_arenas-&gt;freepools = pool-&gt;nextpool;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* This arena already had the smallest nfreepools</span></span><br><span class="line"><span class="comment">             * value, so decreasing nfreepools doesn't change</span></span><br><span class="line"><span class="comment">             * that, and we don't need to rearrange the</span></span><br><span class="line"><span class="comment">             * usable_arenas list.  However, if the arena has</span></span><br><span class="line"><span class="comment">             * become wholly allocated, we need to remove its</span></span><br><span class="line"><span class="comment">             * arena_object from usable_arenas.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//调整usable_arenas链表中第一个arena中的可用pool数量</span></span><br><span class="line">            <span class="comment">//如果调整后数量为0，则将该arena从usable_arenas链表中摘除</span></span><br><span class="line">            --usable_arenas-&gt;nfreepools;</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* Wholly allocated:  remove. */</span></span><br><span class="line">                assert(usable_arenas-&gt;freepools == <span class="literal">NULL</span>);</span><br><span class="line">                assert(usable_arenas-&gt;nextarena == <span class="literal">NULL</span> ||</span><br><span class="line">                       usable_arenas-&gt;nextarena-&gt;prevarena ==</span><br><span class="line">                       usable_arenas);</span><br><span class="line"></span><br><span class="line">                usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">                <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">                    assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* nfreepools &gt; 0:  it must be that freepools</span></span><br><span class="line"><span class="comment">                 * isn't NULL, or that we haven't yet carved</span></span><br><span class="line"><span class="comment">                 * off all the arena's pools for the first</span></span><br><span class="line"><span class="comment">                 * time.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                assert(usable_arenas-&gt;freepools != <span class="literal">NULL</span> ||</span><br><span class="line">                       usable_arenas-&gt;pool_address &lt;=</span><br><span class="line">                       (block*)usable_arenas-&gt;address +</span><br><span class="line">                           ARENA_SIZE - POOL_SIZE);</span><br><span class="line">            &#125;</span><br><span class="line">        init_pool:</span><br><span class="line">            <span class="comment">/* Frontlink to used pools. */</span></span><br><span class="line">            <span class="comment">// 将 pool 放入 usedpool 中</span></span><br><span class="line">            next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">            pool-&gt;nextpool = next;</span><br><span class="line">            pool-&gt;prevpool = next;</span><br><span class="line">            next-&gt;nextpool = pool;</span><br><span class="line">            next-&gt;prevpool = pool;</span><br><span class="line">            pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;szidx == size) &#123;</span><br><span class="line">                <span class="comment">/* Luckily, this pool last contained blocks</span></span><br><span class="line"><span class="comment">                 * of the same size class, so its header</span></span><br><span class="line"><span class="comment">                 * and free list are already initialized.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                bp = pool-&gt;freeblock;</span><br><span class="line">                assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">                pool-&gt;freeblock = *(block **)bp;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                    <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Initialize the pool header, set up the free list to</span></span><br><span class="line"><span class="comment">             * contain just the second block, and return the first</span></span><br><span class="line"><span class="comment">             * block.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 初始化pool header，将freeblock指向第二个block，返回第一个block</span></span><br><span class="line">            pool-&gt;szidx = size;</span><br><span class="line">            size = INDEX2SIZE(size);</span><br><span class="line">            bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">            pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">            pool-&gt;freeblock = bp + size;</span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">if</span> (use_calloc)</span><br><span class="line">                <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Carve off a new pool. */</span></span><br><span class="line">        assert(usable_arenas-&gt;nfreepools &gt; <span class="number">0</span>);</span><br><span class="line">        assert(usable_arenas-&gt;freepools == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 从arena中取出一个新的pool</span></span><br><span class="line">        pool = (poolp)usable_arenas-&gt;pool_address;</span><br><span class="line">        assert((block*)pool &lt;= (block*)usable_arenas-&gt;address +</span><br><span class="line">                               ARENA_SIZE - POOL_SIZE);</span><br><span class="line">        <span class="comment">// 设置 pool 中的 arenaindex，这个 index 实际上就是 pool 所在的 arena</span></span><br><span class="line">        <span class="comment">// 位于 arenas 所指的数组的序号。用于判断一个 block 是否在某个 pool 中。</span></span><br><span class="line">        pool-&gt;arenaindex = (uint)(usable_arenas - arenas);</span><br><span class="line">        assert(&amp;arenas[pool-&gt;arenaindex] == usable_arenas);</span><br><span class="line">        <span class="comment">// 随后 Python 将新得到的 pool 的 szidx 设置为 0xffff，表示从没管理过 block 集合。</span></span><br><span class="line">        pool-&gt;szidx = DUMMY_SIZE_IDX;</span><br><span class="line">        <span class="comment">// 调整刚获得的 arena 中的 pools 集合，甚至可能调整 usable_arenas</span></span><br><span class="line">        usable_arenas-&gt;pool_address += POOL_SIZE;</span><br><span class="line">        --usable_arenas-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">            assert(usable_arenas-&gt;nextarena == <span class="literal">NULL</span> ||</span><br><span class="line">                   usable_arenas-&gt;nextarena-&gt;prevarena ==</span><br><span class="line">                   usable_arenas);</span><br><span class="line">            <span class="comment">/* Unlink the arena:  it is completely allocated. */</span></span><br><span class="line">            usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">                assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> init_pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The small block allocator ends here. */</span></span><br><span class="line"></span><br><span class="line">redirect:</span><br><span class="line">    <span class="comment">/* Redirect the original request to the underlying (libc) allocator.</span></span><br><span class="line"><span class="comment">     * We jump here on bigger requests, on error in the code above (as a</span></span><br><span class="line"><span class="comment">     * last chance to serve the request) or when the max memory limit</span></span><br><span class="line"><span class="comment">     * has been reached.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> *result;</span><br><span class="line">        <span class="keyword">if</span> (use_calloc)</span><br><span class="line">            result = PyMem_RawCalloc(nelem, elsize);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = PyMem_RawMalloc(nbytes);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            _Py_AllocatedBlocks--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate a new arena.  If we run out of memory, return NULL.  Else</span></span><br><span class="line"><span class="comment"> * allocate a new arena, and return the address of an arena_object</span></span><br><span class="line"><span class="comment"> * describing the new arena.  It's expected that the caller will set</span></span><br><span class="line"><span class="comment"> * `usable_arenas` to the return value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>*</span></span><br><span class="line"><span class="class"><span class="title">new_arena</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span></span><br><span class="line">    uint excess;        <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">    <span class="keyword">void</span> *address;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> debug_stats = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug_stats == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *opt = Py_GETENV(<span class="string">"PYTHONMALLOCSTATS"</span>);</span><br><span class="line">        debug_stats = (opt != <span class="literal">NULL</span> &amp;&amp; *opt != <span class="string">'\0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (debug_stats)</span><br><span class="line">        _PyObject_DebugMallocStats(<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要扩充“未使用的”arena_object列表</span></span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        uint i;</span><br><span class="line">        uint numarenas;</span><br><span class="line">        <span class="keyword">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Double the number of arena objects on each allocation.</span></span><br><span class="line"><span class="comment">         * Note that it's possible for `numarenas` to overflow.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 确定本次需要申请的arena_object的个数，并申请内存</span></span><br><span class="line">        numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line">        <span class="keyword">if</span> (numarenas &lt;= maxarenas)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">/* overflow */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_SIZE_T &lt;= SIZEOF_INT</span></span><br><span class="line">        <span class="keyword">if</span> (numarenas &gt; SIZE_MAX / <span class="keyword">sizeof</span>(*arenas))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">/* overflow */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">        <span class="comment">// realloc() 对 ptr 指向的内存重新分配 size 大小的空间，size 可比原来的大或者小</span></span><br><span class="line">        arenaobj = (struct arena_object *)PyMem_RawRealloc(arenas, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        arenas = arenaobj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We might need to fix pointers that were copied.  However,</span></span><br><span class="line"><span class="comment">         * new_arena only gets called when all the pages in the</span></span><br><span class="line"><span class="comment">         * previous arenas are full.  Thus, there are *no* pointers</span></span><br><span class="line"><span class="comment">         * into the old array. Thus, we don't have to worry about</span></span><br><span class="line"><span class="comment">         * invalid pointers.  Just to be sure, some asserts:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(usable_arenas == <span class="literal">NULL</span>);</span><br><span class="line">        assert(unused_arena_objects == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Put the new arenas on the unused_arena_objects list. */</span></span><br><span class="line">        <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">            arenas[i].address = <span class="number">0</span>;              <span class="comment">/* mark as unassociated */</span></span><br><span class="line">            arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ?</span><br><span class="line">                                   &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update globals. */</span></span><br><span class="line">        unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">        maxarenas = numarenas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Take the next available arena object off the head of the list. */</span></span><br><span class="line">    <span class="comment">// 从unused_arena_objects链表中取出一个“未使用的”arena_object</span></span><br><span class="line">    assert(unused_arena_objects != <span class="literal">NULL</span>);</span><br><span class="line">    arenaobj = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">    assert(arenaobj-&gt;address == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 申请arena_object管理的内存</span></span><br><span class="line">    <span class="comment">// 这里的 alloc 对应 linux 下就是 malloc</span></span><br><span class="line">    address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* The allocation failed: return NULL after putting the</span></span><br><span class="line"><span class="comment">         * arenaobj back.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        arenaobj-&gt;nextarena = unused_arena_objects;</span><br><span class="line">        unused_arena_objects = arenaobj;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;address = (<span class="keyword">uintptr_t</span>)address;</span><br><span class="line"></span><br><span class="line">    ++narenas_currently_allocated;</span><br><span class="line">    ++ntimes_arena_allocated;</span><br><span class="line">    <span class="keyword">if</span> (narenas_currently_allocated &gt; narenas_highwater)</span><br><span class="line">        narenas_highwater = narenas_currently_allocated;</span><br><span class="line">    arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* pool_address &lt;- first pool-aligned address in the arena</span></span><br><span class="line"><span class="comment">       nfreepools &lt;- number of whole pools that fit after alignment */</span></span><br><span class="line">    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">    arenaobj-&gt;nfreepools = ARENA_SIZE / POOL_SIZE;</span><br><span class="line">    assert(POOL_SIZE * arenaobj-&gt;nfreepools == ARENA_SIZE);</span><br><span class="line">    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line">    <span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">        --arenaobj-&gt;nfreepools;</span><br><span class="line">        arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体可以参考以上注释，以上。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.python.org/2.3/whatsnew/section-pymalloc.html" target="_blank" rel="noopener">https://docs.python.org/2.3/whatsnew/section-pymalloc.html</a></p>
<p>《Python 源码解析》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/Python内存管理机制——内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/Python内存管理机制——内存模型/" itemprop="url">Python内存管理机制——内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:50:07+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Python 中所有的内存管理机制都有两套实现，这两套实现由编译符号<code>PYMALLOC_DEBUG</code> 控制，当该符号被定义时，使用的是 debug 模式下的内存管理机制，这套机制在正常的内存管理动作之外，还会记录许多关于内存的信息，以方便 Python 在开发时进行调试；而当该符号未被定义时，Python 的内存管理机制只进行正常的内存管理动作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /include/Python.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(Py_DEBUG) &amp;&amp; defined(WITH_PYMALLOC) &amp;&amp; !defined(PYMALLOC_DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PYMALLOC_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h2><p>在 Python 中，内存管理机制被抽象成下图这样的层次似结果。</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%883.48.00.png?raw=true" alt="Python 内存管理机制的层次结构"></p>
<h3 id="Layer-0："><a href="#Layer-0：" class="headerlink" title="Layer 0："></a>Layer 0：</h3><p>操作系统提供的内存管理接口，比如 C 运行时所提供的 malloc 和 free 接口。这层由操作系统实现并管理，Python 不能干涉这一层的行为。</p>
<h3 id="Layer-1："><a href="#Layer-1：" class="headerlink" title="Layer 1："></a>Layer 1：</h3><p>Python 基于第 0 层操作系统的内存管理接口包装而成的，这一层并没有在第 0 层加入太多的冻灾，其目的仅仅是为 Python 提供一层同意的 raw memory 的管理接口。防止操作系统的差异。第一次实现就是一组以<code>PyMem_</code>为前缀的函数族。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include/pymem.h</span></span><br><span class="line"></span><br><span class="line">PyAPI_FUNC(<span class="keyword">void</span> *) PyMem_Malloc(<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(Py_LIMITED_API) || Py_LIMITED_API+0 &gt;= 0x03050000</span></span><br><span class="line">PyAPI_FUNC(<span class="keyword">void</span> *) PyMem_Calloc(<span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> elsize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">PyAPI_FUNC(<span class="keyword">void</span> *) PyMem_Realloc(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> new_size);</span><br><span class="line">PyAPI_FUNC(<span class="keyword">void</span>) PyMem_Free(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"><span class="comment">// 这里使用了一个数据结构 PyMemAllocatorEx 里面定义了上下文及四种方法，上面有用 #ifdef...#endif 来初始化该数据结构方法</span></span><br><span class="line"><span class="comment">// 原始 C 语言方法也在该文件中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">PyMem_Malloc(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (<span class="keyword">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">malloc</span>(_PyMem.ctx, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">PyMem_Calloc(<span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> elsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (elsize != <span class="number">0</span> &amp;&amp; nelem &gt; (<span class="keyword">size_t</span>)PY_SSIZE_T_MAX / elsize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">calloc</span>(_PyMem.ctx, nelem, elsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">PyMem_Realloc(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> new_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (new_size &gt; (<span class="keyword">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyMem.<span class="built_in">realloc</span>(_PyMem.ctx, ptr, new_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PyMem_Free(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    _PyMem.<span class="built_in">free</span>(_PyMem.ctx, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一层中，Python 还提供了面向 Python 中类型的内存分配器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include/pymem.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Type-oriented memory interface</span></span><br><span class="line"><span class="comment"> * ==============================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocate memory for n objects of the given type.  Returns a new pointer</span></span><br><span class="line"><span class="comment"> * or NULL if the request was too large or memory allocation failed.  Use</span></span><br><span class="line"><span class="comment"> * these macros rather than doing the multiplication yourself so that proper</span></span><br><span class="line"><span class="comment"> * overflow checking is always done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_New(type, n) \</span></span><br><span class="line">  ( ((<span class="keyword">size_t</span>)(n) &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(type)) ? <span class="literal">NULL</span> :	\</span><br><span class="line">	( (type *) PyMem_Malloc((n) * <span class="keyword">sizeof</span>(type)) ) )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_NEW(type, n) \</span></span><br><span class="line">  ( ((<span class="keyword">size_t</span>)(n) &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(type)) ? <span class="literal">NULL</span> :	\</span><br><span class="line">	( (type *) PyMem_MALLOC((n) * <span class="keyword">sizeof</span>(type)) ) )</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The value of (p) is always clobbered by this macro regardless of success.</span></span><br><span class="line"><span class="comment"> * The caller MUST check if (p) is NULL afterwards and deal with the memory</span></span><br><span class="line"><span class="comment"> * error if so.  This means the original value of (p) MUST be saved for the</span></span><br><span class="line"><span class="comment"> * caller's memory error handler to not lose track of it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_Resize(p, type, n) \</span></span><br><span class="line">  ( (p) = ((<span class="keyword">size_t</span>)(n) &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(type)) ? <span class="literal">NULL</span> :	\</span><br><span class="line">	(type *) PyMem_Realloc((p), (n) * <span class="keyword">sizeof</span>(type)) )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_RESIZE(p, type, n) \</span></span><br><span class="line">  ( (p) = ((<span class="keyword">size_t</span>)(n) &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(type)) ? <span class="literal">NULL</span> :	\</span><br><span class="line">	(type *) PyMem_REALLOC((p), (n) * <span class="keyword">sizeof</span>(type)) )</span><br></pre></td></tr></table></figure>
<p>在 <code>PyMem_New</code> 中，只要提供类型和数量，Python 会自动侦测其所需的内存空间大小。</p>
<h3 id="Layer-2："><a href="#Layer-2：" class="headerlink" title="Layer 2："></a>Layer 2：</h3><p>以 PyObje_为前缀的函数族，主要提供了创建 Python 对象的接口。这一套函数族又被唤作 Pymalloc 机制。</p>
<p>在第二层内存管理机制之上，对于 Python 中的一些常用对象，比如整数对象、字符串对象等，Python 又构建了更高抽象层次的内存管理策略。</p>
<p>真正在 Python 中发挥巨大作用、同时也是 GC 的藏身之处的内存管理机制所在层次。</p>
<h3 id="Layer-3"><a href="#Layer-3" class="headerlink" title="Layer 3:"></a>Layer 3:</h3><p>第三层的内存管理策略，主要就是对象缓冲池机制。（参加书中第一部分，或者下篇博客）。</p>
<h2 id="小块空间的内存池"><a href="#小块空间的内存池" class="headerlink" title="小块空间的内存池"></a>小块空间的内存池</h2><p>在 Python 中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着 Python 在运行期间会大量地执行 malloc 和 free 操作，导致操作系统频繁地在用户态和核心态之间进行切换，这将严重影响 Python 的执行效率。为了提高 Python 的执行效率，Python 引入了一个内存池机制，用于管理对小块内存的申请和释放。<strong>这也就是之前提到的 Pymalloc 机制</strong>。</p>
<p>在 Python 中，整个小块内存池可以视为一个层次结构，在这个层次结构中，一共分为4层，从下至上分别是：block、pool、arena 和内存池。需要说明的是，block、pool 和 arena 都是 Python 代码中可以找到的实体，而最顶层的『内存池』只是一个概念上的东西，表示 Python 对于整个小块内存分配和释放行为的内存管理机制。</p>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>在最底层，block 是一个确定大小的内存块。在 Python 中，有多种 block，不同种类的 block 都有不同的内存大小，这个内存大小的值被称为 size class。为了在当前主流的平台都能获得最佳性能，所有的 block 的长度都是8字节对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT               8               <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT_SHIFT         3</span></span><br></pre></td></tr></table></figure>
<p>block 上限，当申请的内存大小小于这个上限时，Python 可以使用不同种类的 block 来满足对内存的需求；当神奇的内存大小超过这个上限，Python 就会对内存的请求转交给第一层的内存管理机制，即 PyMem 函数族，来处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALL_REQUEST_THRESHOLD 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br></pre></td></tr></table></figure>
<p>现在，需要指出一个相当关键的点，虽然我们这里谈论了很多block，但是在Python中，block只是一个概念，在Python源码中没有与之对应的实体存在。之前我们说对象，对象在Python源码中有对应的PyObject；我们说列表，列表在Python源码中对应PyListObject、PyType_List。这里的block就很奇怪了，它仅仅是概念上的东西，我们知道它是具有一定大小的内存，但它不与Python源码里的某个东西对应。然而，Python却提供了一个管理block的东西，这就是下面要剖析的pool。</p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>一组 block 的集合称为一个 pool，换句话说，一个 pool 管理着一堆有固定大小的内存块。事实上，pool 管理着一大块内存，它由一定的策略，将这块大的内存划分为多个小的内存块。在 Python 中，一个 pool 的大小通常为一个系统内存页，由于当前大多数 Python 支持的系统的内存页都是4KB，所以 Python 内部也将一个 pool 的大小定义为4KB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PAGE_SIZE        (4 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Size of the pools used for small blocks. Should be a power of 2,</span></span><br><span class="line"><span class="comment"> * between 1K and SYSTEM_PAGE_SIZE, that is: 1k, 2k, 4k.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE               SYSTEM_PAGE_SIZE        <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When you say memory, my mind reasons in terms of (pointers to) blocks */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span> block;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123; block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* number of allocated blocks    */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* pool's free list head         */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* next pool of this size class  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* previous pool       ""        */</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* index into arenas of base adr */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* block size class index        */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* bytes to virgin block         */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* largest valid nextoffset      */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4KB 中除去 pool_header，还有一大块内存就是 pool 中维护的 block 的集合占用的内存。</p>
<p>前面提到block 是有固定大小的内存块，因此，pool 也携带了大量这样的信息。一个 pool 管理的所有 block，它们的大小都是一样的。也就是说，一个 pool 可能管理了100个32个字节的 block，也可能管理了100个64个字节的 block，但是绝不会有一个管理了50个32字节的 block 和50个64字节的 block 的 pool 存在。每一个 pool 都和一个 size 联系在一起，更确切地说，都和一个 size class index 联系在一起。这就是 <code>pool_header</code> 中的 szindex 的意义。</p>
<p>假设我们手上现在有一块 4KB 的内存，来看看 Python 是如何将这块内存改造为一个管理32字节 block 的 pool，并从 pool 中取出第一块 block 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]-[convert 4k raw memory to pool]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUNDUP(x)    (((x) + ALIGNMENT_MASK) &amp; ~ALIGNMENT_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_OVERHEAD   ROUNDUP(sizeof(struct pool_header))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> struct pool_header* poolp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar block</span></span><br><span class="line"></span><br><span class="line">poolp pool;</span><br><span class="line">block* bp;</span><br><span class="line">…… <span class="comment">// pool指向了一块4kB的内存</span></span><br><span class="line">pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//设置pool的size class index</span></span><br><span class="line">pool-&gt;szidx = size; </span><br><span class="line"><span class="comment">//将size class index转换为size，比如3转换为32字节</span></span><br><span class="line">size = INDEX2SIZE(size); </span><br><span class="line"><span class="comment">//跳过用于pool_header的内存，并进行对齐</span></span><br><span class="line">bp = (block *)pool + POOL_OVERHEAD; </span><br><span class="line"><span class="comment">//实际就是pool-&gt;nextoffset = POOL_OVERHEAD+size+size</span></span><br><span class="line">pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>); </span><br><span class="line">pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">pool-&gt;freeblock = bp + size;</span><br><span class="line">*(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// bp 返回的实际是一个地址，这个地址之后有将近 4KB 的内存实际上都是可用的，但是可用肯定申请内存的函数只会使用[bp, bp+size] 这个区间的内存，这是由 size class index 可用保证的。</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%886.54.29.png?raw=true" alt="改造成 pool 后的 4KB 内存"></p>
<p>注意其中的实线箭头是指针，但是虚线箭头不是代表指针，是偏移位置的形象表示。在nextoffset和maxnextoffset中存储的是相对于poo头部的偏移位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]-[allocate block]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">            ++pool-&gt;ref.count;</span><br><span class="line">            bp = pool-&gt;freeblock;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">                <span class="comment">//有足够的block空间</span></span><br><span class="line">                pool-&gt;freeblock = (block *)pool + pool-&gt;nextoffset;</span><br><span class="line">                pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">                <span class="comment">// 设置*freeblock 的动作正是建立离散自由 block 链表的关键所在</span></span><br><span class="line">                *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>原来freeblock指向的是下一个可用的block的起始地址，这一点在上图中也可以看得出。当再次申请32字节的block时，只需返回freeblock指向的地址就可以了，很显然，这时freeblock需要向前进，指向下一个可用的block。这时，nextoffset现身了。</p>
<p>在pool header中，nextoffset和maxoffset是两个用于对pool中的block集合进行迭代的变量：从初始化pool的结果及图16-2中可以看到，它所指示的偏移位置正好指向了freeblock之后的下一个可用的block的地址。从这里分配block的动作也可以看到，在分配了block之后，freeblock和nextoffset都会向前移动一个block的距离，如此反复，就可对所有的block进行一次遍历。而maxnextoffset指名了该pool中最后一个可用的block距pool开始位置的便移，它界定了pool的边界，当nextoffset &gt; maxnextoff 时，也就意味着已经遍历完了pool中所有的block了。</p>
<p>可以想像，一旦Python运转起来，内存的释放动作将会导致pool中出现大量的离散的自由block，Python必须建立一种机制，将这些离散的自由block组织起来，再次使用。这个机制就是所谓的自由block链表。这个链表的关键就着落在pool_header中的那个freeblock身上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="comment">//基于地址P获得离P最近的pool的边界地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_ADDR(P) ((poolp)((uptr)(P) &amp; ~(uptr)POOL_SIZE_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PyObject_Free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="comment">//判断p指向的block是否属于pool</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ADDRESS_IN_RANGE(p, pool)) &#123;</span><br><span class="line">        <span class="comment">// 被释放的第一个字节的值被设置为当前的 freeblock 的值</span></span><br><span class="line">        *(block **)p = lastfree = pool-&gt;freeblock; </span><br><span class="line">        <span class="comment">// pool 的值被更新，指向其首地址，则一个 block 被插入到了离散自由的 block 链表中</span></span><br><span class="line">        pool-&gt;freeblock = (block *)p;             </span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%887.25.44.png?raw=true" alt="释放了 block 之后产生的自由 block 链表"></p>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>在 Python 中，多个 pool 聚合的结果就是一个 arena。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object/obmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arena 大小的默认值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_SIZE              (256 &lt;&lt; 10)     <span class="comment">/* 256KB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//arena_object 是 arena 的一部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Record keeping for arenas. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The address of the arena, as returned by malloc.  Note that 0</span></span><br><span class="line"><span class="comment">     * will never be returned by a successful malloc, and is used</span></span><br><span class="line"><span class="comment">     * here to mark an arena_object that doesn't correspond to an</span></span><br><span class="line"><span class="comment">     * allocated arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pool-aligned pointer to the next pool to be carved off. */</span></span><br><span class="line">    block* pool_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The number of available pools in the arena:  free pools + never-</span></span><br><span class="line"><span class="comment">     * allocated pools.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    uint nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The total number of pools in the arena, whether or not available. */</span></span><br><span class="line">    uint ntotalpools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Singly-linked list of available pools. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whenever this arena_object is not associated with an allocated</span></span><br><span class="line"><span class="comment">     * arena, the nextarena member is used to link all unassociated</span></span><br><span class="line"><span class="comment">     * arena_objects in the singly-linked `unused_arena_objects` list.</span></span><br><span class="line"><span class="comment">     * The prevarena member is unused in this case.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When this arena_object is associated with an allocated arena</span></span><br><span class="line"><span class="comment">     * with at least one available pool, both members are used in the</span></span><br><span class="line"><span class="comment">     * doubly-linked `usable_arenas` list, which is maintained in</span></span><br><span class="line"><span class="comment">     * increasing order of `nfreepools` values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Else this arena_object is associated with an allocated arena</span></span><br><span class="line"><span class="comment">     * all of whose pools are in use.  `nextarena` and `prevarena`</span></span><br><span class="line"><span class="comment">     * are both meaningless in this case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="『未使用』的-arena-和『可用』的-arena"><a href="#『未使用』的-arena-和『可用』的-arena" class="headerlink" title="『未使用』的 arena 和『可用』的 arena"></a>『未使用』的 arena 和『可用』的 arena</h4><p>实际上，在Python中，确实会存在多个arena_object构成的集合，但是这个集合并不构成链表，而是构成了一个arena的数组。数组的首地址由arenas维护，这个数组就是Python中的通用小块内存的内存池；另一方面，nextarea和prevarea也确实是用来连接arena_object组成链表的。</p>
<p>pool_header管理的内存与pool_header自身是一块连续的内存，而areana_object与其管理的内存则是分离的。这后面隐藏着这样一个事实：当pool_header被申请时，它所管理的block集合的内存一定也被申请了；但是当aerna_object被申请时，它所管理的pool集合的内存则没有被申请。换句话说，arena_object和pool集合在某一时刻需要建立联系。注意，这个建立联系的时刻是一个关键的时刻，Python从这个时刻一刀切下，将一个arena_object切分为两种状态。</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%887.49.39.png?raw=true" alt="pool 和 arena 的内存布局区别"></p>
<p>当一个arena的area_object没有与pool集合建立联系时，这时的arena处于“未使用”状态；一旦建立了联系，这时arena就转换到了“可用”状态。对于每一种状态，都有一个arena的链表。“未使用”的arena的链表表头是unused_arena_objects、arena与arena之间通过nextarena连接，是一个单向链表；而“可用”的arena的链表表头是usable_arenas、arena与arena之间通过nextarena和prevarena连接，是一个双向链表。</p>
<p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%887.56.39.png?raw=true" alt="某一时刻多个 arena 的一个可能状态"></p>
<h4 id="申请-arena"><a href="#申请-arena" class="headerlink" title="申请 arena"></a>申请 arena</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//arenas管理着arena_object的集合</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenas</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="comment">//当前arenas中管理的arena_object的个数</span></span><br><span class="line"><span class="keyword">static</span> uint maxarenas = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//“未使用的”arena_object链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">unused_arena_objects</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="comment">//“可用的”arena_object链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">usable_arenas</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="comment">//初始化时需要申请的arena_object的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL_ARENA_OBJECTS 16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct arena_object* <span class="title">new_arena</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span> </span><br><span class="line">    uint excess;  <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//[1]: 判断是否需要扩充“未使用的”arena_object列表</span></span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123; <span class="comment">// if one</span></span><br><span class="line">    uint i;</span><br><span class="line">    uint numarenas;</span><br><span class="line">    <span class="keyword">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]: 确定本次需要申请的arena_object的个数，并申请内存</span></span><br><span class="line">    numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line">    <span class="keyword">if</span> (numarenas &lt;= maxarenas)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//overflow（溢出）</span></span><br><span class="line">    nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">    <span class="keyword">if</span> (nbytes / <span class="keyword">sizeof</span>(*arenas) != numarenas)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//overflow</span></span><br><span class="line">    arenaobj = (struct arena_object *)<span class="built_in">realloc</span>(arenas, nbytes);</span><br><span class="line">    <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    arenas = arenaobj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[3]: 初始化新申请的arena_object，并将其放入unused_arena_objects链表中</span></span><br><span class="line">    <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">      arenas[i].address = <span class="number">0</span>;  <span class="comment">/* mark as unassociated */</span></span><br><span class="line">      arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ? &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Update globals. */</span></span><br><span class="line">    unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">    maxarenas = numarenas;</span><br><span class="line">&#125; <span class="comment">// end one</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//[4]: 从unused_arena_objects链表中取出一个“未使用的”arena_object</span></span><br><span class="line">    arenaobj = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">    assert(arenaobj-&gt;address == <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//[5]: 申请arena_object管理的内存</span></span><br><span class="line">    arenaobj-&gt;address = (uptr)<span class="built_in">malloc</span>(ARENA_SIZE);</span><br><span class="line">    ++narenas_currently_allocated;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//[6]: 设置pool集合的相关信息</span></span><br><span class="line">    arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line">    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">    arenaobj-&gt;nfreepools = ARENA_SIZE / POOL_SIZE;</span><br><span class="line">    <span class="comment">//将pool的起始地址调整为系统页的边界</span></span><br><span class="line">    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line">    <span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">    --arenaobj-&gt;nfreepools;</span><br><span class="line">    arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">   &#125;</span><br><span class="line">    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><h4 id="可用-pool-缓冲池——usedpools"><a href="#可用-pool-缓冲池——usedpools" class="headerlink" title="可用 pool 缓冲池——usedpools"></a>可用 pool 缓冲池——usedpools</h4><p>Python 内部默认的小块内存与大块内存的分界点定在512个字节，这个分界点由前面我们看到的名为<code>SMALL_REQUEST_THRESHOLD</code> 的符号控制。也就是说，当申请的内存小于512字节时，<code>PyObject_Malloc</code> 会在内存池中申请内存；当申请的内存大于512字节时，<code>PyObject_Malloc</code> 的行为将退化为 malloc 的行为。</p>
<p>在Python中，pool是一个有size概念的内存管理抽象体，一个pool中的block总是有确定的大小，这个pool总是和某个size class index对应，还记得pool_head中的那个szidx么？而arena是没有size概念的内存管理抽象体，这就意味着，同一个arena，在某个时刻，其内的pool集合可能都是管理的32字节的block；而到了另一时刻，由于系统需要，这个arena可能被重新划分，其中的pool集合可能改为管理64字节的block了，甚至pool集合中一半管理32字节，一半管理64字节。这就决定了在进行内存分配和销毁时，所有的动作都是在pool上完成的。</p>
<p>内存池中的pool，不仅是一个有size概念的内存管理抽象体，而且，更进一步的，它还是一个有状态的内存管理抽象体。一个pool在Python运行的任何一个时刻，总是处于以下三种状态的一种：</p>
<ul>
<li>used状态：pool中至少有一个block已经被使用，并且至少有一个block还未被使用。这种状态的pool受控于Python内部维护的usedpools数组；</li>
<li>full状态：pool中所有的block都已经被使用，这种状态的pool在arena中，但不在arena的freepools链表中；</li>
<li>empty状态：pool中所有的block都未被使用，处于这个状态的pool的集合通过其pool_header中的nextpool构成一个链表，这个链表的表头就是arena_object中的freepools；</li>
</ul>
<p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.25.34.png?raw=true" alt="某个时刻 aerna 中 pool 集合的可能状态"></p>
<p>Python内部维护的usedpools数组是一个非常巧妙的实现，维护着所有的处于used状态的pool。当申请内存时，Python就会通过usedpools寻找到一块可用的（处于used状态的）pool，从中分配一个block。一定有一个与usedpools相关联的机制，完成从申请的内存的大小到size class index之间的转换，否则Python也就无法寻找到最合适的pool了。这种机制与usedpools的结构有密切的关系，我们来看一看usedpools的结构。</p>
<p>一定有一个与usedpools相关联的机制，完成从申请的内存的大小到size class index之间的转换，否则Python也就无法寻找到最合适的pool了。这种机制与usedpools的结构有密切的关系，我们来看一看usedpools的结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uchar block;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTA(x)  ((poolp )((uchar *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT(x)   PTA(x), PTA(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 poolp 指的就是 pool_head</span></span><br><span class="line"><span class="keyword">static</span> poolp usedpools[<span class="number">2</span> * ((NB_SMALL_SIZE_CLASSES + <span class="number">7</span>) / <span class="number">8</span>) * <span class="number">8</span>] = &#123;</span><br><span class="line">    PT(<span class="number">0</span>), PT(<span class="number">1</span>), PT(<span class="number">2</span>), PT(<span class="number">3</span>), PT(<span class="number">4</span>), PT(<span class="number">5</span>), PT(<span class="number">6</span>), PT(<span class="number">7</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">8</span> <span class="comment">//指明了在当前的配置之下，一共有多少个 size class</span></span><br><span class="line">    , PT(<span class="number">8</span>), PT(<span class="number">9</span>), PT(<span class="number">10</span>), PT(<span class="number">11</span>), PT(<span class="number">12</span>), PT(<span class="number">13</span>), PT(<span class="number">14</span>), PT(<span class="number">15</span>)</span><br><span class="line">    …… </span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>NB_SMALL_SIZE_CLASSES</code>指明了在当前的配置之下，一共有多少个size class。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.29.02.png?raw=true" alt="usedpools 数组"></p>
<p>Python会首先获得 size class index，通过 size = (uint )(nbytes - 1) &gt;&gt; ALIGNMENT_SHIFT，得到 size class index 为3。在usedpools 中，寻找第3+3=6个元素，发现 usedpools[6] 的值是指向 usedpools[4] 的地址。有些迷惑了，对吧？好了，现在对照 pool_header 的定义来看一看 usedpools[6] -&gt; nextpool 这个指针指向哪里了呢？是从 usedpools[6]（即usedpools+4）开始向后偏移8个字节（一个ref的大小加上一个freeblock的大小）后的内存，不正是 usedpools[6] 的地址（即usedpools+6）吗？这是Python内部使用的一个 trick。</p>
<p>想象一下，当我们手中有一个size class为32字节的pool，想要将其放入这个usedpools中时，需要怎么做呢？从上面的描述可以看到，只需要进行usedpools[i+i]-&gt;nextpool = pool即可，其中i为size class index，对应于32字节，这个i为3。当下次需要访问size class为32字节（size class index为3）的pool时，只需要简单地访问usedpool[3+3]就可以得到了。Python正是使用这个usedpools快速地从众多的pool中快速地寻找到一个最适合当前内存需求的pool，从中分配一块block。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">PyObject_Malloc</span><span class="params">(<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block *bp;</span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line">    <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">        LOCK();</span><br><span class="line">        <span class="comment">//获得size class index</span></span><br><span class="line">        size = (uint )(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">        pool = usedpools[size + size];</span><br><span class="line">        <span class="comment">//usedpools中有可用的pool</span></span><br><span class="line">        <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">            ……<span class="comment">//usedpools中有可用的pool</span></span><br><span class="line">        &#125;</span><br><span class="line">        …… <span class="comment">//usedpools中无可用pool，尝试获取empty状态pool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Pool-的初始化"><a href="#Pool-的初始化" class="headerlink" title="Pool 的初始化"></a>Pool 的初始化</h4><p>当 Python 启动之后，在 usedpools 这个小块空间内存池中，并不存在任何可用的内存，准确地说，不存在任何可用的pool。在这里，Python 采用了延迟分配的策略，即当我们确实开始申请小块内存时，Python 才开始建立这个内存池。</p>
<p>考虑一下这样的情况，当申请32字节内存时，从“可用的” arena 中取出其中一个 pool 用作32字节的 pool 。当下一次内存分配请求分配64字节的内存时，Python 可以直接使用当前“可用的” arena 的另一个 pool 即可。这正如我们前面所说， arena 没有 size class 的属性，而 pool 才有（见下面代码）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">PyObject_Malloc</span><span class="params">(<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block *bp; </span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">    LOCK();</span><br><span class="line">    size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">    pool = usedpools[size + size];</span><br><span class="line">    <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">      …… <span class="comment">//usedpools中有可用的pool</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//usedpools中无可用pool，尝试获取empty状态pool</span></span><br><span class="line">    <span class="comment">//[1]: 如果usable_arenas链表为空，则创建链表</span></span><br><span class="line">    <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//申请新的arena_object，并放入usable_arenas链表</span></span><br><span class="line">      usable_arenas = new_arena();</span><br><span class="line">      usable_arenas-&gt;nextarena = usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[2]: 从usable_arenas链表中第一个arena的freepools中抽取一个可用的pool</span></span><br><span class="line">    pool = usable_arenas-&gt;freepools;</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      usable_arenas-&gt;freepools = pool-&gt;nextpool;</span><br><span class="line">      <span class="comment">//[3]: 调整usable_arenas链表中第一个arena中的可用pool数量</span></span><br><span class="line">      <span class="comment">//如果调整后数量为0，则将该arena从usable_arenas链表中摘除</span></span><br><span class="line">      --usable_arenas-&gt;nfreepools;</span><br><span class="line">      <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">        usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">        <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    init pool:</span><br><span class="line">            ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="初始化之一"><a href="#初始化之一" class="headerlink" title="初始化之一"></a>初始化之一</h5><p>好了，现在我们手里有了一块用于32字节内存分配的pool，为了以后提高内存分配的效率，我们需要将这个pool放入到usedpools中。这一步，叫做init pool。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUNDUP(x)    (((x) + ALIGNMENT_MASK) &amp; ~ALIGNMENT_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_OVERHEAD   ROUNDUP(sizeof(struct pool_header))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">PyObject_Malloc</span><span class="params">(<span class="keyword">size_t</span> nbytes)</span> </span>&#123;</span><br><span class="line">……</span><br><span class="line">init_pool:</span><br><span class="line">            <span class="comment">//[1]: 将pool放入usedpools中</span></span><br><span class="line">            next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">            pool-&gt;nextpool = next;</span><br><span class="line">            pool-&gt;prevpool = next;</span><br><span class="line">            next-&gt;nextpool = pool;</span><br><span class="line">            next-&gt;prevpool = pool;</span><br><span class="line">            pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//[2]：pool在之前就具有正确的size结构，直接返回pool中的一个block</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;szidx == size) &#123;</span><br><span class="line">                bp = pool-&gt;freeblock;</span><br><span class="line">                pool-&gt;freeblock = *(block **)bp;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//[3]： 初始化pool header，将freeblock指向第二个block，返回第一个block</span></span><br><span class="line">            pool-&gt;szidx = size;</span><br><span class="line">            size = INDEX2SIZE(size);</span><br><span class="line">            bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">            pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">            pool-&gt;freeblock = bp + size;</span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在什么样的情况下才会发生一个 pool 从 empty 状态转换为 used 状态呢？假设申请的内存的 size class index 为 i，且 usedpools[i+i] 处没有处于 used 状态的 pool ，同时在 Python 维护的全局变量 freepools 中还有处于 empty 的 pool ，那么位于 freepools 所维护的 pool 链表头部的 pool 将被取出来，放入 usedpools 中，并从其内部分配一块 block 。同时，这个 pool 也就从 empty 状态转换到了 used 状态。下面我们看一看这个行为在代码中是如何体现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line">    ……</span><br><span class="line">        pool = usable_arenas-&gt;freepools;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            usable_arenas-&gt;freepools = pool-&gt;nextpool;</span><br><span class="line">            …… <span class="comment">//调整usable_arenas-&gt;nfreepools和usable_arenas自身</span></span><br><span class="line">            [init_pool] </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="初始化之二"><a href="#初始化之二" class="headerlink" title="初始化之二"></a>初始化之二</h5><p>我们现在可以来看看，当PyObject_Malloc从new_arena中得到一个新的arena后，是怎么样来初始化其中的pool集合，并最终完成PyObject_Malloc函数的分配一个block这个终极任务的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUMMY_SIZE_IDX    0xffff  <span class="comment">/* size class of newly cached pools */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">PyObject_Malloc</span><span class="params">(<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block *bp; </span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//[1]：从arena中取出一个新的pool</span></span><br><span class="line">    pool = (poolp)usable_arenas-&gt;pool_address;</span><br><span class="line">    <span class="comment">// 设置 pool 中的 arenaindex，这个 index 实际上就是 pool 所在的 arena 位于 arenas 所指的数组的序号。用于判断一个 block 是否在某个 pool 中。</span></span><br><span class="line">    pool-&gt;arenaindex = usable_arenas - arenas;</span><br><span class="line">    <span class="comment">// 随后 Python 将新得到的 pool 的 szidx 设置为 0xffff，表示从没管理过 block 集合。</span></span><br><span class="line">    pool-&gt;szidx = DUMMY_SIZE_IDX;</span><br><span class="line">    <span class="comment">// 调整刚获得的 arena 中的 pools 集合，甚至可能调整 usable_arenas</span></span><br><span class="line">    usable_arenas-&gt;pool_address += POOL_SIZE;</span><br><span class="line">    --usable_arenas-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Unlink the arena:  it is completely allocated. */</span></span><br><span class="line">    usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">    <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> init_pool;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="block-的释放"><a href="#block-的释放" class="headerlink" title="block 的释放"></a>block 的释放</h4><p>pool 的状态变更最为常见的还是之前是 used 之后也是 used：</p>
<p>在pool的状态保持used状态这种情况下，Python仅仅将block重新放入到自由block链表中，并调整了pool中的ref.count这个引用计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PyObject_Free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="keyword">if</span> (Py_ADDRESS_IN_RANGE(p, pool)) &#123;</span><br><span class="line">        <span class="comment">//设置离散自由block链表</span></span><br><span class="line">        *(block **)p = lastfree = pool-&gt;freeblock;</span><br><span class="line">        pool-&gt;freeblock = (block *)p;</span><br><span class="line">        <span class="keyword">if</span> (lastfree) &#123; <span class="comment">//lastfree有效，表明当前pool不是处于full状态</span></span><br><span class="line">             <span class="keyword">if</span> (--pool-&gt;ref.count != <span class="number">0</span>) &#123; <span class="comment">//pool不需要转换为empty状态</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//待释放的内存在PyObject_Malloc中是通过malloc获得的</span></span><br><span class="line">    <span class="comment">//所以要归还给系统</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们释放一个 block 后，可能会引起 pool 的状态的转变，这种转变可分为两种情况：</p>
<ul>
<li><p>full状态转变为used状态</p>
<p> 仅仅是将 pool 重新链回到 usedpools 中即可</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PyObject_Free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="keyword">if</span> (Py_ADDRESS_IN_RANGE(p, pool)) &#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">//当前pool处于full状态，在释放一块block后，需将其转换为used状态，并重新</span></span><br><span class="line">        <span class="comment">//链入usedpools的头部</span></span><br><span class="line">        --pool-&gt;ref.count;</span><br><span class="line">        size = pool-&gt;szidx;</span><br><span class="line">        next = usedpools[size + size];</span><br><span class="line">        prev = next-&gt;prevpool;</span><br><span class="line">        <span class="comment">/* insert pool before next:   prev &lt;-&gt; pool &lt;-&gt; next */</span></span><br><span class="line">        pool-&gt;nextpool = next;</span><br><span class="line">        pool-&gt;prevpool = prev;</span><br><span class="line">        next-&gt;prevpool = pool;</span><br><span class="line">        prev-&gt;nextpool = pool;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>used状态转变为empty状态</p>
<p> 首先 Python 要做的是将empty状态的 pool 链入到 freepools 中去</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PyObject_Free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="keyword">if</span> (Py_ADDRESS_IN_RANGE(p, pool)) &#123;</span><br><span class="line">        *(block **)p = lastfree = pool-&gt;freeblock;</span><br><span class="line">        pool-&gt;freeblock = (block *)p;</span><br><span class="line">        <span class="keyword">if</span> (lastfree) &#123; </span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">ao</span>;</span> </span><br><span class="line">             uint nf;  <span class="comment">//ao-&gt;nfreepools </span></span><br><span class="line">             <span class="keyword">if</span> (--pool-&gt;ref.count != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将pool放入freepools维护的链表中</span></span><br><span class="line">            <span class="comment">// 这里隐藏着一个类似于内存泄露的问题：arena 从来不释放 pool</span></span><br><span class="line">            ao = &amp;arenas[pool-&gt;arenaindex];</span><br><span class="line">            pool-&gt;nextpool = ao-&gt;freepools;</span><br><span class="line">            ao-&gt;freepools = pool;</span><br><span class="line">            nf = ++ao-&gt;nfreepools;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 现在开始处理 arena，分为四种情况：</p>
<ul>
<li><p>如果arena中所有的pool都是empty的，释放pool集合占用的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [obmalloc.c]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PyObject_Free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">ao</span>;</span>  </span><br><span class="line">    uint nf;  <span class="comment">//ao-&gt;nfreepools </span></span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//将pool放入freepools维护的链表中</span></span><br><span class="line">    ao = &amp;arenas[pool-&gt;arenaindex];</span><br><span class="line">    pool-&gt;nextpool = ao-&gt;freepools;</span><br><span class="line">    ao-&gt;freepools = pool;</span><br><span class="line">    nf = ++ao-&gt;nfreepools;</span><br><span class="line">    <span class="keyword">if</span> (nf == ao-&gt;ntotalpools) &#123;</span><br><span class="line">        <span class="comment">//调整usable_arenas链表</span></span><br><span class="line">        <span class="keyword">if</span> (ao-&gt;prevarena == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            usable_arenas = ao-&gt;nextarena;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ao-&gt;prevarena-&gt;nextarena = ao-&gt;nextarena;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (ao-&gt;nextarena != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ao-&gt;nextarena-&gt;prevarena = ao-&gt;prevarena;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调整unused_arena_objects链表</span></span><br><span class="line">        ao-&gt;nextarena = unused_arena_objects;</span><br><span class="line">        unused_arena_objects = ao;</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">free</span>((<span class="keyword">void</span> *)ao-&gt;address);</span><br><span class="line">        <span class="comment">//设置address，将arena的状态转为“未使用”</span></span><br><span class="line">        ao-&gt;address = <span class="number">0</span>;</span><br><span class="line">        --narenas_currently_allocated;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果之前arena中没有了empty的pool，那么在usable_arenas链表中就找不到该arena，由于现在arena中有了一个pool，所以需要将这个aerna链入到usable_arenas链表的表头。</p>
</li>
<li><p>若arena中的empty的pool个数为n，则从usable_arenas开始寻找arena可以插入的位置，将arena插入到usable_arenas。这个操作的原因是由于usable_arenas实际上是一个有序的链表，从表头开始往后，每一个arena中的empty的pool的个数，即nfreepools，都不能大于前面的arena，也不能小于前面的arena。保持这种有序性的原因是分配block时，是从usable_arenas的表头开始寻找可用的arena的，这样，就能保证如果一个arena的empty pool数量越多，它被使用的机会就越少。因此，它最终释放其维护的pool集合的内存的机会就越大，这样就能保证多余的内存会被归还给系统。</p>
</li>
<li><p>其他情况，不进行任何对arena的处理。</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h4 id="内存池全景"><a href="#内存池全景" class="headerlink" title="内存池全景"></a>内存池全景</h4><p><img src="https://github.com/BingLau7/blog/blob/master/Image/blog_18/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%889.59.26.png?raw=true" alt="Python 的小块内存的内存池全景"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Python 源码解析》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/浅谈动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/浅谈动态规划/" itemprop="url">浅谈动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:49:34+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇是个人动态规划笔记。</p>
<h4 id="应用动态规划方法："><a href="#应用动态规划方法：" class="headerlink" title="应用动态规划方法："></a>应用动态规划方法：</h4><ol>
<li>刻画一个最优解的结构特征</li>
<li>递归地定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造一个最优解</li>
</ol>
<h4 id="动态规划两种等价的实现方法："><a href="#动态规划两种等价的实现方法：" class="headerlink" title="动态规划两种等价的实现方法："></a>动态规划两种等价的实现方法：</h4><ol>
<li>带备忘的自顶向下法：此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，过程首先检查是否保存过此解。如果是，则直接返回保存的值，从而节省了计算时间，否则，按通常方式计算这个子问题。</li>
<li>自底向上法：这种方法一般需要恰当定义子问题『规模』的概念，使得任何子问题的求解都只依赖于『更小的』子问题的求解。因而我们可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个子问题时，它所引来的那些更小的子问题都已求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它（也是第一次遇到它）时，它的所有前提子问题都已求解完成。</li>
</ol>
<h4 id="适合动态规划求解的两个要素"><a href="#适合动态规划求解的两个要素" class="headerlink" title="适合动态规划求解的两个要素"></a>适合动态规划求解的两个要素</h4><h5 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h5><p>如果一个问题的最优解包含其子问题的最优解没我们就称此问题具有最优子结构性质。</p>
<p><strong>发掘此问题具有最优子结构性质的通用模式：</strong></p>
<ol>
<li>证明问题最优解的第一个组成部分是做出一个选择，做出这次选择产生一个或多个待解的子问题。</li>
<li>对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。</li>
<li>给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，已经如何最好地刻画子问题空间。</li>
<li>利用『剪切-粘贴』(cut-and-paste) 技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。证明这一点是利用反证法：假定子问题的解不是其自身的最优解，那么我们就可以从原问题的解中『剪切』掉这些非最优解，将最优解『粘贴』进去，从而得到原问题一个最优的解，这与最初的解释原问题最优解的前提假设矛盾。</li>
</ol>
<p>一个刻画子问题空间的好经验是：保持子问题空间尽可能简单，只在必要时才扩展它。</p>
<p>对于不同领域，最优子结构的不同体现在两个方面：</p>
<ol>
<li>原问题的最优解中设计多少个子问题，以及</li>
<li>在确定最优解使用哪些子问题时，我们需要考察多少种选择</li>
</ol>
<p>算法导论有两个实例值得一看。</p>
<h5 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h5><p>适合用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够『小』，即问题的递归算法会反复地求解相同的子问题，而不是一直声称新的子问题，即具有重复子问题性质。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><a href="https://github.com/BingLau7/alg/blob/master/java/src/main/java/io/github/binglau/dynamic_programming/LCS.java" target="_blank" rel="noopener">最长公共子序列</a></p>
<h4 id="参考书籍："><a href="#参考书籍：" class="headerlink" title="参考书籍："></a>参考书籍：</h4><p>《算法导论》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/yield与yield-from备忘录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘冰鉴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="村里最好的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/yield与yield-from备忘录/" itemprop="url">yield与yield from备忘录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T16:49:05+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于 <code>yield</code>与<code>yield from</code>的语法，官方给出的解释<a href="https://docs.python.org/3.6/reference/simple_stmts.html#yield" target="_blank" rel="noopener">Link</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> &lt;expr&gt;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> &lt;expr&gt;</span><br></pre></td></tr></table></figure>
<p>等于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">yield</span> &lt;expr&gt;)</span><br><span class="line">(<span class="keyword">yield</span> <span class="keyword">from</span> &lt;expr&gt;)</span><br></pre></td></tr></table></figure>
<p>要理解<code>yield</code>需要先介绍几个概念</p>
<h3 id="Iterables（可迭代对象）"><a href="#Iterables（可迭代对象）" class="headerlink" title="Iterables（可迭代对象）"></a><code>Iterables</code>（可迭代对象）</h3><blockquote>
<p> An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as <a href="https://docs.python.org/3.6/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>, <a href="https://docs.python.org/3.6/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, and <a href="https://docs.python.org/3.6/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a>) and some non-sequence types like <a href="https://docs.python.org/3.6/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>, <a href="https://docs.python.org/3.6/glossary.html#term-file-object" target="_blank" rel="noopener">file objects</a>, and objects of any classes you define with an <a href="https://docs.python.org/3.6/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> or <a href="https://docs.python.org/3.6/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> method. Iterables can be used in a <a href="https://docs.python.org/3.6/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> loop and in many other places where a sequence is needed (<a href="https://docs.python.org/3.6/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a>, <a href="https://docs.python.org/3.6/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a>, …).</p>
<p>  When an iterable object is passed as an argument to the built-in function <a href="https://docs.python.org/3.6/library/functions.html#iter" target="_blank" rel="noopener"><code>iter()</code></a>, it returns an iterator for the object. This iterator is good for one pass over the set of values. When using iterables, it is usually not necessary to call <a href="https://docs.python.org/3.6/library/functions.html#iter" target="_blank" rel="noopener"><code>iter()</code></a> or deal with iterator objects yourself. The <code>for</code> statement does that automatically for you, creating a temporary unnamed variable to hold the iterator for the duration of the loop. See also <a href="https://docs.python.org/3.6/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>, <a href="https://docs.python.org/3.6/glossary.html#term-sequence" target="_blank" rel="noopener">sequence</a>, and <a href="https://docs.python.org/3.6/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist :</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>所有你可以使用 <code>for .. in ..</code> 语法的叫做一个迭代器：列表，字符串，文件……你经常使用它们是因为你可以如你所愿的读取其中的元素，但是你把所有的值都存储到了内存中，如果你有大量数据的话这个方式并不是你想要的。</p>
<h3 id="Generators（生成器）"><a href="#Generators（生成器）" class="headerlink" title="Generators（生成器）"></a><code>Generators</code>（生成器）</h3><blockquote>
<p> A function which returns a <a href="https://docs.python.org/3.6/glossary.html#term-generator-iterator" target="_blank" rel="noopener">generator iterator</a>. It looks like a normal function except that it contains <strong><a href="https://docs.python.org/3.6/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> expressions</strong> for producing a series of values usable in a for-loop or that can be retrieved one at a time with the <a href="https://docs.python.org/3.6/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> function.</p>
<p> Usually refers to a generator function, but may refer to a <em>generator iterator</em> in some contexts. In cases where the intended meaning isn’t clear, using the full terms avoids ambiguity.</p>
</blockquote>
<p>生成器是可以迭代的，但是你 <strong>只可以读取它一次</strong> ，因为它并不把所有的值放在内存中，它是实时地生成数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator :</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>看起来除了把 <code>[]</code> 换成 <code>()</code> 外没什么不同。但是，你不可以再次使用 <code>for i inmygenerator</code> , 因为生成器只能被迭代一次：先计算出0，然后继续计算1，然后计算4，一个跟一个的…</p>
<p>其实这里跟<strong>流的概念</strong>（计算机程序的构造与解释）是一样的，所谓流就是一个语法糖而已，如果用Python来实现，应该可以这么做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, l)</span>:</span></span><br><span class="line">        self.l = l</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.l) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.l.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> Generator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]):</span><br><span class="line">   ...:     print(i)</span><br><span class="line">   ...:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>当然，我这只是简单范例，以后我会再结合Python源码来说明生成器是如何实现的（挖了个大坑）。</p>
<h3 id="yield语法"><a href="#yield语法" class="headerlink" title="yield语法"></a><code>yield</code>语法</h3><p>先给出官方文档连接（<a href="https://docs.python.org/3.6/reference/expressions.html#yield-expressions" target="_blank" rel="noopener">Link</a>）</p>
<p><code>yield</code> 是一个类似 <code>return</code> 的关键字，只是这个函数返回的是个生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span> :</span></span><br><span class="line"><span class="meta">... </span>   mylist = range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist :</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mygenerator) <span class="comment"># mygenerator is an object!</span></span><br><span class="line">&lt;generator object createGenerator at <span class="number">0xb7555c34</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这个例子没什么用途，但是它让你知道，这个函数会返回一大批你只需要读一次的值.</p>
<p>为了精通 <code>yield</code> ,你必须要理解：<strong>当你调用这个函数的时候，函数内部的代码并不立马执行</strong> ，这个函数只是返回一个生成器对象，这有点蹊跷不是吗。</p>
<p>那么，函数内的代码什么时候执行呢？当你使用for进行迭代的时候.</p>
<p>现在到了关键点了！</p>
<p>第一次迭代中你的函数会执行，从开始到达 <code>yield</code> 关键字，然后返回 <code>yield</code> 后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次，再返回那个值，直到没有可以返回的。</p>
<p>如果生成器内部没有定义 <code>yield</code> 关键字，那么这个生成器被认为成空的。这种情况可能因为是循环进行没了，或者是没有满足 <code>if/else</code> 条件。</p>
<p>看到上述解释，你可以这样认为，<code>yield</code>是实现一个语法糖，其语法是将这个函数本身传了出去，并生成一个对象，这个对象是一个生成器，其会执行一次<code>yield</code>封装的函数然后将结果作为下一次的返回值（第一次的返回值是直接返回，或者这样更好实现，就是如果检测到函数有<code>yield</code>关键字则直接封装为一个生成器对象，然后调用就是先执行一次<code>yield</code>封装的函数，然后再返回数据）。</p>
<h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a><code>yield from</code></h3><p>该语法是在<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">PEP380</a>中被定义的。总之大意是原本的yield语句只能将CPU控制权 还给直接调用者，当你想要将一个generator或者coroutine里带有 yield语句的逻辑重构到另一个generator（原文是subgenerator） 里的时候，会非常麻烦，因为外面的generator要负责为里面的 generator做消息传递；所以某人有个想法是让python把消息传递封装起来，使其对开发者透明，于是就有了<code>yield from</code>。</p>
<p><code>yield from x()</code>其中的x应该返回一个可迭代的对象(<code>Iterables</code>)，这样整个表达式会返回一个生成器(<code>Generators</code>)，我们将整个表达式称为y(就是说<code>y=lambda:yield from x()</code>)。</p>
<blockquote>
<p> The full semantics of the yield from expression can be described in terms of the generator protocol as follows:</p>
<ul>
<li>Any values that the iterator yields（x） are passed directly to the caller（y）.</li>
<li>Any values sent to the delegating generator using send() are passed directly to the iterator. If the sent value is None, the iterator’s __next__() method is called. If the sent value is not None, the iterator’s send() method is called. If the call raises StopIteration, the delegating generator is resumed. Any other exception is propagated to the delegating generator.</li>
<li>Exceptions other than GeneratorExit thrown into the delegating generator are passed to the throw() method of the iterator. If the call raises StopIteration, the delegating generator is resumed. Any other exception is propagated to the delegating generator.</li>
<li>If a GeneratorExit exception is thrown into the delegating generator, or the close() method of the delegating generator is called, then the close() method of the iterator is called if it has one. If this call results in an exception, it is propagated to the delegating generator. Otherwise, GeneratorExit is raised in the delegating generator.</li>
<li>The value of the yield from expression is the first argument to the StopIteration exception raised by the iterator when it terminates.</li>
<li>return expr in a generator causes StopIteration(expr) to be raised upon exit from the generator.</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     <span class="string">"""A generator that fakes a read from a file, socket, etc."""</span></span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">   ...:         <span class="keyword">yield</span> <span class="string">'&lt;&lt; %s'</span> % i</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="function"><span class="keyword">def</span> <span class="title">reader_wrapper</span><span class="params">(g)</span>:</span></span><br><span class="line">   ...:     <span class="comment"># Manually iterate over data produced by reader</span></span><br><span class="line">   ...:     <span class="keyword">for</span> v <span class="keyword">in</span> g:</span><br><span class="line">   ...:         <span class="keyword">yield</span> v</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: wrap = reader_wrapper(reader())</span><br><span class="line">   ...: <span class="keyword">for</span> i <span class="keyword">in</span> wrap:</span><br><span class="line">   ...:     print(i)</span><br><span class="line">   ...:</span><br><span class="line">&lt;&lt; <span class="number">0</span></span><br><span class="line">&lt;&lt; <span class="number">1</span></span><br><span class="line">&lt;&lt; <span class="number">2</span></span><br><span class="line">&lt;&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: <span class="function"><span class="keyword">def</span> <span class="title">reader_wrapper</span><span class="params">(g)</span>:</span></span><br><span class="line">   ...:     <span class="keyword">yield</span> <span class="keyword">from</span> g</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: wrap = reader_wrapper(reader())</span><br><span class="line">   ...: <span class="keyword">for</span> i <span class="keyword">in</span> wrap:</span><br><span class="line">   ...:     print(i)</span><br><span class="line">   ...:</span><br><span class="line">&lt;&lt; <span class="number">0</span></span><br><span class="line">&lt;&lt; <span class="number">1</span></span><br><span class="line">&lt;&lt; <span class="number">2</span></span><br><span class="line">&lt;&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这篇文章作为介绍Python的<code>asyncio</code>的基础文章。</p>
<p>参考文章：</p>
<ul>
<li>Python官方文档</li>
<li>PEP380</li>
<li><a href="http://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3" target="_blank" rel="noopener">In practice, what are the main uses for the new “yield from” syntax in Python 3.3?</a></li>
<li><a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do" target="_blank" rel="noopener">What does the “yield” keyword do?</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="刘冰鉴" />
          <p class="site-author-name" itemprop="name">刘冰鉴</p>
           
              <p class="site-description motion-element" itemprop="description">issue</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘冰鉴</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
