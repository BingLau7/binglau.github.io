<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>村里最好的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-12T09:52:17.116Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘冰鉴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty-UnpooledByteBuf 源码剖析</title>
    <link href="http://yoursite.com/2018/11/17/netty-UnpooledByteBuf-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2018/11/17/netty-UnpooledByteBuf-源码剖析/</id>
    <published>2018-11-17T10:13:28.000Z</published>
    <updated>2019-01-12T09:52:17.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>UnpooledByteBufAllocator 的 Heap 与 Direct 的实现</li><li>Heap 内部实现使用了 byte[]</li><li>Direct 内部依托于 <code>PlatformDependent0</code> 的各种 native 方法</li><li>toLeakAwareBuffer 部分主要讨论了 Netty 是如何应对内存泄露，以及检测内存泄露跟踪的四个级别是如何实现的</li></ol><a id="more"></a><p><strong>Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.buffer();</span><br><span class="line">buf.writeBytes(<span class="string">"test"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] readBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">buf.readBytes(readBytes);</span><br><span class="line">System.out.println(<span class="string">"read content: "</span> + <span class="keyword">new</span> String(readBytes));</span><br></pre></td></tr></table></figure><blockquote><p>入口 <code>Unpooled.buffer</code></p></blockquote><h3 id="UnpooledByteBufAllocator-的-Heap-部分解析"><a href="#UnpooledByteBufAllocator-的-Heap-部分解析" class="headerlink" title="UnpooledByteBufAllocator 的 Heap 部分解析"></a>UnpooledByteBufAllocator 的 Heap 部分解析</h3><h4 id="构造器说明"><a href="#构造器说明" class="headerlink" title="构造器说明"></a>构造器说明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">boolean</span> disableLeakDetector, <span class="keyword">boolean</span> tryNoCleaner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(preferDirect);</span><br><span class="line">    <span class="keyword">this</span>.disableLeakDetector = disableLeakDetector;</span><br><span class="line">    noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe()</span><br><span class="line">            &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>preferDirect 设置为 true 时, allocator.buffer 会先尝试分配 direct buffer 而非 heap buffer （如果能分配 direct buffer）</li><li>disableLeakDetector 设置为 true 则表示该 allocator 将关闭 leak-detection. 这个用处在于用户仅想依靠 gc 来管理 direct buffer 而不希望显式释放内存。</li><li>tryNoCleaner 设置为 true 则表示我们将尝试去使用 PlatformDependent.allocateDirectNoCleaner(int) 去分配 direct buffer（如果其他条件允许）</li></ol><h4 id="buffer-主要逻辑"><a href="#buffer-主要逻辑" class="headerlink" title="buffer() 主要逻辑"></a>buffer() 主要逻辑</h4><p>由方法追踪，跟踪 heapBuffer 的逻辑则我们能找到稍微内容多一些的方法即下面的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity); <span class="comment">// 验证 initialCapacity 的合法性</span></span><br><span class="line">    <span class="keyword">return</span> newHeapBuffer(initialCapacity, maxCapacity); <span class="comment">// core code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便一说，heapBuffer 其默认值（即我们之间调用 <code>buffer()</code> 结果）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CAPACITY = Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.hasUnsafe() ? <span class="comment">// 判断一下是否能使用 unsafe</span></span><br><span class="line">            <span class="keyword">new</span> InstrumentedUnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">            <span class="keyword">new</span> InstrumentedUnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以使用 unsafe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedUnpooledUnsafeHeapByteBuf</span> <span class="keyword">extends</span> <span class="title">UnpooledUnsafeHeapByteBuf</span> </span>&#123;</span><br><span class="line">    InstrumentedUnpooledUnsafeHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器追踪到 <code>UnpooledHeapByteBuf</code> 时候会发现一段这样的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(maxCapacity); <span class="comment">// 设置 maxCapacity 值</span></span><br><span class="line"></span><br><span class="line">    checkNotNull(alloc, <span class="string">"alloc"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"initialCapacity(%d) &gt; maxCapacity(%d)"</span>, initialCapacity, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line">    setArray(allocateArray(initialCapacity)); <span class="comment">// 单纯 setArray 逻辑即是将参数中的数组设置为 ByteBuf 的数组变量</span></span><br><span class="line">    setIndex(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 设置 readIndex 与 writeIndex 均为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一看其核心逻辑就在 allocateArray() 方法，而且可以确定的是 <code>InstrumentedUnpooledUnsafeHeapByteBuf</code> 与 <code>InstrumentedUnpooledHeapByteBuf</code> 的区别也仅在 <strong>分配(allocateArray)</strong> 与 <strong>释放(freeArray)</strong> 方法上，但是当你仔细看着两个类的代码时你会发现，他们的核心在于 <code>UnpooledUnsafeHeapByteBuf</code> 与  <code>UnpooledHeapByteBuf</code> 的 <code>allocateArray</code> 与 <code>freeArray</code> 中，这二者余下操作是针对具体 ByteBuf 内部字段的调整/监控.</p><p><code>UnpooledHeapByteBuf</code> 过于简单，就是初始化一个数组而已 <code>new byte[]</code> 就不做介绍了，让我们主要来看看 <code>UnpooledUnsafeHeapByteBuf</code> 内部调用的 <code>PlatformDependent.allocateUninitializedArray(initialCapacity)</code>。</p><p>这个方法内部逻辑是</p><ol><li>判断分配大小是否超过 <code>UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD</code> （默认 1024，可设置，对于 java9 之前或者是 java9 不给开 Unsafe 而言这个值就是 -1）</li><li>若分配 size 大小小于 <code>UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD</code> 则直接创建数组了事（new byte[]）（即<strong>对 java9 之前及不支持 Unsafe 而言，都是创建数组</strong>）</li><li>若分配 size 太大，则调用 <code>PlatformDependent0.allocateUninitializedArray(size)</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] allocateUninitializedArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>[]) ALLOCATE_ARRAY_METHOD.invoke(INTERNAL_UNSAFE, <span class="keyword">byte</span>.class, size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ALLOCATE_ARRAY_METHOD 是针对 Java9+ 的 <code>jdk.internal.misc.Unsafe.allocateUninitializedArray</code> 创建 Method, 从名称来看应该是使用了底层系统调用创建了一个未初始化的数组，一个针对性能的优化。其代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates an array of a given type, but does not do zeroing.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method should only be used in the very rare cases where a high-performance code</span></span><br><span class="line"><span class="comment"> * overwrites the destination array completely, and compilers cannot assist in zeroing elimination.</span></span><br><span class="line"><span class="comment"> * In an overwhelming majority of cases, a normal Java allocation should be used instead.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Users of this method are &lt;b&gt;required&lt;/b&gt; to overwrite the initial (garbage) array contents</span></span><br><span class="line"><span class="comment"> * before allowing untrusted code, or code in other threads, to observe the reference</span></span><br><span class="line"><span class="comment"> * to the newly allocated array. In addition, the publication of the array reference must be</span></span><br><span class="line"><span class="comment"> * safe according to the Java Memory Model requirements.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The safest approach to deal with an uninitialized array is to keep the reference to it in local</span></span><br><span class="line"><span class="comment"> * variable at least until the initialization is complete, and then publish it &lt;b&gt;once&lt;/b&gt;, either</span></span><br><span class="line"><span class="comment"> * by writing it to a &lt;em&gt;volatile&lt;/em&gt; field, or storing it into a &lt;em&gt;final&lt;/em&gt; field in constructor,</span></span><br><span class="line"><span class="comment"> * or issuing a &#123;<span class="doctag">@link</span> #storeFence&#125; before publishing the reference.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implnote</span> This method can only allocate primitive arrays, to avoid garbage reference</span></span><br><span class="line"><span class="comment"> * elements that could break heap integrity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> componentType array component type to allocate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length array size to allocate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if component type is null, or not a primitive class;</span></span><br><span class="line"><span class="comment"> *                                  or the length is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">allocateUninitializedArray</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Component type is null"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!componentType.isPrimitive()) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Component type is not primitive"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative length"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> allocateUninitializedArray0(componentType, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">allocateUninitializedArray0</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// These fallbacks provide zeroed arrays, but intrinsic is not required to</span></span><br><span class="line">   <span class="comment">// return the zeroed arrays.</span></span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">byte</span>.class)    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">boolean</span>.class) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">short</span>.class)   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">short</span>[length];</span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">char</span>.class)    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">int</span>.class)     <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">float</span>.class)   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">float</span>[length];</span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">long</span>.class)    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">long</span>[length];</span><br><span class="line">   <span class="keyword">if</span> (componentType == <span class="keyword">double</span>.class)  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[length];</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了这儿我也不太能理解为什么会绕弯选择这个优化[捂脸]，可能是期望一个性能优化的承诺？</p><p>就前面的理解可知，我们此时获取到的 buffer 通常是 <code>InstrumentedUnpooledUnsafeHeapByteBuf extends UnpooledUnsafeHeapByteBuf</code> /<code>InstrumentedUnpooledHeapByteBuf extends UnpooledHeapByteBuf</code>。而 <code>UnpooledUnsafeHeapByteBuf extends UnpooledHeapByteBuf</code>，所以接下来我们解析的顺序先从 <code>UnpooledHeapByteBuf</code> 开始，然后再看 <code>UnpooledUnsafeHeapByteBuf</code> 有什么不一样的地方.</p><h4 id="writeByte-逻辑"><a href="#writeByte-逻辑" class="headerlink" title="writeByte 逻辑"></a>writeByte 逻辑</h4><p>在 <code>AbstractByteBuf</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    ensureWritable(length); <span class="comment">// 这里就是自动调节长度的位置了</span></span><br><span class="line">    setBytes(writerIndex, src, srcIndex, length); <span class="comment">// 被 UnpooledHeapByteBuf 重载</span></span><br><span class="line">    writerIndex += length; <span class="comment">// 增加 writerIndex 索引值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ensureWriteable0</code> // 核心逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    ensureAccessible(); <span class="comment">// 明确是否可访问</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds) &#123; <span class="comment">// 用户 jvm 配置是否需要 check bound，默认为 true</span></span><br><span class="line">        <span class="keyword">if</span> (minWritableBytes &gt; maxCapacity - writerIndex) &#123; <span class="comment">// maxCapacity 前文提过默认 int 上限</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                    <span class="string">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span>,</span><br><span class="line">                    writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize the current capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>set minNewCapacity = writerIndex + minWritableBytes;</p></blockquote><p>calculateNewCapacity 增加的逻辑有点意思，它在预设值 <code>threshold = 4M</code> 的场景下 ，有这几种情况:</p><ol><li>minWritableBytes == threshold 则直接返回 threshold</li><li><p>minWritableBytes &gt; threshold 则  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold; <span class="comment">// threshold 倍数级增加（向下取整）</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123; <span class="comment">// 如果是最后一个 threshold 则将最大值空间分配返回</span></span><br><span class="line">        newCapacity = maxCapacity;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newCapacity += threshold; <span class="comment">// 否则增加一个 4M 即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后一种情况即 minWritableBytes 小于 threshold，此时  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = <span class="number">64</span>; <span class="comment">// 从 64 开始 double 直到大于 minNewCapacity</span></span><br><span class="line"><span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">    newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.min(newCapacity, maxCapacity); <span class="comment">// 如果 maxCapacity &lt; threshold 这儿就有用了</span></span><br></pre></td></tr></table></figure></li></ol><p>接下来我们看看被重载的 <code>setBytes</code> 方法（其实 <code>UnpooledHeapByteBuf</code> 与 <code>UnpooledUnsafeHeapByteBuf</code> 差异点也在这里）</p><p><code>UnpooledHeapByteBuf</code> 非常简单，copy 一把跑路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkSrcIndex(index, length, srcIndex, src.length);</span><br><span class="line">    System.arraycopy(src, srcIndex, array, index, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnpooledUnsafeHeapByteBuf</code> 的就需要稍微深入一下了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setByte</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    checkIndex(index);</span><br><span class="line">    _setByte(index, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">_setByte</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    UnsafeByteBufUtil.setByte(array, index, value);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 最后起作用的，此时 data 及是 array 即原 buffer 的存储数组，第二个参数是其插入值的 index，value 是需要插入的值</span></span><br><span class="line">UNSAFE.putByte(data, BYTE_ARRAY_BASE_OFFSET + index, value);</span><br></pre></td></tr></table></figure><h3 id="UnpooledByteBufAllocator-的-Direct-部分解析"><a href="#UnpooledByteBufAllocator-的-Direct-部分解析" class="headerlink" title="UnpooledByteBufAllocator 的 Direct 部分解析"></a>UnpooledByteBufAllocator 的 Direct 部分解析</h3><p>我们经过上面的铺垫，通过 <code>directBuffer()</code> 方法可以直接追踪到 <code>UnpooledByteBufAllocator.newDirectBuffer()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此之前我们需要回忆一下 noCleaner 与 disableLeakDetector 两个参数</p><blockquote><p>disableLeakDetector 设置为 true 则表示该 allocator 将关闭 leak-detection. 这个用处在于用户仅想依靠 gc 来管理 direct buffer 而不希望显式释放内存。 </p><p>tryNoCleaner 设置为 true 则表示我们将尝试去使用 PlatformDependent.allocateDirectNoCleaner(int) 去分配 direct buffer（如果其他条件允许）</p><p>noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe() &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();</p></blockquote><p>看来接下来需要介绍</p><ol><li>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf、InstrumentedUnpooledUnsafeDirectByteBuf、 InstrumentedUnpooledDirectByteBuf 之间的异同</li><li>toLeakAwareBuffer(buf) 的用途</li></ol><p>先说三个 ByteBuf。</p><p>这三个其实都只是添加了一些监控功能的类，具体还需要查看相对应的父类：UnpooledUnsafeNoCleanerDirectByteBuf, UnpooledUnsafeDirectByteBuf, UnpooledDirectByteBuf。其关系：</p><p><img src="evernotecid://030B6737-EB59-4FA5-B258-B85DAAD049D0/appyinxiangcom/7066058/ENResource/p7345" alt="6152fbef5328a4f62ec298ab588b5a86.png"></p><p>先说一下 UnpooledUnsafeNoCleanerDirectByteBuf, UnpooledUnsafeDirectByteBuf 两位的区别</p><p>NoCleaner 其实就是指 ByteBuffer 在 allocateDirect 时候会使用 <code>PlatformDependent.allocateDirectNoCleaner</code> 而 freeDirect 时候会使用 <code>PlatformDependent.freeDirectNoCleaner</code>。而后者则是使用 <code>ByteBuffer.allocateDirect</code> 与 <code>PlatformDependent.freeDirectBuffer</code></p><p>那就来看看这两对方法的两两比较即可</p><h4 id="Unsafe-的-allocateDirect-组比较"><a href="#Unsafe-的-allocateDirect-组比较" class="headerlink" title="Unsafe 的 allocateDirect 组比较"></a>Unsafe 的 <code>allocateDirect</code> 组比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirectNoCleaner</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> USE_DIRECT_BUFFER_NO_CLEANER;</span><br><span class="line"></span><br><span class="line">    incrementMemoryCounter(capacity); <span class="comment">// 内存使用记录增加 capacity</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PlatformDependent0.allocateDirectNoCleaner(capacity);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        decrementMemoryCounter(capacity); <span class="comment">// 若分配失败则内存使用记录减少对应的值</span></span><br><span class="line">        throwException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PlatformDependent0.allocateDirectNoCleaner</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">allocateDirectNoCleaner</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Calling malloc with capacity of 0 may return a null ptr or a memory address that can be used.</span></span><br><span class="line">    <span class="comment">// Just use 1 to make it safe to use in all cases:</span></span><br><span class="line">    <span class="comment">// See: http://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html</span></span><br><span class="line">    <span class="keyword">return</span> newDirectBuffer(UNSAFE.allocateMemory(Math.max(<span class="number">1</span>, capacity)), capacity); <span class="comment">// 先分配内存并获取内存地址，再调用 newDirectBuffer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkPositiveOrZero(capacity, <span class="string">"capacity"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ByteBuffer) DIRECT_BUFFER_CONSTRUCTOR.newInstance(address, capacity); <span class="comment">// 通过 DirectByteBuffer 暴露了 address 的构造器来创建 ByteBuffer</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">        <span class="comment">// Not expected to ever throw!</span></span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后者，直接创建了一个 DirectByteBuffer，借助 JDK 的 DirectByteBuffer 本身的垃圾回收进行内存管理（可参考<a href="">Netty 中的 ByteBuf — ByteBuffer 与 ByteBuf</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Unsafe-的-freeDirect-组比较"><a href="#Unsafe-的-freeDirect-组比较" class="headerlink" title="Unsafe 的 freeDirect 组比较"></a>Unsafe 的 <code>freeDirect</code> 组比较</h5><p><code>UnpooledUnsafeNoCleanerDirectByteBuf.freeDirect</code> 调用  <code>PlatformDependent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectNoCleaner</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> USE_DIRECT_BUFFER_NO_CLEANER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> capacity = buffer.capacity();</span><br><span class="line">    PlatformDependent0.freeMemory(PlatformDependent0.directBufferAddress(buffer)); <span class="comment">// 释放内存</span></span><br><span class="line">    decrementMemoryCounter(capacity); <span class="comment">// 降低记录总内存数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PlatformDependent0.directBufferAddress</code> 是获取其 buffer 的内存地址信息，这个信息获取逻辑是通过获取 <code>DirectByteBuffer</code> 的 address 字段信息，而这个字段是在 PlatformDependent0 初始化时通过反射获取的（其中验证 Buffer 是否是 DirecitByteBuffer 使用了 Unsafe 获取值来判断）。</p><p>当获取到了内存地址之后自然就可以通过 Unsafe.freeMemory(address) 来释放内存了。</p><p><code>UnpooledUnsafeDirectByteBuf.freeDirect</code> 调用 <code>PlatformDependent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLEANER 是一个针对 Java9+ 版本的类（<code>io.netty.util.internal.CleanerJava9</code>），Java9 为空操作。CleanerJava9 主要起用的是 <code>sun.misc.Unsafe.invokeCleaner</code>. 此方法即是调用 <code>DirectByteBuffer</code> 的 Cleaner，这是一个利用 PhantomReference 来管理内存的手段。</p><p><code>UnpooledDirectByteBuf</code> 就相对来说毕竟简单，<code>allocate</code> 还是直接调用 JDK 的 <code>DirectByteBuffer</code> 相关 API，<code>free</code> 还是同样是使用 <code>Cleaner</code></p><h3 id="toLeakAwareBuffer"><a href="#toLeakAwareBuffer" class="headerlink" title="toLeakAwareBuffer"></a><code>toLeakAwareBuffer</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ByteBuf <span class="title">toLeakAwareBuffer</span><span class="params">(ByteBuf buf)</span> </span>&#123;</span><br><span class="line">    ResourceLeakTracker&lt;ByteBuf&gt; leak;</span><br><span class="line">    <span class="keyword">switch</span> (ResourceLeakDetector.getLevel()) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIMPLE:</span><br><span class="line">            leak = AbstractByteBuf.leakDetector.track(buf);</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buf = <span class="keyword">new</span> SimpleLeakAwareByteBuf(buf, leak);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADVANCED:</span><br><span class="line">        <span class="keyword">case</span> PARANOID:</span><br><span class="line">            leak = AbstractByteBuf.leakDetector.track(buf);</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buf = <span class="keyword">new</span> AdvancedLeakAwareByteBuf(buf, leak);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到 Netty 的一个内存泄露监控措施。</p><h4 id="ResourceLeakDetector-介绍"><a href="#ResourceLeakDetector-介绍" class="headerlink" title="ResourceLeakDetector 介绍"></a>ResourceLeakDetector 介绍</h4><p>主要参考文章: <a href="https://ylgrgyq.github.io/2017/11/11/netty-resource-leack-detector/" target="_blank" rel="noopener">Netty 的资源泄露探测机制</a></p><ol><li>ResourceLeakDetector 能对占用资源的对象进行监控，如果对象被 GC 之前没有主动释放资源，则 ResourceLeakDetector 会发现这个泄露，并记录日志</li><li>ResourceLeakDetector 主要用于 ByteBuf（Heap And Direct） 的记录，若未调用 release 时候可以通过日志告知出现泄漏。</li></ol><p>Level 说明:</p><ul><li>SIMPLE: 默认级别，简单抽样，仅报告是否存在泄漏  </li><li>PARANOID: 所有均采样，报告对象最后一次访问的地址，消耗极高，只测试使用  </li><li>ADVANCED: 抽样，报告对象最后一次访问的地址，消耗较高</li><li>DISABLED: 关闭</li></ul><p>ResourceLeakDetector 准备流程即 <code>AbstractByteBuf.leakDetector.track()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;ByteBuf&gt; leakDetector =</span><br><span class="line">        ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);</span><br></pre></td></tr></table></figure><p>实际调用 <code>DefaultResourceLeakDetectorFactory.newResourceLeakDetector</code> 方法（非 deprecation），传入时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResourceLeakDetector&lt;T&gt; <span class="title">newResourceLeakDetector</span><span class="params">(Class&lt;T&gt; resource, <span class="keyword">int</span> samplingInterval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (customClassConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ResourceLeakDetector&lt;T&gt; leakDetector =</span><br><span class="line">                    (ResourceLeakDetector&lt;T&gt;) customClassConstructor.newInstance(resource, samplingInterval);</span><br><span class="line">            logger.debug(<span class="string">"Loaded custom ResourceLeakDetector: &#123;&#125;"</span>,</span><br><span class="line">                    customClassConstructor.getDeclaringClass().getName());</span><br><span class="line">            <span class="keyword">return</span> leakDetector;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(</span><br><span class="line">                    <span class="string">"Could not load custom resource leak detector provided: &#123;&#125; with the given resource: &#123;&#125;"</span>,</span><br><span class="line">                    customClassConstructor.getDeclaringClass().getName(), resource, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResourceLeakDetector&lt;T&gt; resourceLeakDetector = <span class="keyword">new</span> ResourceLeakDetector&lt;T&gt;(resource, samplingInterval);</span><br><span class="line">    logger.debug(<span class="string">"Loaded default ResourceLeakDetector: &#123;&#125;"</span>, resourceLeakDetector);</span><br><span class="line">    <span class="keyword">return</span> resourceLeakDetector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>check 是否有通过 <code>io.netty.customResourceLeakDetector</code> 引入的自定义 ResourceLeakDetector，若有则创建该类型的 ResourceLeakDetector</li><li>samplingInterval 指代采样间隔时间，默认 128 millsSecends，可通过 <code>io.netty.leakDetection.samplingInterval</code> 设置</li></ol><h5 id="track"><a href="#track" class="headerlink" title="track()"></a><code>track()</code></h5><p>创建 <code>ResourceLeakTracker</code>，该类将会在 Resource 被 deallocate 后自动调用 close() 方法，从其创建方法中我们能看出 PARANOID 模式与其他的区别</p><p>部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (level.ordinal() &lt; Level.PARANOID.ordinal()) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((PlatformDependent.threadLocalRandom().nextInt(samplingInterval)) == <span class="number">0</span>) &#123; <span class="comment">// 使用间隔抽样</span></span><br><span class="line">        reportLeak();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultResourceLeak(obj, refQueue, allLeaks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">reportLeak();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultResourceLeak(obj, refQueue, allLeaks);</span><br></pre></td></tr></table></figure><p>这里抽样的逻辑是，随机值实现是 0 - samplingInterval 均态分布的，即获取到 0 的时候则为使用间隔是符合预期的（调用大量时）。</p><p>先说说 DefaultResourceLeak 的实现</p><p>DefaultResourceLeak 是继承的 WeakReference，其 ResourceLeakDetector 初始化时候会持有一个 ReferenceQueue(refQ)，初始化 DefaultResourceLeak 时会将其队列加入构造器，这样 refQ 就与该 DefaultResourceLeak 绑定，在对象被 <code>close()</code> 的时候执行 <code>WeakReference.clear</code> 让弱引用不因为 gc 的原因进入 ReferenceQueue。<strong>若是没有调用 <code>close()</code> 随着 gc 将其引用的对象回收，其 WeakReference 也会被回收，其 ref 将会进入 refQ</strong>，此时队列中存在的就是未调用 <code>close()</code> 的 Resource 了。</p><p>接下来我们看看 <code>reportLeak()</code> 干了啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!logger.isErrorEnabled()) &#123; <span class="comment">// 若没有答应日志开口，就清理队列即可</span></span><br><span class="line">        clearRefQueue();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect and report previous leaks.</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        DefaultResourceLeak ref = (DefaultResourceLeak) refQueue.poll(); <span class="comment">// 获取每一个被 clear 的 DefaultResourceLeak</span></span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123; <span class="comment">// 队列中没有对象，完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ref.dispose()) &#123; <span class="comment">// 返回值表示已被处理，应该是个 double check</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String records = ref.toString();</span><br><span class="line">        <span class="keyword">if</span> (reportedLeaks.putIfAbsent(records, Boolean.TRUE) == <span class="keyword">null</span>) &#123; <span class="comment">// 打印记录的信息</span></span><br><span class="line">            <span class="keyword">if</span> (records.isEmpty()) &#123; <span class="comment">// 有无详情</span></span><br><span class="line">                reportUntracedLeak(resourceType);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reportTracedLeak(resourceType, records);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看 <code>DefaultResourceLeak</code> 会知道它的信息是会由 <code>record</code> 方法记录生成，这里我们记住即可。</p><p>在回到 <code>AbstractByteBufAllocator.toLeakAwareBuffer</code> （我们的起点）。这里会创建 SimpleLeakAwareByteBuf 或者 AdvancedLeakAwareByteBuf，其在构建起中会关联上面创建的 DefaultResourceLeak，而其中的 <code>release()</code> 方法将会调用 <code>ResourceLeak.close()</code> 方法来执行上面所说的逻辑，其中 AdvancedLeakAwareByteBuf 几乎对每一个 ByteBuf 的读写操作都进行了 <code>DefaultResourceLeak.record()</code> 的调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;UnpooledByteBufAllocator 的 Heap 与 Direct 的实现&lt;/li&gt;
&lt;li&gt;Heap 内部实现使用了 byte[]&lt;/li&gt;
&lt;li&gt;Direct 内部依托于 &lt;code&gt;PlatformDependent0&lt;/code&gt; 的各种 native 方法&lt;/li&gt;
&lt;li&gt;toLeakAwareBuffer 部分主要讨论了 Netty 是如何应对内存泄露，以及检测内存泄露跟踪的四个级别是如何实现的&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
      <category term="Netty源码分析系列" scheme="http://yoursite.com/tags/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>ByteBuffer 源码剖析</title>
    <link href="http://yoursite.com/2018/11/12/ByteBuffer-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2018/11/12/ByteBuffer-源码剖析/</id>
    <published>2018-11-12T09:11:18.000Z</published>
    <updated>2019-01-12T09:50:57.997Z</updated>
    
    <content type="html"><![CDATA[<p>要点:</p><ol><li>JDK 原生支持，主要用于 NIO</li><li>包含两个实现<ol><li>HeapByteBuffer: 基于 Java 堆实现</li><li>DirectByteBuffer: 使用 unsafe 的 API 进行堆外操作</li></ol></li><li>核心方法为 <code>put(byte)</code> 与 <code>get()</code>。分别是往ByteBuffer里写一个字节，和读一个字节。</li><li>读写模式分离，正常的应用场景是：往ByteBuffer里写一些数据，然后 <code>flip()</code>，然后再读出来。</li><li>在 JDK11 中 MappedByteBuffer 的创建实际是 DirectByteBuffer</li><li>DirectByteBuffer 的垃圾回收利用了幻象引用进行回收，详见下面的 <code>Cleaner</code></li></ol><a id="more"></a><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">    System.out.printf(<span class="string">"before pos/cap/limit: %d, %d, %d\n"</span>, buffer.position(), buffer.capacity(), buffer.limit());</span><br><span class="line">    <span class="comment">// before pos/cap/limit: 0, 8, 8</span></span><br><span class="line"></span><br><span class="line">    buffer.putShort((<span class="keyword">short</span>)<span class="number">20</span>);</span><br><span class="line">    buffer.put(<span class="string">"test"</span>.getBytes());</span><br><span class="line">    System.out.printf(<span class="string">"write pos/cap/limit: %d, %d, %d\n"</span>, buffer.position(), buffer.capacity(), buffer.limit());</span><br><span class="line">    <span class="comment">// write pos/cap/limit: 6, 8, 8</span></span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.printf(<span class="string">"flip pos/cap/limit: %d, %d, %d\n"</span>, buffer.position(), buffer.capacity(), buffer.limit());</span><br><span class="line">    <span class="comment">// flip pos/cap/limit: 0, 8, 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> num = buffer.getShort();</span><br><span class="line">    System.out.printf(<span class="string">"get short pos/cap/limit: %d, %d, %d\n"</span>, buffer.position(), buffer.capacity(), buffer.limit());</span><br><span class="line">    <span class="comment">// get short pos/cap/limit: 2, 8, 6</span></span><br><span class="line">    <span class="keyword">byte</span>[] strArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">    buffer.get(strArr, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.printf(<span class="string">"get array pos/cap/limit: %d, %d, %d\n"</span>, buffer.position(), buffer.capacity(), buffer.limit());</span><br><span class="line">    <span class="comment">// get array pos/cap/limit: 6, 8, 6</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num: "</span> + num + <span class="string">" str: "</span> + <span class="keyword">new</span> String(strArr));</span><br><span class="line">    <span class="comment">// num: 20 str: test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主要工作原理"><a href="#主要工作原理" class="headerlink" title="主要工作原理"></a>主要工作原理</h3><p><strong>内部字段</strong></p><ul><li><code>byte[] hb</code>: 缓存数组</li><li><code>position</code>: 当前操作位置</li><li><code>capacity</code>: 初始化 Buffer 容量</li><li><code>limit</code>: 读写的上限，limit &lt;= capacity</li><li><code>mark</code>: 为某一读过的位置做标记，便于某些时候回退到该位置。</li></ul><p>主要操作即操作这几个字段用于协同</p><ol><li><code>put/get</code> 将会增加 <code>position</code>，其操作也是从 <code>position</code> 开始</li><li><code>put</code> 将会增加 <code>limit</code>，检测 <code>capacity</code></li><li><code>get</code> 将会检测 <code>limit</code></li><li><code>filp</code> 将会复位 <code>position</code> 一般用于读写转换</li></ol><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="HeapByteBuffer-解析"><a href="#HeapByteBuffer-解析" class="headerlink" title="HeapByteBuffer 解析"></a>HeapByteBuffer 解析</h4><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>就 ByteBuffer 来看，<code>HeapByteBuffer</code> 中初始化链条<strong>第一环</strong>是 Buffer 的构造器，代码过于简单不进行说明，总体来说是初始化了 <code>capacity、limit、position、mark</code>。<br>这里大家会疑惑 <code>capacity</code> 可能通过 <code>allocate</code> 传递了，但其他的从哪儿来？  </p><ol><li>limit = capacity</li><li>mark = -1 会在构造器中直接置为 0 </li><li>position = 0</li></ol><p><strong>第二环:</strong> ByteBuffer 的构造器会将 byte[] 初始化并设置 capacity，同时设置 offset = 0.</p><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>核心函数：</p><ul><li><code>public ByteBuffer put(byte[] src, int offset, int length)</code>  </li><li><code>public final Buffer position(int newPosition)</code>  </li></ul><p>要点:</p><ol><li><code>checkBounds</code> 是个有趣的函数，若其中（offset、length、src.length）任一一个值为负数则结果即超出，若 <code>(size - (off + len))</code> 为负则结果也为异常。其实现使用了 <code>|</code></li><li>position 将会重新设置位置，这里面，若 mark 的值大于 postition 了 mark 会重置为 -1</li><li>若对比 <code>ByteBuffer</code> 父类与 <code>HeapByteBuffer</code> 的实现来看会发现，<code>ByteBuffer</code> 使用 <code>put(byte)</code> 逐个工作而后者则借助了 <code>System.arrayCopy</code></li></ol><p>既然都看到这儿了，那我们就了解一下 <code>System.arrayCopy</code>，native 源码翻起来</p><p>该代码位于 <code>src/share/native/lang/System.c</code> 中，主要通过 <code>Java_java_lang_System_registerNatives</code> 注册，其真实实现在 <code>src/share/vm/prims/jvm.cpp</code></p><p>说实话，得补一下 C艹…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,</span><br><span class="line">                               jobject dst, jint dst_pos, jint length))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_ArrayCopy"</span>);</span><br><span class="line">  <span class="comment">// Check if we have null pointers</span></span><br><span class="line">  <span class="keyword">if</span> (src == <span class="literal">NULL</span> || dst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_NullPointerException());</span><br><span class="line">  &#125;</span><br><span class="line">  arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));</span><br><span class="line">  arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));</span><br><span class="line">  assert(s-&gt;is_oop(), <span class="string">"JVM_ArrayCopy: src not an oop"</span>);</span><br><span class="line">  assert(d-&gt;is_oop(), <span class="string">"JVM_ArrayCopy: dst not an oop"</span>);</span><br><span class="line">  <span class="comment">// Do copy</span></span><br><span class="line">  s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><p>可以看出，主要逻辑肯定是 <code>copy_array</code> 中（这里可能涉及到 <code>TypeArrayKlass（基础类型）/ObjArrayKlass</code>，我们看前者）</p><p>核心逻辑：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// This is an attempt to make the copy_array fast.</span></span><br><span class="line"><span class="keyword">int</span> l2es = log2_element_size();</span><br><span class="line"><span class="keyword">int</span> ihs = array_header_in_bytes() / wordSize;</span><br><span class="line"><span class="keyword">char</span>* src = (<span class="keyword">char</span>*) ((oop*)s + ihs) + ((<span class="keyword">size_t</span>)src_pos &lt;&lt; l2es);</span><br><span class="line"><span class="keyword">char</span>* dst = (<span class="keyword">char</span>*) ((oop*)d + ihs) + ((<span class="keyword">size_t</span>)dst_pos &lt;&lt; l2es);</span><br><span class="line">Copy::conjoint_memory_atomic(src, dst, (<span class="keyword">size_t</span>)length &lt;&lt; l2es);</span><br></pre></td></tr></table></figure></p><p>最后会发现调用了平台相关的 <code>pd_conjoint_bytes</code>，看了看 linux 下面的实现居然都直接汇编了，卧槽… 追到这儿暂停吧，真看不懂了[捂脸]</p><p>但到现在也差不多已知猜测是通过操作整块内存一起使用指针串联提高执行速度的。</p><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>get 流程与 put 几乎一致。即空数组作为 arrayCopy 的 dst，然后将 dst 作为结果返回。</p><h4 id="MappedByteBuffer-解析"><a href="#MappedByteBuffer-解析" class="headerlink" title="MappedByteBuffer 解析"></a>MappedByteBuffer 解析</h4><p>由于 DirectByteBuffer 继承了 MappedByteBuffer 且个人对其机制比较感兴趣，所以先介绍一下 MappedByteBuffer。这儿有一篇文章可以参考一下: <a href="https://www.jianshu.com/p/f90866dcbffc" target="_blank" rel="noopener">深入浅出MappedByteBuffer</a>。文章要点:</p><ol><li>MappedByteBuffer 继承自 ByteBuffer，内部维护了一个逻辑地址 address。</li><li>除了正常 READ/WRITE 还支持 copy_on_write（MapMode.PRIVATE）</li><li>解析了 MappedByteBuffer 的创建过程</li></ol><p>文中所包含的代码可以在 <a href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java" target="_blank" rel="noopener">FileChannelImpl.java</a> 查看</p><p>创建主要核心代码 <code>Utils.newMappedByteBuffer</code> 主要是创建了一个 <code>DirectByteBuffer</code> （失望了吧？）</p><h4 id="DirectByteBuffer-解析"><a href="#DirectByteBuffer-解析" class="headerlink" title="DirectByteBuffer 解析"></a>DirectByteBuffer 解析</h4><p>即堆外内存。关于介绍这里有篇文章可以参考一下 <a href="http://www.importnew.com/26334.html" target="_blank" rel="noopener">堆外内存之 DirectByteBuffer 详解</a>。文章要点:</p><ol><li>DirectByteBuffer 该类本身还是位于Java内存模型的堆中。堆内内存是 JVM 可以直接管控、操纵。而 DirectByteBuffer 中的 <code>unsafe.allocateMemory(size);</code> 是个一个 native 方法，这个方法分配的是堆外内存，通过 C 的 malloc 来进行分配的。分配的内存是系统本地的内存，并不在 Java 的内存中，也不属于 JVM 管控范围。</li><li>DirectByteBuffer 中的 <code>address</code> 表示分配的堆外内存地址。</li><li>利用 PhantomReference 跟踪垃圾回收过程</li><li>最后介绍了一些 DirectByteBuffer 使用的要点</li></ol><p>还有笨神的文章<a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/" target="_blank" rel="noopener">JVM源码分析之堆外内存完全解读</a>。文章要点:</p><ol><li>区分广义堆外内存（jvm 本身在运行过程中分配的内存，codecache，jni 里分配的内存，DirectByteBuffer 分配的内存等等），狭义堆外内存（DirectByteBuffer）</li><li><code>Bits.reserveMemory</code> 用以分配内存</li><li>默认堆外内存实际是在 java.lang.System 初始化时候通过 native 方法 <code>Runtime.getRuntime().maxMemory()</code> 设置的（若不设置 <code>-Dsun.nio.MaxDirectMemorySize</code>）。</li><li><code>Bits.reserveMemory</code> 过程中主动触发了一次 <code>System.gc()</code> 。堆外内存不会对 gc 造成什么影响(这里的 System.gc 除外)，但是堆外内存的回收其实依赖于我们的 gc 机制，gc 能通过操作 DirectByteBuffer 对象来间接操作对应的堆外内存了。</li><li>DirectByteBuffer 对象在创建的时候关联了一个 PhantomReference，其主要是用来跟踪对象何时被回收的，它不能影响 gc 决策，但是 gc 过程中如果发现某个对象除了只有 PhantomReference 引用它之外，并没有其他的地方引用它了，那将会把这个引用放到 java.lang.ref.Reference.pending 队列里，在 gc 完毕的时候通知 ReferenceHandler 这个守护线程去执行一些后置处理，而 DirectByteBuffer 关联的 PhantomReference 是 PhantomReference 的一个子类，在最终的处理里会通过 Unsafe 的 free 接口来释放 DirectByteBuffer 对应的堆外内存块。</li><li>在通信阶段存在于 Heap 的内存最后都要 copy 一份到堆外，这样直接使用堆外更好</li><li>堆外内存不会对 gc 造成影响，同时也不受 gc 影响</li><li>对于需要频繁操作的内存，并且仅仅是临时存在一会的，都建议使用堆外内存，并且做成缓冲池，不断循环利用这块内存。</li><li>堆外内存的回收不是被直接控制的，当然你可以通过别的一些途径，比如反射，直接使用 Unsafe 接口等，但是这些务必给你带来了一些烦恼。如果大面积使用迟早会发生内存泄露。</li></ol><p>两篇文章都讲得足够好了，就不赘述了。</p><h5 id="Cleaner-详解"><a href="#Cleaner-详解" class="headerlink" title="Cleaner 详解"></a>Cleaner 详解</h5><p>先简单介绍一下 PhantomReference，所谓幻象引用。</p><ol><li>不能通过该引用去访问对象</li><li>提供一种确保对象被 <code>finalize</code> 后做某些事的机制</li><li>一般使用幻想应用模式：<ol><li>指定一个 ReferenceQueue 作为引用队列</li><li>当 finalize(非空实现)被触发时，JVM 会将对象推入引用队列中</li></ol></li></ol><p><strong>PhantomReference Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue rq = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object t = <span class="keyword">new</span> Object();</span><br><span class="line">        PhantomReference pr = <span class="keyword">new</span> PhantomReference(t, rq);</span><br><span class="line">        t = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"finalize: "</span> + (rq.remove(<span class="number">1000</span>) != <span class="keyword">null</span>)); <span class="comment">// finalize: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个符合预期，但是若对象实现了 <code>finalizer</code> 就比较有意思了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue rq = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        TestDemo t = <span class="keyword">new</span> TestDemo();</span><br><span class="line">        PhantomReference pr = <span class="keyword">new</span> PhantomReference(t, rq);</span><br><span class="line">        t = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"finalize: "</span> + (rq.remove(<span class="number">1000</span>) != <span class="keyword">null</span>)); <span class="comment">// finalize: false</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"finalize: "</span> + (rq.remove(<span class="number">1000</span>) != <span class="keyword">null</span>)); <span class="comment">// finalize: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下引用以下 《深入理解 Java 虚拟机》 书中内容</p><blockquote><p>即使在可达性分析算法中不可达的对象，也并非是『非死不可』的，这时候它们暂时处于『缓刑』阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法。<strong>当对象没有覆盖 <code>finalizer()</code> 方法，或者 <code>finalizer()</code> 方法已经被虚拟机调用过，虚拟机将这两种情况都视为『没有必要执行』。</strong></p></blockquote><p>即上述之所以需要第二次 gc 才能触发引用队列的原因是对象在第一次时并未真正的死亡。</p><p>接下来是 Cleaner 的源码，其核心即是 <code>public class Cleaner extends PhantomReference&lt;Object&gt;</code></p><p>其中 <code>clean()</code> 方法是核心清理代码，这里是在 <code>java.lang.ref.Reference</code> 初始化时创建了一个 <code>ReferenceHandler</code> 的守护线程进行调用。</p><p>而其调用的清理任务是来自于 DirectByteBuffer 的 Deallocator Runnable。主要记录了 <code>address</code> 内存地址信息，以及内存容量信息，然后使用 <code>unsafe.freeMemory(address)</code> 释放该内存地址，最后再调用 <code>Bits.unreserveMemory</code> 来清理内存计数。 </p><p>关于 Cleaner 与 finalizer 最新的还有下面这些可以参考:</p><p><a href="https://bugs.openjdk.java.net/browse/JDK-8165641" target="_blank" rel="noopener">Deprecate Object.finalize</a><br><a href="https://bugs.openjdk.java.net/browse/JDK-8138696" target="_blank" rel="noopener">java.lang.ref.Cleaner - an alternative to finalization</a><br><a href="http://mail.openjdk.java.net/pipermail/core-libs-dev/2017-March/046650.html" target="_blank" rel="noopener">RFR 9: 8165641 : Deprecate Object.finalize</a></p><h3 id="ByteBuffer-与-ByteBuf"><a href="#ByteBuffer-与-ByteBuf" class="headerlink" title="ByteBuffer 与 ByteBuf"></a>ByteBuffer 与 ByteBuf</h3><p>Netty 中的 ByteBuf 是由于 ByteBuffer 在使用上的困难，以及一些在网络 IO 上的常用操作的缺失决定了其存在性。</p><p>其特性参考 <a href="https://netty.io/4.1/api/index.html" target="_blank" rel="noopener">官方 API</a></p><ol><li>可自定义 buffer type</li><li>composite buffer type 可以实现零拷贝</li><li>动态长度 Buffer type</li><li>不需要调用 filp() 在读写模式下转换</li><li>通常比 ByteBuffer 快</li></ol><p>接下来的文章，我们将深入 ByteBuf 源码进行分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JDK 原生支持，主要用于 NIO&lt;/li&gt;
&lt;li&gt;包含两个实现&lt;ol&gt;
&lt;li&gt;HeapByteBuffer: 基于 Java 堆实现&lt;/li&gt;
&lt;li&gt;DirectByteBuffer: 使用 unsafe 的 API 进行堆外操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;核心方法为 &lt;code&gt;put(byte)&lt;/code&gt; 与 &lt;code&gt;get()&lt;/code&gt;。分别是往ByteBuffer里写一个字节，和读一个字节。&lt;/li&gt;
&lt;li&gt;读写模式分离，正常的应用场景是：往ByteBuffer里写一些数据，然后 &lt;code&gt;flip()&lt;/code&gt;，然后再读出来。&lt;/li&gt;
&lt;li&gt;在 JDK11 中 MappedByteBuffer 的创建实际是 DirectByteBuffer&lt;/li&gt;
&lt;li&gt;DirectByteBuffer 的垃圾回收利用了幻象引用进行回收，详见下面的 &lt;code&gt;Cleaner&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
      <category term="Netty源码剖析系列" scheme="http://yoursite.com/tags/Netty%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>关于 asyncio 的喃喃自语</title>
    <link href="http://yoursite.com/2018/01/30/%E5%85%B3%E4%BA%8E-asyncio-%E7%9A%84%E5%96%83%E5%96%83%E8%87%AA%E8%AF%AD/"/>
    <id>http://yoursite.com/2018/01/30/关于-asyncio-的喃喃自语/</id>
    <published>2018-01-29T16:22:04.000Z</published>
    <updated>2018-01-29T16:48:33.784Z</updated>
    
    <content type="html"><![CDATA[<p>大多数东西都是根据之前学习中的印象而来，这篇文章更多的是喃喃自语吧。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>在 Python 3.5 之前，协程在我眼中应该就是 <code>yield</code> 这个语法的同义，通过 <code>send</code>、<code>throw</code> 等方法来作为其交互，用于多进程中以提升效率，然而就 Python 的使用环境来说，其实接触到的机会并不是太多。</p><p>在 Python 3.5 之后，给了一种新的，现在看起来还是比较友好的选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello world!"</span>)</span><br><span class="line">    <span class="comment"># asyncio.sleep 也是一个 coroutine</span></span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    <span class="comment"># 线程也可以从这儿拿到返回值（asyncio.sleep(1) 返回值为 None）</span></span><br><span class="line">    r = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"Hello again!"</span>)</span><br></pre></td></tr></table></figure><p>在 <code>I/O</code> 密集的地方，填入 <code>await</code> ，在 <code>def</code> 前面加上 <code>async</code>，不需要去适应至今让我还是十分不适的 <code>yield</code> / <code>yield from</code> </p><a id="more"></a><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>最初接触到这个概念应该是 <code>epoll</code> 中，然后是在 <code>Tornado</code> 的源码中，当然，<code>Tornado</code> 也是用了 <code>epoll</code>。</p><p>在 <code>EventLoop</code> 的世界中，它总是与 <code>thread</code> 共存，它只是负责接收事件，余下的由 <code>thread</code> 来解决，保证了并发，在最近阅读的 <code>Kafka</code> 源码中它看起来也是这么干的，不过它可能比起 <code>Tornado</code> 做得更加彻底，<code>Tornado</code> 整个应用只会保持一个 <code>EventLoop</code>，而 <code>Kafka</code> 为了保证高吞吐高并发，除了 <code>Accept</code> 之外，拥有多个类型注册器，又对应了不同类型的线程池，基本的读和写都不成问题了。</p><p>说道这里，才开始说了 <code>asyncio</code> 中的 <code>EventLoop</code>。如果你只是运行 demo 的话，你会发现获取 <code>event_loop</code> 的方法非常简单 <code>asyncio.get_event_loop()</code>，但这只是在主线程中，如果你在其他线程中再看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p>获得的却是一个 <code>RuntimeError</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: There is no current event loop in thread &apos;LoopThread&apos;.</span><br></pre></td></tr></table></figure><p>需要的是这么做</p><ol><li><code>loop = asyncio.new_evet_loop()</code></li><li><code>asyncio.set_event_loop(loop)</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    new_loop = asyncio.new_event_loop()</span><br><span class="line">    asyncio.set_event_loop(new_loop)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p>其实是有种，多此一举的感觉。</p><p>那，<code>event_loop</code> 有什么用呢？</p><ul><li>它是 <code>asyncio</code> 的起点，是执行所有事件的起点</li><li>通过 <code>loop.run_forever()</code> + <code>loop.call_*</code> 实现对事件的调度，最后关闭的时候调用 <code>loop.close()</code></li><li>通过 <code>loop.add_reader()、loop.remove_reader()、loop.add_writer()、loop.remove_writer()</code> 来注册读写事件，其中有两个参数：文件描述符、<code>callback</code>，另外还有就是 <code>callback</code> 的参数，事件驱动嘛，多用于 socket。</li><li>通过使用 <code>run_in_executor</code> 来达到将耗时调用委托给线程池/进程池</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cpu_bound_operation</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"cpu bounding"</span>)</span><br><span class="line">    time.sleep(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 线程池 / 进程池执行</span></span><br><span class="line">    loop.run_in_executor(p, cpu_bound_operation, <span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"doing something thing"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    p = ProcessPoolExecutor(<span class="number">2</span>)</span><br><span class="line">    loop.run_until_complete(func())</span><br><span class="line">    loop.run_until_complete(func())</span><br><span class="line">    loop.run_until_complete(func())</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">doing something thing</span></span><br><span class="line"><span class="string">doing something thing</span></span><br><span class="line"><span class="string">doing something thing</span></span><br><span class="line"><span class="string">cpu bounding</span></span><br><span class="line"><span class="string">cpu bounding</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- sleep 5 seconds --</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cpu bounding</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="Future-与-Future"><a href="#Future-与-Future" class="headerlink" title="Future 与 Future"></a>Future 与 Future</h3><p>  真的，我第一次知道 <code>Future</code> 是在 Java 中，然后是在 <code>Tornado</code> 中，然后告诉我，<code>Python</code> 中还有两个（完全不兼容） <code>Future</code>，分别是 <code>asyncio.futures.Future</code>，<code>concurrent.futures.Future</code>，而且这两个都在 <code>asyncio</code> 中使用，真是感觉，这屎有毒。</p><blockquote><p> 例如，<code>asyncio.run_coroutine_threadsafe()</code> 将调度一个协程到在另一个线程中运行的事件循环，但它返回一个 <code>concurrent.futures.Future</code> 对象，而不是 <code>asyncio.futures.Future</code> 对象。 这是有道理的，因为只有 <code>concurrent.futures.Future</code> 对象是线程安全的。</p></blockquote><p>你如果在阅读文档的时候你会发现，<code>loop.run_until_complete</code> 里面给出的参数就是 <code>future</code>，这里的 <code>future</code> 指的是 <code>asyncio.futures.Future</code>，文档会告诉你 <code>If the argument is a coroutine object, it is wrapped by ensure_future().</code> （我真的完全不想知道 <code>coroutine object</code> diff <code>coroutine</code>），简单来说我们从 <code>ensure_future()</code> 入手知道它大概封装了一个协程，然后读源码的时候发现它给你返回的是一个 <code>task</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ensure_future</span><span class="params">(coro_or_future, *, loop=None)</span>:</span></span><br><span class="line">    <span class="string">"""Wrap a coroutine or an awaitable in a future.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the argument is a Future, it is returned directly.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> futures.isfuture(coro_or_future):</span><br><span class="line">        <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> loop <span class="keyword">is</span> <span class="keyword">not</span> coro_or_future._loop:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'loop argument must agree with Future'</span>)</span><br><span class="line">        <span class="keyword">return</span> coro_or_future</span><br><span class="line">    <span class="keyword">elif</span> coroutines.iscoroutine(coro_or_future):</span><br><span class="line">        <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            loop = events.get_event_loop()</span><br><span class="line">        task = loop.create_task(coro_or_future)</span><br><span class="line">        <span class="keyword">if</span> task._source_traceback:</span><br><span class="line">            <span class="keyword">del</span> task._source_traceback[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> task</span><br><span class="line">    <span class="keyword">elif</span> compat.PY35 <span class="keyword">and</span> inspect.isawaitable(coro_or_future):</span><br><span class="line">        <span class="keyword">return</span> ensure_future(_wrap_awaitable(coro_or_future), loop=loop)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'A Future, a coroutine or an awaitable is required'</span>)</span><br></pre></td></tr></table></figure><p>这时候你大概能知道 <code>run_until_complete</code> 执行的是一个 <code>task</code> （当然，你如果去看文档的会知道，它能执行一个 task 列表）。</p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>讲真，Python 3 的 <code>asyncio</code> 在我对比了 <code>epoll</code> 和 <code>Java</code> 的异步机制之后我觉得是将一件本来就不是对初学者很友好的机制再次复杂化，你需要很多新的东西，比如：<code>call</code>，协程，<code>eventLoop</code>，<code>task</code>，<code>future</code>，<code>executor</code> 等等，以及延展的 <code>yield</code>，<code>generator</code> 等等。</p><p>幸好，社区已经有很多人为我们封装了基础的框架，优秀如 <code>aiohttp</code> 等，希望以后这类理解成本越来越低吧。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://linux.cn/article-8051-1.html" target="_blank" rel="noopener">雾里看花之 Python Asyncio</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数东西都是根据之前学习中的印象而来，这篇文章更多的是喃喃自语吧。&lt;/p&gt;
&lt;h3 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h3&gt;&lt;p&gt;在 Python 3.5 之前，协程在我眼中应该就是 &lt;code&gt;yield&lt;/code&gt; 这个语法的同义，通过 &lt;code&gt;send&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt; 等方法来作为其交互，用于多进程中以提升效率，然而就 Python 的使用环境来说，其实接触到的机会并不是太多。&lt;/p&gt;
&lt;p&gt;在 Python 3.5 之后，给了一种新的，现在看起来还是比较友好的选择&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# asyncio.sleep 也是一个 coroutine&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 异步调用asyncio.sleep(1):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 线程也可以从这儿拿到返回值（asyncio.sleep(1) 返回值为 None）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; asyncio.sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;Hello again!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;I/O&lt;/code&gt; 密集的地方，填入 &lt;code&gt;await&lt;/code&gt; ，在 &lt;code&gt;def&lt;/code&gt; 前面加上 &lt;code&gt;async&lt;/code&gt;，不需要去适应至今让我还是十分不适的 &lt;code&gt;yield&lt;/code&gt; / &lt;code&gt;yield from&lt;/code&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="异步编程" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Kafka生产者分析——RecordAccumulator</title>
    <link href="http://yoursite.com/2017/12/24/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94RecordAccumulator/"/>
    <id>http://yoursite.com/2017/12/24/Kafka生产者分析——RecordAccumulator/</id>
    <published>2017-12-24T11:38:31.000Z</published>
    <updated>2017-12-24T11:39:42.246Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 紧接 <a href="https://binglau7.github.io/2017/12/18/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94KafkaProducer/" target="_blank" rel="noopener">Kafka生产者分析——KafkaProducer</a></p></blockquote><p>前文介绍过，KafkaProducer 可以有同步和异步两种方式发送消息，其实两者的底层实现相同，都是通过异步方式实现的。主线程调用 <code>KafkaProducer#send()</code> 方法发送消息的时候，先将消息放到 <code>RecordAccumulator</code> 中暂存，然后主线程就可以从 <code>send()</code> 方法中返回了，此时消息并没有真正地发送给 Kafka，而是缓存在了 <code>RecordAccumulator</code> 中。之后，业务线程<strong>通过 <code>KafkaProducer#send()</code> 方法不断向 <code>RecordAccumulator</code> 追加消息，当达到一定的条件，会唤醒 <code>Sender</code> 线程发送 <code>RecordAccumulator</code> 中的消息。</strong></p><p>下面我们就来介绍 <code>RecordAccumulator</code> 的结构。首先需要注意的是，<strong><code>RecordAccumulator</code> 至少有一个业务线程和一个 <code>Sender</code> 线程并发操作，所以必须是线程安全的</strong>。</p><a id="more"></a><p><code>RecordAccumulator</code> 中有一个以 <code>TopicPartition</code> 为 key 的 <code>ConcurrentMap</code> ，每个 value 是 <code>ArrayDeque&lt;RecordBatch&gt;</code> （<code>ArrayDeque</code> 并不是线程安全的集合，后面会详细介绍其加锁处理过程），其中缓存了发往对应 <code>TopicPartition</code> 的消息。每个 <code>RecordBatch</code> 拥有一个 <code>MemoryRecords</code> 对象的引用。<code>MemoryRecords</code> 才是消息最终存放的地方。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordAccumulator&amp;RecordBatch&amp;MemoryRecords.jpg?raw=true" alt="RecordAccumulator&amp;RecordBatch&amp;MemoryRecords"></p><h2 id="MemoryRecords"><a href="#MemoryRecords" class="headerlink" title="MemoryRecords"></a><code>MemoryRecords</code></h2><p>我们从最底层的 <code>MemoryRecords</code> 开始分析。<code>MemoryRecords</code> 表示的是多个消息的集合，其中封装了 Java NIO ByteBuffer 用来保存消息数据，<code>Compressor</code> 用于对 <code>ByteBuffer</code> 中的消息进行压缩，以及其他控制字段。其中有四个字段比较重要：</p><ul><li>buffer：用于保存消息数据的 Java NIO ByteBuffer</li><li>writeLimit：记录 buffer 字段最多可以写入多少个字节的数据</li><li>compressor：压缩器，对消息数据进行压缩，将压缩后的数据输出到 buffer。</li><li>writable：此 <code>MemoryRecords</code> 对象是只读的模式，还是可写模式。在 <code>MemoryRecords</code> 发送前，会将其设置成只读模式。</li></ul><p>在 Compressor 比较重要的字段和方法，有两个输出流类型的字段：</p><ul><li><p><code>bufferStream</code></p><p>在 buffer 上建立的 <code>ByteBufferOutputStream</code> (Kafka 自己提供的实现)对象，<code>ByteBufferOutputStream</code> 继承了 <code>java.io.OutputStream</code> ，封装了 <code>ByteBuffer</code>，当写入数据超过 <code>ByteBuffer</code> 容量时，<code>ByteBufferOutputStream</code> 会进行自动扩容。</p></li><li><p><code>appendStream</code></p><p><code>DataOutputStream</code> 类型，是对 <code>bufferStream</code> 进行了一层装饰，为其添加了压缩的功能。</p></li></ul><p><code>MemoryRecords</code> 中的 <code>Compressor</code> 的压缩类型是由 <code>compression.type</code> 配置参数指定的，即 <code>KafkaProducer.compressor.type</code> 字段的指。</p><p>下面来分析一下创建压缩流的方式，目前 <code>KafkaProducer</code> 支持 <code>GZIP、SNAPPY、LZ4</code> 三种压缩方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Compressor</span><span class="params">(ByteBuffer buffer, CompressionType type)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* 从 KafkaProducer 传递过来的压缩类型 */</span></span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// create the stream</span></span><br><span class="line">      bufferStream = <span class="keyword">new</span> ByteBufferOutputStream(buffer);</span><br><span class="line">      <span class="comment">/* 下面根据压缩类型创建合适的压缩流 */</span></span><br><span class="line">      appendStream = wrapForOutput(bufferStream, type, COMPRESSION_DEFAULT_BUFFER_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataOutputStream <span class="title">wrapForOutput</span><span class="params">(ByteBufferOutputStream buffer, CompressionType type, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">switch</span> (type) &#123;  <span class="comment">/* 根据不同的类型选择创建不同压缩流 */</span></span><br><span class="line">              <span class="keyword">case</span> NONE: <span class="comment">/* 不压缩的方式 */</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> DataOutputStream(buffer);</span><br><span class="line">              <span class="keyword">case</span> GZIP:</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> GZIPOutputStream(buffer, bufferSize) <span class="comment">/* 使用 JDK 自带的包 */</span>);</span><br><span class="line">              <span class="keyword">case</span> SNAPPY:</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">/* 使用额外引入的依赖包，为了在不使用 Snappy 压缩方式时，减少依赖包，使用反射的方式动态创建(如果不使用反射则会造成为多个压缩方式的第三方依赖做初始化工作的时间损耗) */</span></span><br><span class="line">                      OutputStream stream = (OutputStream) snappyOutputStreamSupplier.get().newInstance(buffer, bufferSize);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">new</span> DataOutputStream(stream);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(e);</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="keyword">case</span> LZ4:</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      OutputStream stream = (OutputStream) lz4OutputStreamSupplier.get().newInstance(buffer);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">new</span> DataOutputStream(stream);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(e);</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown compression type: "</span> + type);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>Compressor</code> 提供了一系列 <code>put*()</code> 方法，向 <code>appendStream</code> 流写入数据，一个典型的装饰器模式的运用，通过 <code>bufferStream</code>  装饰，添加自动扩容的功能；通过 <code>appendStream</code> 装饰后，添加压缩功能。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_43/Compressor-putXXX.png?raw=true" alt="Compressor装饰器模式"></p><p><code>Compressor.estimateBytesWritten()</code> 方法的功能是根据指定压缩方式的压缩率，写入的未压缩数据的字节数（<code>writtenUncompressed</code> 字段记录）、估算因子（COMPRESSION_RATE_ESTIMATION_FACTOR 字段），估计已写入的（压缩后的）字节数，次方法主要用来判断 <code>MemoryRecords</code> 是否写满的逻辑中使用。</p><p>下面分析过程暂且认为是使用的非压缩方式（None）。</p><p>了解了 <code>Compressor</code> 的实现逻辑后，我们回到 <code>MemoryRecords</code> 继续分析。<code>MemoryRecords</code> 的构造方法是私有的，只能通过 <code>emptyRecords()</code> 方法得到其对象。<code>MemoryRecords</code> 中有四个比较重要的方法。</p><ul><li><code>append()</code> 方法：先判断 <code>MomoryRecords</code> 是否为可写模式，然后调用 <code>Compressor.put*()</code> 方法，将消息数据写入 <code>ByteBuffer</code> 中。</li><li><code>hasRoomFor()</code> 方法：根据 <code>Compressor</code> 估计的已写字节数，估计 <code>MemoryRecords</code> 剩余空间是否足够写入指定的数据。注意，这里仅仅是估计，所以不一定准确，通过 <code>hasRoomFor()</code> 方法判断之后写入数据，也可能就会导致底层 <code>ByteBuffer</code> 出现扩容的情况。</li><li><code>close()</code> 方法：出现 <code>ByteBuffer</code> 扩容的情况时，<code>MemoryRecords.buffer</code> 字段与 <code>ByteBufferOutputStream.buffer</code> 字段所指向的不再是同一个 <code>ByteBuffer</code> 对象。在 <code>close()</code> 方法中，会将 <code>MemoryRecords.buffer</code> 字段指向扩容后的 <code>ByteBuffer</code> 对象。同时，将 <code>writbale</code> 设置为 <code>false</code> （即只读模式）</li><li><code>sizeInBytes()</code> 方法:对于可写的 <code>MemoryRecords</code> ，返回的是 <code>ByteBufferOutputStream.buffer</code> 字段的大小；对于只读 <code>MemoryRecords</code> ，返回的是 <code>MemoryRecords.buffer</code> 的大小。</li></ul><p><code>MemoryRecords</code> 还提供了迭代器，主要是用于在 <code>Consumer</code> 端读取其中的消息。</p><h2 id="RecordBatch"><a href="#RecordBatch" class="headerlink" title="RecordBatch"></a>RecordBatch</h2><p>在了解了 <code>MemoryRecords</code> 的具体实现之后，来分析 <code>RecordBatch</code> 类的实现。我们在前面所知，每个 <code>RecordBatch</code> 对象中封装了一个 <code>MemoryRecords</code> 对象，除此之外，还封装了很多控制信息和统计信息，接下来简单介绍一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录了保存的 Record 的个数 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> recordCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 最大 Record 的字节数 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxRecordSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 尝试发送当前 RecordBatch 的次数 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> attempts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> createdMs;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> drainedMs;</span><br><span class="line"><span class="comment">/* 最后一次尝试发送的时间戳 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> lastAttemptMs;</span><br><span class="line"><span class="comment">/* 指向用来存储数据的 MemoryRecords 对象 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> MemoryRecords records;</span><br><span class="line"><span class="comment">/* 当前 RecordBatch 中缓存的消息都会发送给此 TopicPartition */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TopicPartition topicPartition;</span><br><span class="line"><span class="comment">/* 标识 RecordBatch 状态的 Future 对象 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ProduceRequestResult produceFuture;</span><br><span class="line"><span class="comment">/* 最后一次向 RecordBatch 追加消息的时间戳 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> lastAppendTime;</span><br><span class="line"><span class="comment">/* Thunk 对象的集合 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thunk&gt; thunks;</span><br><span class="line"><span class="comment">/* 用来记录某消息在 RecordBatch 中的偏移量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> offsetCounter = <span class="number">0L</span>;</span><br><span class="line"><span class="comment">/* 是否正在重试。如果 RecordBatch 中的数据发送失败，则会重新尝试发送 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> retry;</span><br></pre></td></tr></table></figure><p>在下图中，以 <code>RecordBatch</code> 为中心，刻画了其相关类间的对应关系。</p><blockquote><p> 这里推荐一下 idea 的 <a href="http://plantuml.com/sitemap" target="_blank" rel="noopener">Plantuml</a> 这个插件</p></blockquote><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordBatch.png?raw=true" alt="RecordBatch"></p><p>下面我们来分析一下 <code>ProduceRequestResult</code> 这个类的功能。<code>ProduceRequestResult</code> 并未实现 <code>java.util.concurrent.Future</code> 接口，但是其通过包含一个 <code>count</code> 值为 1 的 <code>CountDownLatch</code> 对象，实现了类似于 <code>Future</code> 的功能。</p><p>当 <code>RecordBatch</code> 中全部的消息被正常响应、或超时、或关闭生产者时，会调用 <code>ProduceRequestResult.done()</code> 方法，将 <code>produceFuture</code> 标记为完成并通过 <code>ProduceRequestResult.error</code> 字段区分『异常完成』还是『正常完成』，之后调用 <code>CountDownLatch</code> 对象的 <code>countDown()</code> 方法。此时，会唤醒阻塞在 <code>CountDownLatch</code> 对象的 <code>await()</code> 方法的线程（这些线程通过 <code>ProduceRequestResult</code> 的 <code>await</code> 方法等待上述三个事件的发送）。</p><p>Kafka 的分区会为其中记录的消息分配一个 <code>offset</code> 并通过此 <code>offset</code> 维护消息顺序。在 <code>ProduceRequestResult</code> 中海油一个需要注意的字段 <code>baseOffset</code>，表示的是服务的为此 <code>RecordBatch</code> 中第一条消息分配的 <code>offset</code>，这样每个消息可以根据此 <code>offset</code> 以及自身在此 <code>RecordBatch</code> 中的相对偏移量，计算出其在服务端分区中的偏移量了。</p><p>在介绍 <code>Thunk</code> 类之前，先回顾一下 <code>KafkaProducer.send()</code> 方法的第二个参数，是一个 <code>Callback</code> 对象，它是针对单个消息的回调函数（每个消息对会有一个对应的 <code>Callback</code> 对象作为回调）。<code>RecordBatch.thunks</code> 字段可以理解为消息的回调对象队列，<code>Thunk</code> 中的 <code>callback</code> 字段就指向对应消息的 <code>Callback</code> 对象，其另一个字段 <code>future</code> 是 <code>FutureRecordMetadata</code> 类型。<code>FutureRecordMetadata</code> 类有两个关键字段。</p><ul><li><code>result</code>：<code>ProduceRequestResult</code> 类型，指向对应消息所在 <code>RecordBatch</code> 的 <code>produceFuture</code> 字段。</li><li><code>relativeOffset</code>：<code>long</code>类型，记录了对应消息在 <code>RecordBatch</code> 中的偏移量。</li></ul><p><code>FutureRecordMetadata</code> 实现了 <code>java.util.concurrent.Future</code> 接口，但其实现基本都是委托给了 <code>ProduceRequestResult</code> 对应的方法，由此可以看出，消息应该是按照 <code>RecordBatch</code> 进行发送和确认的。</p><p>当生产者已经收到某消息的响应时，<code>FutureRecordMetadata.get()</code> 方法就会返回 <code>RecordMetadata</code> 对象，其中包含消息在 <code>Partition</code> 中的 <code>offset</code> 等其他元数据，可供用户自定义 <code>Callback</code> 使用。</p><p>分析完 <code>RecordBatch</code> 依赖的组件，现在回来看看 <code>RecordBatch</code> 类的核心方法。<code>tryAppend()</code> 方法是最核心的方法，其功能是尝试将消息添加到当前的 <code>RecordBatch</code> 中缓存，代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FutureRecordMetadata <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Callback callback, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 估算剩余空间不足，前面说过，这不是一个准确值 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.records.hasRoomFor(key, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 向 MemoryRecords 中添加数据。注意，offsetCounter 是在 RecordBatch 中的偏移量 */</span></span><br><span class="line">        <span class="keyword">long</span> checksum = <span class="keyword">this</span>.records.append(offsetCounter++, timestamp, key, value);</span><br><span class="line">        <span class="comment">/*  更新统计信息 */</span></span><br><span class="line">        <span class="keyword">this</span>.maxRecordSize = Math.max(<span class="keyword">this</span>.maxRecordSize, Record.recordSize(key, value));</span><br><span class="line">        <span class="keyword">this</span>.lastAppendTime = now;</span><br><span class="line">        <span class="comment">/* 创建 FutureRecordMetadata 对象 */</span></span><br><span class="line">        FutureRecordMetadata future = <span class="keyword">new</span> FutureRecordMetadata(<span class="keyword">this</span>.produceFuture, <span class="keyword">this</span>.recordCount,</span><br><span class="line">                                                               timestamp, checksum,</span><br><span class="line">                                                               key == <span class="keyword">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                               value == <span class="keyword">null</span> ? -<span class="number">1</span> : value.length);</span><br><span class="line">        <span class="comment">/* 将用户自定义 CallBack 和 FutureRecordMetadata 封装成 Thunk，保存到 thunks 集合中 */</span></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>)</span><br><span class="line">            thunks.add(<span class="keyword">new</span> Thunk(callback, future));</span><br><span class="line">        <span class="keyword">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>RecordBatch</code> 成功收到正常响应、或超市、或关闭生成者时，都会调用 <code>RecordBatch</code> 的 <code>done()</code> 方法。在 <code>done()</code> 方法中，会回调 <code>RecordBatch</code> 中全部消息的  <code>Callback</code> 回调，并调用其 <code>produceFuture</code> 字段的 <code>done()</code> 方法。<code>RecordBatch.done()</code> 方法的调用关系如下：</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_43/RecordBatch-done.jpg?raw=true" alt="RecordBatch.done()调用链"></p><p>其代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(<span class="keyword">long</span> baseOffset, <span class="keyword">long</span> timestamp, RuntimeException exception)</span> </span>&#123;</span><br><span class="line">    log.trace(<span class="string">"Produced messages to topic-partition &#123;&#125; with base offset offset &#123;&#125; and error: &#123;&#125;."</span>,</span><br><span class="line">              topicPartition,</span><br><span class="line">              baseOffset,</span><br><span class="line">              exception);</span><br><span class="line">    <span class="comment">// execute callbacks</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.thunks.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thunk thunk = <span class="keyword">this</span>.thunks.get(i);</span><br><span class="line">            <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123; <span class="comment">/* 正常处理完成 */</span></span><br><span class="line">                <span class="comment">// If the timestamp returned by server is NoTimestamp, that means CreateTime is used. Otherwise LogAppendTime is used.</span></span><br><span class="line">                <span class="comment">/* 将服务端返回的信息（offset 和 timestamp）和消息的其他信息封装成 RecordMetadata */</span></span><br><span class="line">                RecordMetadata metadata = <span class="keyword">new</span> RecordMetadata(<span class="keyword">this</span>.topicPartition,  baseOffset, thunk.future.relativeOffset(),</span><br><span class="line">                                                             timestamp == Record.NO_TIMESTAMP ? thunk.future.timestamp() : timestamp,</span><br><span class="line">                                                             thunk.future.checksum(),</span><br><span class="line">                                                             thunk.future.serializedKeySize(),</span><br><span class="line">                                                             thunk.future.serializedValueSize());</span><br><span class="line">                <span class="comment">/* 调用详细对应的自定义 Callback */</span></span><br><span class="line">                thunk.callback.onCompletion(metadata, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 处理过程中出现异常，注意，第一个参数为 null，与上面情况刚好相反 */</span></span><br><span class="line">                thunk.callback.onCompletion(<span class="keyword">null</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error executing user-provided callback on message for topic-partition &#123;&#125;:"</span>, topicPartition, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 标识整个 RecordBatch 都已经处理完成 */</span></span><br><span class="line">    <span class="keyword">this</span>.produceFuture.done(topicPartition, baseOffset, exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BufferPool"><a href="#BufferPool" class="headerlink" title="BufferPool"></a>BufferPool</h2><p><code>ByteBuffer</code> 的创建和释放是比较消耗资源的，为了实现内存的高效利用，基本上每个成熟的框架或工具都有一套内存管理机制。Kafka 客户端使用 <code>BufferPool</code> 来实现 <code>ByteBuffer</code> 的复用。</p><p>首先需要了解的是，每个 <code>BufferPool</code> 对象只针对特定大小（由<code>poolableSize</code> 字段指定）的 <code>ByteBuffer</code> 进行管理，对于其他大小的 <code>ByteBuffer</code> 并不会缓存进 <code>BufferPool</code> 。一般情况，我们会调整 <code>MemoryRecords</code> 的大小（<code>RecordAccumulator.batchSize</code> 字段指定），使得每个 <code>MemoryRecords</code> 可以缓存多条消息。但也有例外情况，当一条消息的字节数大于 <code>MemoryRecords</code> 时，就不会复用<code>BufferPool</code> 中缓存的 <code>ByteBuffer</code> ，而是例外分配 <code>ByteBuffer</code>，在它被使用完后也不会放入 <code>BufferPool</code> 进行管理，而是直接丢弃由 GC 回收。</p><p>下面介绍一下 <code>BufferPoll</code> 的关键字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记录了整个 Pool 的大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> totalMemory;</span><br><span class="line"><span class="comment">/* 因为有多线程并发分配和回收 ByteBuffer，所以使用锁控制并发，保证线程安全 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">/* 是一个 ArrayDeque&lt;ByteBuffer&gt; 队列，其中缓存了指定大小的 ByteBuffer 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; free;</span><br><span class="line"><span class="comment">/* 记录因申请不到足够空间而阻塞的线程，此队列中实际记录的是阻塞线程对应的 Condition 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Condition&gt; waiters;</span><br><span class="line"><span class="comment">/* 记录了可用的空间大小，这个空间是 totalMemory - free 列表的 ByteBuffer 大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> availableMemory;</span><br></pre></td></tr></table></figure><p><code>BufferPool.allocate()</code> 方法负责从缓冲池中申请 <code>ByteBuffer</code> ，<strong>当缓冲池中空间不足时，就会阻塞调用线程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">long</span> maxTimeToBlockMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="keyword">this</span>.totalMemory)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Attempt to allocate "</span> + size</span><br><span class="line">                                           + <span class="string">" bytes, but there is a hard limit of "</span></span><br><span class="line">                                           + <span class="keyword">this</span>.totalMemory</span><br><span class="line">                                           + <span class="string">" on memory allocations."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lock.lock(); <span class="comment">/* 同步加锁 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check if we have a free buffer of the right size pooled</span></span><br><span class="line">        <span class="comment">/* 请求的是 poolableSize 指定大小的 ByteBuffer，且 free 中有空闲的 ByteBuffer */</span></span><br><span class="line">        <span class="keyword">if</span> (size == poolableSize &amp;&amp; !<span class="keyword">this</span>.free.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.free.pollFirst(); <span class="comment">/* 返回合适的 ByteBuffer */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 当申请的空间大小不是 poolableSize，则执行下面的操作 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// now check if the request is immediately satisfiable with the</span></span><br><span class="line">        <span class="comment">// memory on hand or if we need to block</span></span><br><span class="line">        <span class="comment">/* free 队列中都是 poolableSize 大小的 ByteBuffer，可以直接计算整个 free 队列的空间 */</span></span><br><span class="line">        <span class="keyword">int</span> freeListSize = <span class="keyword">this</span>.free.size() * <span class="keyword">this</span>.poolableSize;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.availableMemory + freeListSize &gt;= size) &#123;</span><br><span class="line">            <span class="comment">// we have enough unallocated or pooled memory to immediately</span></span><br><span class="line">            <span class="comment">// satisfy the request</span></span><br><span class="line">            <span class="comment">/* 为了让 availableMemory &gt; size，freeUp() 方法会从 free 队列中不断释放</span></span><br><span class="line"><span class="comment">             * ByteBuffer，直到 availableMemory 满足这次申请 */</span></span><br><span class="line">            freeUp(size);</span><br><span class="line">            <span class="keyword">this</span>.availableMemory -= size; <span class="comment">/* 减少 availableMemory */</span></span><br><span class="line">            lock.unlock(); <span class="comment">/* 解锁 */</span></span><br><span class="line">            <span class="comment">/* 这里没有用 free 队列中的 buffer，而是直接分配 size 大小的 HeapByteBuffer */</span></span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocate(size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 没有足够空间，只能阻塞了 */</span></span><br><span class="line">            <span class="comment">// we are out of memory and will have to block</span></span><br><span class="line">            <span class="keyword">int</span> accumulated = <span class="number">0</span>;</span><br><span class="line">            ByteBuffer buffer = <span class="keyword">null</span>;</span><br><span class="line">            Condition moreMemory = <span class="keyword">this</span>.lock.newCondition();</span><br><span class="line">            <span class="keyword">long</span> remainingTimeToBlockNs = TimeUnit.MILLISECONDS.toNanos(maxTimeToBlockMs);</span><br><span class="line">            <span class="comment">/* 将 Condition 添加到 waiters 中 */</span></span><br><span class="line">            <span class="keyword">this</span>.waiters.addLast(moreMemory);</span><br><span class="line">            <span class="comment">// loop over and over until we have a buffer or have reserved</span></span><br><span class="line">            <span class="comment">// enough memory to allocate one</span></span><br><span class="line">            <span class="keyword">while</span> (accumulated &lt; size) &#123; <span class="comment">/* 循环等待 */</span></span><br><span class="line">                <span class="keyword">long</span> startWaitNs = time.nanoseconds();</span><br><span class="line">                <span class="keyword">long</span> timeNs;</span><br><span class="line">                <span class="keyword">boolean</span> waitingTimeElapsed;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/* 阻塞 */</span></span><br><span class="line">                    waitingTimeElapsed = !moreMemory.await(remainingTimeToBlockNs, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">/* 异常，移除此线程对应的 Condition */</span></span><br><span class="line">                    <span class="keyword">this</span>.waiters.remove(moreMemory);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">/* 统计阻塞时间 */</span></span><br><span class="line">                    <span class="keyword">long</span> endWaitNs = time.nanoseconds();</span><br><span class="line">                    timeNs = Math.max(<span class="number">0L</span>, endWaitNs - startWaitNs);</span><br><span class="line">                    <span class="keyword">this</span>.waitTime.record(timeNs, time.milliseconds());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (waitingTimeElapsed) &#123; <span class="comment">/* 超时，报错 */</span></span><br><span class="line">                    <span class="keyword">this</span>.waiters.remove(moreMemory);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to allocate memory within the configured max blocking time "</span> + maxTimeToBlockMs + <span class="string">" ms."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                remainingTimeToBlockNs -= timeNs;</span><br><span class="line">                <span class="comment">// check if we can satisfy this request from the free list,</span></span><br><span class="line">                <span class="comment">// otherwise allocate memory</span></span><br><span class="line">                <span class="comment">/* 请求的是 poolableSize 大小的 ByteBuffer，且 free 中有空间的 ByteBuffer */</span></span><br><span class="line">                <span class="keyword">if</span> (accumulated == <span class="number">0</span> &amp;&amp; size == <span class="keyword">this</span>.poolableSize &amp;&amp; !<span class="keyword">this</span>.free.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// just grab a buffer from the free list</span></span><br><span class="line">                    buffer = <span class="keyword">this</span>.free.pollFirst();</span><br><span class="line">                    accumulated = size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 先分配一部分空间，并继续等待空闲空间 */</span></span><br><span class="line">                    <span class="comment">// we'll need to allocate memory, but we may only get</span></span><br><span class="line">                    <span class="comment">// part of what we need on this iteration</span></span><br><span class="line">                    freeUp(size - accumulated);</span><br><span class="line">                    <span class="keyword">int</span> got = (<span class="keyword">int</span>) Math.min(size - accumulated, <span class="keyword">this</span>.availableMemory);</span><br><span class="line">                    <span class="keyword">this</span>.availableMemory -= got;</span><br><span class="line">                    accumulated += got;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remove the condition for this thread to let the next thread</span></span><br><span class="line">            <span class="comment">// in line start getting memory</span></span><br><span class="line">            <span class="comment">/* 已经成功分配空间，移除 Condition */</span></span><br><span class="line">            Condition removed = <span class="keyword">this</span>.waiters.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (removed != moreMemory)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Wrong condition: this shouldn't happen."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// signal any additional waiters if there is more memory left</span></span><br><span class="line">            <span class="comment">// over for them</span></span><br><span class="line">            <span class="comment">/* 还是要用空闲空间，就唤醒下一个线程 */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.availableMemory &gt; <span class="number">0</span> || !<span class="keyword">this</span>.free.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.waiters.isEmpty())</span><br><span class="line">                    <span class="keyword">this</span>.waiters.peekFirst().signal();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unlock and return the buffer</span></span><br><span class="line">            lock.unlock(); <span class="comment">/* 解锁 */</span></span><br><span class="line">            <span class="keyword">if</span> (buffer == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> ByteBuffer.allocate(size);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> buffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">/* 解锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (lock.isHeldByCurrentThread())</span><br><span class="line">            lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了 <code>allocate()</code> 方法的实现后，继续分享 <code>deallocate()</code> 方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(ByteBuffer buffer, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    lock.lock(); <span class="comment">/* 加锁 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 释放的 ByteBuffer 的大小是 poolableSize，放入 free 队列进行管理 */</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="keyword">this</span>.poolableSize &amp;&amp; size == buffer.capacity()) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">this</span>.free.add(buffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 释放的 ByteBuffer 大小不是 poolableSize，不会复用 ByteBuffer，仅修改 availableMemory 的值 */</span></span><br><span class="line">            <span class="keyword">this</span>.availableMemory += size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 唤醒一个因空间不足而阻塞的线程 */</span></span><br><span class="line">        Condition moreMem = <span class="keyword">this</span>.waiters.peekFirst();</span><br><span class="line">        <span class="keyword">if</span> (moreMem != <span class="keyword">null</span>)</span><br><span class="line">            moreMem.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">/* 解锁 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RecordAccumulator"><a href="#RecordAccumulator" class="headerlink" title="RecordAccumulator"></a>RecordAccumulator</h2><p>介绍完了 <code>MemoryRecord</code>、<code>RecordBatch</code> 以及 <code>BufferPool</code> 的工作机制，再来看 <code>RecordAccumulator</code> 的实现就比较简单了。先来看看 <code>RecordAccumulator</code> 中的关键字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指定每个 RecordBatch 底层 ByteBuffer 的大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> batchSize;</span><br><span class="line"><span class="comment">/* 压缩类型 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CompressionType compression;</span><br><span class="line"><span class="comment">/* BufferPool 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BufferPool free;</span><br><span class="line"><span class="comment">/* TopicPartition 与 RecordBatch 集合的映射关系，类型是 CopyOnWriteMap，是线程安全的结合，</span></span><br><span class="line"><span class="comment"> * 但其中的 Deque 是 ArrayDeque 类型，是非线程安全的结合。追加新消息或发送 RecordBatch</span></span><br><span class="line"><span class="comment"> * 的时候，需要同步加锁。每个 Deque 都保持了发往对应 TopicPartition 的 RecordBatch 集合*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; batches;</span><br><span class="line"><span class="comment">/* 未发送完成 RecordBatch 集合，底层通过 Set&lt;RecordBatch&gt; 实现 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IncompleteRecordBatches incomplete;</span><br><span class="line"><span class="comment">/* 使用 drain 方法批量导出 RecordBatch 时，为了防止饥饿，使用 drainIndex 记录上次发送停止时的位置，</span></span><br><span class="line"><span class="comment"> * 下次继续从此位置开始发送 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> drainIndex;</span><br></pre></td></tr></table></figure><p><code>KafkaProducer.send()</code> 方法最终会调用 <code>RecordsAccumulator.append()</code> 方法将消息追加到 <code>RecordAccumulator</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Callback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> maxTimeToBlock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// We keep track of the number of appending thread to make sure we do not miss batches in</span></span><br><span class="line">    <span class="comment">// abortIncompleteBatches().</span></span><br><span class="line">    <span class="comment">/* 统计正在向 RecordsAccumulator 中追加数据的线程数 */</span></span><br><span class="line">    appendsInProgress.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 1. 查找 TopicPartition 对应的 Deque */</span></span><br><span class="line">        <span class="comment">// check if we have an in-progress batch</span></span><br><span class="line">        Deque&lt;RecordBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123; <span class="comment">/* 2. 对 Deque 对象加锁 */</span></span><br><span class="line">            <span class="comment">/* 边界检查 */</span></span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot send after the producer is closed."</span>);</span><br><span class="line">            <span class="comment">/* 3. 向 Deque 中最后一个 RecordBatch 追加 Record */</span></span><br><span class="line">            RecordAppendResult appendResult = tryAppend(timestamp, key, value, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> appendResult; <span class="comment">/* 5. 追加成功直接返回 */</span></span><br><span class="line">        &#125; <span class="comment">/* 4. synchronized 块结束，自动解锁 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// we don't have an in-progress record batch try to allocate a new batch</span></span><br><span class="line">        <span class="comment">/* 6. 追加失败，从 BufferPool 中申请新空间 */</span></span><br><span class="line">        <span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, Records.LOG_OVERHEAD + Record.recordSize(key, value));</span><br><span class="line">        log.trace(<span class="string">"Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;"</span>, size, tp.topic(), tp.partition());</span><br><span class="line">        ByteBuffer buffer = free.allocate(size, maxTimeToBlock);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">            <span class="comment">// Need to check if producer is closed again after grabbing the dequeue lock.</span></span><br><span class="line">            <span class="comment">/* 边界检查 */</span></span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot send after the producer is closed."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 7. 对 Deque 加锁后，再次调用 tryAppend() 方法尝试追加 Record */</span></span><br><span class="line">            RecordAppendResult appendResult = tryAppend(timestamp, key, value, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>) &#123; <span class="comment">/* 8. 追加成功，则返回 */</span></span><br><span class="line">                <span class="comment">// Somebody else found us a batch, return the one we waited for! Hopefully this doesn't happen often...</span></span><br><span class="line">                free.deallocate(buffer); <span class="comment">/* 释放 7 申请的新空间 */</span></span><br><span class="line">                <span class="keyword">return</span> appendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            MemoryRecords records = MemoryRecords.emptyRecords(buffer, compression, <span class="keyword">this</span>.batchSize);</span><br><span class="line">            RecordBatch batch = <span class="keyword">new</span> RecordBatch(tp, records, time.milliseconds());</span><br><span class="line">            <span class="comment">/* 9. 在新创建的 RecordBatch 中追加 Record，并将其添加到 batches 集合中 */</span></span><br><span class="line">            FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">            dq.addLast(batch);</span><br><span class="line">            <span class="comment">/* 10. 将新建的 RecordBatch 追加到 incomplete 集合 */</span></span><br><span class="line">            incomplete.add(batch);</span><br><span class="line">            <span class="comment">/* 12. 返回 RecordAppendResult */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.records.isFull(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="comment">/* 11. synchronized 块结束，解锁 */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        appendsInProgress.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面之所以分为两个 <code>synchronized</code> 是因为向 <code>BufferPool</code> 申请新 <code>ByteBuffer</code> 的时候，可能会导致阻塞。我们假设在一个 <code>synchronized</code> 中完成上面所有的追加操作，有下面的场景：线程 1 发送的消息比较大，需要向 <code>BufferPool</code> 申请新空间，而此时 <code>BufferPool</code> 空间不足，线程 1 在 <code>BufferPool</code> 上等待，此时它依然持有对应 <code>Deque</code> 的锁；线程 2 发送的消息较小，<code>Deque</code> 最后一个 <code>RecordBatch</code> 剩余空间够用，但是由于线程 1 未释放 <code>Deque</code> 的锁，所以也需要一起等待。若线程 2 这样的线程比较多，就会造成很多不必要的线程阻塞，降低了吞吐量。</p><p>第二次加锁后重试，是为了防止多个线程并发向 <code>BufferPool</code> 申请空间后，造成内部碎片。</p><p>现在回到 <code>KafkaProducer.doSend()</code> 方法，<code>doSend()</code> 方法的最后一步就是判断此次向 <code>RecordAccumulator</code> 中追加消息后是否满足唤醒 <code>Sender</code> 线程条件，这里唤醒 <code>Sender</code> 线程的条件是消息所在队列的最后一个 <code>RecordBatch</code> 满了或此队列中不止一个 <code>RecordBatch</code>。</p><p>在客户端将消息发送给服务端之前，会调用 <code>RecordAccumulator.ready()</code> 方法获取集群中符合发送消息条件的节点集合。这些条件是站在 <code>RecordAccumulator</code> 的家都对集群中的 <code>Node</code> 进行筛选，具体条件如下：</p><ol><li><code>Deque</code> 中有多个 <code>RecordBatch</code> 或是第一个 <code>RecordBatch</code> 是否满了</li><li>是否超时了</li><li>是否有其他线程在等待 <code>BufferPool</code> 释放空间（即 <code>BufferPool</code> 的空间耗尽了）</li><li>是否有线程正在等待 <code>flush</code> 操作完成</li><li><code>Sender</code> 线程准备关闭</li></ol><p>下面来看一下 <code>ready</code> 的代码，它会遍历 <code>batches</code> 集合中每个分区，首先查找当前分区 <code>Leader</code> 副本所在的 <code>Node</code> ，如果满足上述五个条件，则将此 <code>Node</code> 信息记录到 <code>readyNodes</code> 集合中。遍历完成后返回 <code>ReadyCheckResult</code> 对象，其中记录了满足发送条件的 <code>Node</code> 集合、在遍历过程中是否找不到 <code>Leader</code> 副本的分区（也可以认为是 <code>Metadata</code> 中当前的元数据过时了）、下次调用 <code>ready()</code> 方法进行检查的时间间隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReadyCheckResult <span class="title">ready</span><span class="params">(Cluster cluster, <span class="keyword">long</span> nowMs)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; readyNodes = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">/* 用来记录可以向那些 Node 节点发送数据 */</span></span><br><span class="line">    <span class="keyword">long</span> nextReadyCheckDelayMs = Long.MAX_VALUE; <span class="comment">/* 记录下次需要调用 ready() 方法的时间间隔 */</span></span><br><span class="line">     <span class="comment">/* 根据 Metadata 元数据中记录有找不到 Leader 副本的分区 */</span></span><br><span class="line">    Set&lt;String&gt; unknownLeaderTopics = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否有现车在阻塞等待 BufferPool 释放空间 */</span></span><br><span class="line">    <span class="keyword">boolean</span> exhausted = <span class="keyword">this</span>.free.queued() &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 下面遍历 batches 集合，对其中每个分区的 Leader 副本所在的 Node 都进行判断 */</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; entry : <span class="keyword">this</span>.batches.entrySet()) &#123;</span><br><span class="line">        TopicPartition part = entry.getKey();</span><br><span class="line">        Deque&lt;RecordBatch&gt; deque = entry.getValue();</span><br><span class="line"></span><br><span class="line">        Node leader = cluster.leaderFor(part); <span class="comment">/* 查找分区的 Leader 副本所在的 Node */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (deque) &#123; <span class="comment">/* 加锁读取 deque 的元素 */</span></span><br><span class="line">            <span class="comment">/* 根据 Cluster 的信息检查 Leader，Leader 找不到，肯定不能发送消息 */</span></span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; !deque.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// This is a partition for which leader is not known, but messages are available to send.</span></span><br><span class="line">                <span class="comment">// Note that entries are currently not removed from batches when deque is empty.</span></span><br><span class="line">                <span class="comment">/* 这里不为空之后会触发 Metadata 的更新 */</span></span><br><span class="line">                unknownLeaderTopics.add(part.topic());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!readyNodes.contains(leader) &amp;&amp; !muted.contains(part)) &#123;</span><br><span class="line">                <span class="comment">/* 只取 Deque 中的第一个 RecordBatch */</span></span><br><span class="line">                RecordBatch batch = deque.peekFirst();</span><br><span class="line">                <span class="keyword">if</span> (batch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> backingOff = batch.attempts &gt; <span class="number">0</span> &amp;&amp; batch.lastAttemptMs + retryBackoffMs &gt; nowMs;</span><br><span class="line">                    <span class="keyword">long</span> waitedTimeMs = nowMs - batch.lastAttemptMs;</span><br><span class="line">                    <span class="keyword">long</span> timeToWaitMs = backingOff ? retryBackoffMs : lingerMs;</span><br><span class="line">                    <span class="keyword">long</span> timeLeftMs = Math.max(timeToWaitMs - waitedTimeMs, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">/* Deque 中有多个 RecordBatch 或是第一个 RecordBatch 是否满了 */</span></span><br><span class="line">                    <span class="keyword">boolean</span> full = deque.size() &gt; <span class="number">1</span> || batch.records.isFull();</span><br><span class="line">                    <span class="comment">/* 是否超时了 */</span></span><br><span class="line">                    <span class="keyword">boolean</span> expired = waitedTimeMs &gt;= timeToWaitMs;</span><br><span class="line">                    <span class="keyword">boolean</span> sendable = full || expired</span><br><span class="line">                            || exhausted <span class="comment">/* 是否有其他线程在等待 BufferPool 释放空间（即 BufferPool 的空间耗尽了）*/</span></span><br><span class="line">                            || closed  <span class="comment">/* Sender 线程准备关闭 */</span></span><br><span class="line">                            || flushInProgress(); <span class="comment">/* 是否有线程正在等待 flush 操作完成 */</span></span><br><span class="line">                    <span class="keyword">if</span> (sendable &amp;&amp; !backingOff) &#123;</span><br><span class="line">                        readyNodes.add(leader);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Note that this results in a conservative estimate since an un-sendable partition may have</span></span><br><span class="line">                        <span class="comment">// a leader that will later be found to have sendable data. However, this is good enough</span></span><br><span class="line">                        <span class="comment">// since we'll just wake up and then sleep again for the remaining time.</span></span><br><span class="line">                        <span class="comment">/* 记录下次需要调用 ready() 方法检查的时间间隔 */</span></span><br><span class="line">                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadyCheckResult(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>RecordAccumulator.ready()</code> 方法得到 <code>readyNodes</code> 集合后，此集合还要经过 <code>NetworkClient</code> 的过滤之后，才能得到最终能够发送消息的 <code>Node</code> 集合。</p><p><code>RecordAccumulator.drain()</code> 方法会根据上述 <code>Node</code> 集合获取要发送的消息，返回 <code>Map&lt;Integer, List&lt;RecordBatch&gt;&gt;</code> 集合，<code>key</code> 是 <code>NodeId</code>，<code>value</code> 是待发送的 <code>RecordBatch</code> 集合。<code>drain</code> 方法也是由 <code>Sender</code> 线程调用的。</p><p><code>drain</code> 方法的核心逻辑是进行映射的转换：将 <code>RecordAccumulatro</code> 记录的 <code>TopicPartition -&gt; RecordBatch</code> 集合的映射，转换成了 <code>NodeId -&gt; RecordBatch</code> 集合的映射。</p><p>为什么需要这次转换？在网络 I/O 层面，生产者是面向 <code>Node</code> 节点发送消息数据，它只建立到 <code>Node</code> 的连接并发送数据，并不关心这些数据数据哪个 <code>TopicPartition</code> ；而是调用 <code>KafkaProducer</code> 的上层业务逻辑中，则是按照 <code>TopicPartition</code> 的 <code>Node</code> 节点上。在之后介绍 <code>Sender</code> 线程的时候会发现，它每次向每个 <code>Node</code> 节点至多发送一个 <code>ClientRequest</code> 请求，其中封装了追加到此 <code>Node</code> 节点上多个分区的消息，待请求到达服务端后，由 Kafka 对请求进行解析。</p><p>下面来看看 <code>drain</code> 方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Integer, List&lt;RecordBatch&gt;&gt; drain(Cluster cluster,</span><br><span class="line">                                             Set&lt;Node&gt; nodes,</span><br><span class="line">                                             <span class="keyword">int</span> maxSize,</span><br><span class="line">                                             <span class="keyword">long</span> now) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 转换之后的结果 */</span></span><br><span class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : nodes) &#123; <span class="comment">/* 遍历指定的 ready Node 集合 */</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 获取当前 Node 上的分区集合 */</span></span><br><span class="line">        List&lt;PartitionInfo&gt; parts = cluster.partitionsForNode(node.id());</span><br><span class="line">        <span class="comment">/* 记录要发送的 RecordBatch */</span></span><br><span class="line">        List&lt;RecordBatch&gt; ready = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/* to make starvation  less likely this loop doesn't start at 0 */</span></span><br><span class="line">        <span class="comment">/* drainIndex 是 batches 的下标，记录上次发送停止时的位置，下次继续从此位置开始发送</span></span><br><span class="line"><span class="comment">         * 若一直从索引 0 的队列开始发送，可能会出现一直发送前几个分区的消息的情况，造成其他分区饥饿 */</span></span><br><span class="line">        <span class="keyword">int</span> start = drainIndex = drainIndex % parts.size();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            PartitionInfo part = parts.get(drainIndex); <span class="comment">/* 获取分区详细情况 */</span></span><br><span class="line">            TopicPartition tp = <span class="keyword">new</span> TopicPartition(part.topic(), part.partition());</span><br><span class="line">            <span class="comment">// Only proceed if the partition has no in-flight batches.</span></span><br><span class="line">            <span class="keyword">if</span> (!muted.contains(tp)) &#123;</span><br><span class="line">                <span class="comment">/* 获取对应的 RecordBatch 队列 */</span></span><br><span class="line">                Deque&lt;RecordBatch&gt; deque = getDeque(<span class="keyword">new</span> TopicPartition(part.topic(), part.partition()));</span><br><span class="line">                <span class="comment">/* 边界检查 */</span></span><br><span class="line">                <span class="keyword">if</span> (deque != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">                        RecordBatch first = deque.peekFirst();</span><br><span class="line">                        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">boolean</span> backoff = first.attempts &gt; <span class="number">0</span> &amp;&amp; first.lastAttemptMs + retryBackoffMs &gt; now;</span><br><span class="line">                            <span class="comment">// Only drain the batch if it is not during backoff period.</span></span><br><span class="line">                            <span class="keyword">if</span> (!backoff) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (size + first.records.sizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;</span><br><span class="line">                                    <span class="comment">// there is a rare case that a single batch size is larger than the request size due</span></span><br><span class="line">                                    <span class="comment">// to compression; in this case we will still eventually send this batch in a single</span></span><br><span class="line">                                    <span class="comment">// request</span></span><br><span class="line">                                    <span class="keyword">break</span>; <span class="comment">/* 队列已满，结束循环，一般是一个请求的大小 */</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">/* 从队列中获取一个 RecordBatch，并将这个 RecordBatch 放到 ready 集合中 */</span></span><br><span class="line">                                    RecordBatch batch = deque.pollFirst();</span><br><span class="line">                                    <span class="comment">/* 关闭 Compressor 及底层输出流，并将 MemoryRecords 设置为只读 */</span></span><br><span class="line">                                    batch.records.close();</span><br><span class="line">                                    size += batch.records.sizeInBytes();</span><br><span class="line">                                    ready.add(batch);</span><br><span class="line">                                    batch.drainedMs = now;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 更新 drainIndex */</span></span><br><span class="line">            <span class="keyword">this</span>.drainIndex = (<span class="keyword">this</span>.drainIndex + <span class="number">1</span>) % parts.size();</span><br><span class="line">        &#125; <span class="keyword">while</span> (start != drainIndex);</span><br><span class="line">        batches.put(node.id(), ready);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在上面代码中，只从每个队列中取出一个 <code>RecordBatch</code> 放到 <code>ready</code> 集合中，这也是为了防止饥饿，提高系统的可用性。</p><p><code>RecordAccumulator</code> 的工作原理到这里就介绍完了，整个 <code>KafkaProducer.send()</code> 方法过程中用到的所有组件也都分析完了。后面将分析的是 <code>Sender</code> 线程是如何发送消息的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 紧接 &lt;a href=&quot;https://binglau7.github.io/2017/12/18/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94KafkaProducer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kafka生产者分析——KafkaProducer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文介绍过，KafkaProducer 可以有同步和异步两种方式发送消息，其实两者的底层实现相同，都是通过异步方式实现的。主线程调用 &lt;code&gt;KafkaProducer#send()&lt;/code&gt; 方法发送消息的时候，先将消息放到 &lt;code&gt;RecordAccumulator&lt;/code&gt; 中暂存，然后主线程就可以从 &lt;code&gt;send()&lt;/code&gt; 方法中返回了，此时消息并没有真正地发送给 Kafka，而是缓存在了 &lt;code&gt;RecordAccumulator&lt;/code&gt; 中。之后，业务线程&lt;strong&gt;通过 &lt;code&gt;KafkaProducer#send()&lt;/code&gt; 方法不断向 &lt;code&gt;RecordAccumulator&lt;/code&gt; 追加消息，当达到一定的条件，会唤醒 &lt;code&gt;Sender&lt;/code&gt; 线程发送 &lt;code&gt;RecordAccumulator&lt;/code&gt; 中的消息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们就来介绍 &lt;code&gt;RecordAccumulator&lt;/code&gt; 的结构。首先需要注意的是，&lt;strong&gt;&lt;code&gt;RecordAccumulator&lt;/code&gt; 至少有一个业务线程和一个 &lt;code&gt;Sender&lt;/code&gt; 线程并发操作，所以必须是线程安全的&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
      <category term="分布式与中间件" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码分析-AOP</title>
    <link href="http://yoursite.com/2017/12/18/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-AOP/"/>
    <id>http://yoursite.com/2017/12/18/Spring源码分析-AOP/</id>
    <published>2017-12-18T14:28:01.000Z</published>
    <updated>2017-12-18T14:29:08.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态-AOP-使用示例"><a href="#动态-AOP-使用示例" class="headerlink" title="动态 AOP 使用示例"></a>动态 AOP 使用示例</h2><ol><li><p>创建用于拦截的 bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String testStr = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建 Advisor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* *.test(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beforeTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundTest</span><span class="params">(ProceedingJoinPoint p)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"brfore around"</span>);</span><br><span class="line">        Object o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            o = p.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after around"</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.bean.TestBean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.AspectJTest"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beanFactory.xml"</span>);</span><br><span class="line">    TestBean bean = (TestBean) ctx.getBean(<span class="string">"testBean"</span>);</span><br><span class="line">    bean.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不出意外结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brfore around</span><br><span class="line">beforeTest</span><br><span class="line">test</span><br><span class="line">after around</span><br><span class="line">afterTest</span><br></pre></td></tr></table></figure></li></ol><p>可知 <code>&lt;aop:aspectj-autoproxy /&gt;</code> 是开启 aop 的关键，我们不妨由此入手。</p><a id="more"></a><h2 id="动态-AOP-自定义标签"><a href="#动态-AOP-自定义标签" class="headerlink" title="动态 AOP 自定义标签"></a>动态 AOP 自定义标签</h2><p>之前讲过 Spring 中的<a href="https://binglau7.github.io/2017/11/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-bean%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/" target="_blank" rel="noopener">自定义注解</a>，如果声明了自定义的注解，那么就一定会在程序中的某个地方注册了对应的解析器。我们搜索整个代码，尝试找到注册的地方，全局搜索后我们发现了在 <code>AopNamespaceHandler</code> 中对应着这样一段函数。中间我们看到了 <code>aspectj-autoproxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only in 2.0 XSD: moved to context namespace as of 2.1</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册-AnnotationAwareAspectJAutoProxyCreator"><a href="#注册-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="注册 AnnotationAwareAspectJAutoProxyCreator"></a>注册 <code>AnnotationAwareAspectJAutoProxyCreator</code></h3><p>所有解析器，因为是对 <code>BeanDefinitionParser</code> 接口的统一实现，入口都是从 <code>parse</code> 函数开始的，<code>AspectJAutoProxyBeanDefinitionParser</code> 的 <code>parse</code> 函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">        <span class="comment">// 对于注解中子类的处理</span></span><br><span class="line">extendBeanDefinition(element, parserContext);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>registerAspectJAnnotationAutoProxyCreatorIfNecessary</code> 很明显值得注意，这也是其关键逻辑的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册或升级 AutoProxyCreator 定义 beanName 为 org.Springframework.aop.config.internalAutoProxyCreator 的 BeanDefinition</span></span><br><span class="line">BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">        <span class="comment">// 对于 proxy-target-class 以及 expose-proxy 属性的处理</span></span><br><span class="line">useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">        <span class="comment">// 注册组件并通知，便于监听器做进一步处理</span></span><br><span class="line">        <span class="comment">// 其中 beanDefinition 的 className 为 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册或者升级-AnnotationAwareAspectJAutoProxyCreator"><a href="#注册或者升级-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="注册或者升级 AnnotationAwareAspectJAutoProxyCreator"></a>注册或者升级 <code>AnnotationAwareAspectJAutoProxyCreator</code></h4><p>对于 AOP 的实现，基本上都是靠 <code>AnnotationAwareAspectJAutoProxyCreator</code> 去完成，它可以根据 <code>@Point</code> 注解定义的切点来自动代理相匹配的 bean。但是为了配置简便，Spring 使用了自定义配置来帮助我们自动注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> ，其注册过程就是在这里实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(**AnnotationAwareAspectJAutoProxyCreator**.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">        <span class="comment">// 如果已经存在了自动代理创建器且存在的自动代理创建器与现状的不一致那么需要根据优先级来判断</span></span><br><span class="line">        <span class="comment">// 到底需要使用哪个</span></span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="comment">// public static final String AUTO_PROXY_CREATOR_BEAN_NAME =</span></span><br><span class="line">            <span class="comment">//  "org.springframework.aop.config.internalAutoProxyCreator";</span></span><br><span class="line">BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line"><span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line"><span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line"><span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line"><span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                     <span class="comment">// 改变 bean 最重要的就是改变 bean 所对应的 className 属性</span></span><br><span class="line">apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 如果已经存在自动代理创建器并且与将要创建的一直，那么无需再次创建</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">beanDefinition.setSource(source);</span><br><span class="line">beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line"><span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中实现了自动注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类的功能，同时这里还涉及了一个优先级的问题，如果已经存在了自动代理创建器，而且存在的自动代理创建器与现在的不一致，那么需要根据优先级来判断到底需要使用哪个。</p><h4 id="处理-proxy-target-class-以及-expose-proxy-属性"><a href="#处理-proxy-target-class-以及-expose-proxy-属性" class="headerlink" title="处理 proxy-target-class 以及 expose-proxy 属性"></a>处理 proxy-target-class 以及 expose-proxy 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Element sourceElement)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对于 proxy-target-class 属性的处理</span></span><br><span class="line"><span class="keyword">boolean</span> proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line"><span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 对于 expose-proxy 属性的处理</span></span><br><span class="line"><span class="keyword">boolean</span> exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line"><span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制使用的过程其实也是一个属性设置的过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceAutoProxyCreatorToUseClassProxying</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">definition.getPropertyValues().add(<span class="string">"proxyTargetClass"</span>, Boolean.TRUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceAutoProxyCreatorToExposeProxy</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">definition.getPropertyValues().add(<span class="string">"exposeProxy"</span>, Boolean.TRUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="proxy-target-class"><a href="#proxy-target-class" class="headerlink" title="proxy-target-class"></a>proxy-target-class</h5><p>Spring AOP 部分使用 <strong>JDK 动态代理</strong>或者 <strong>CGLIB</strong> 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理），<strong>如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。</strong>所有该目标类型实现的接口都将被代理。<strong>若该目标对象没有实现任何接口，则创建一个CGLIB代理。</strong>如果你希望强制使用CGLIB代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个问题。</p><ul><li>无法通知（advise）Final 方法，因为它们不能被覆写。</li><li>你需要将CGLIB二进制发行包放在classpath下面。</li></ul><p>如果需要强制使用 CGLIB 代理，则需要将 <code>&lt;aop:config&gt;</code> 的 <code>proxy-target-class</code> 属性设为 true:</p><p><code>&lt;aop:config proxy-target-class=&quot;true&quot;&gt; ... &lt;/aop:config&gt;</code></p><p>当需要使用 CGLIB 代理和 <code>@AspectJ</code> 自动代理支持，可以按照以下方式设置 <code>&lt;aop:aspectj-autoproxy&gt;</code> 的 <code>proxy-target-class</code> 属性：</p><p><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></p><h5 id="JDK-动态代理-vs-CGLIB-代理"><a href="#JDK-动态代理-vs-CGLIB-代理" class="headerlink" title="JDK 动态代理 vs CGLIB 代理"></a>JDK 动态代理 vs CGLIB 代理</h5><ul><li>JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。</li><li>CGLIB 代理：实现原理类似于 JDK 动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的Java字节码编辑类库）操作字节码实现的，性能比JDK强。</li></ul><p>具体可以看之前的博客 <a href="https://binglau7.github.io/2017/06/11/AOP%E7%9A%84%E9%81%93%E7%90%86/" target="_blank" rel="noopener">AOP 的道理</a></p><h5 id="expose-proxy"><a href="#expose-proxy" class="headerlink" title="expose-proxy"></a>expose-proxy</h5><p>有时候目标对象内部的自我调用将无法实施切面中的增强，如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl1</span> <span class="keyword">implements</span> <span class="title">AService</span></span>&#123;</span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.b();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 this 指向目标对象，因此调用 <code>this.b()</code> 将不会执行 b 事务切面，即不会执行事务增强，因此 b 方法的事务定义<code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>将不会实施，为了解决这个问题，我们可以这样做：</p><p><code>&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;/&gt;</code></p><p>然后将以上代码中的 <code>this.b();</code> 修改为 <code>((AService) AopContext.currentProxy()).b();</code> 即可。通过以上的修改便可以完成对 a 和 b 方法的同时增强。</p><p>最后注册组件并通知，便于监听器做进一步处理，这里就不再一一赘述了。</p><h2 id="创建-AOP-代理"><a href="#创建-AOP-代理" class="headerlink" title="创建 AOP 代理"></a>创建 AOP 代理</h2><p>上文讲解了通过自定义配置完成了对 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类型的自动注册，那么这个类到底做了什么工作来完成 AOP 的操作呢？</p><p>首先让我们看看 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类的层次结构</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_41/AnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg?raw=true" alt="AnnotationAwareAspectJAutoProxyCreator类的层次结构图"></p><p>我们看到 <code>AnnotationAwareAspectJAutoProxyCreator</code> 实现了 <code>BeanPostProcessor</code> 接口，而实现了该接口之后，当 Spring 加载这个 Bean 时会在实例化之前调用其 <code>postProcessAfterInitialization</code> 方法，其逻辑也由此开始。</p><p>其父类 <code>AbstractAutoProxyCreator#postProcessAfterInitialization</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据给定的 bean 的 class 和 name 构建出个 key，格式: beanClassName_beanName</span></span><br><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 bean 不存在的一些处理或者这个 bean 无需增强</span></span><br><span class="line"><span class="keyword">if</span> (beanName == <span class="keyword">null</span> || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 跳过一些特殊的类</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"><span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"><span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line"><span class="keyword">if</span> (beanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">                 <span class="comment">// 如果存在增强方法则创建代理</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">                 <span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致主流程氛围三步（判断条件走完之后）：</p><ol><li>获取需要增强的 targetSource</li><li>获取增强器</li><li>根据需要增强的 targetSource 和增强器创建代理​</li></ol><h3 id="获取-targetSource"><a href="#获取-targetSource" class="headerlink" title="获取 targetSource"></a>获取 targetSource</h3><blockquote><p> 这部分代码与书上不符，属于多出来的步骤</p></blockquote><p>这里顺便贴出 TargetSource 的说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> TargetSource&#125; is used to obtain the current "target" of</span></span><br><span class="line"><span class="comment"> * an AOP invocation, which will be invoked via reflection if no around</span></span><br><span class="line"><span class="comment"> * advice chooses to end the interceptor chain itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a &#123;<span class="doctag">@code</span> TargetSource&#125; is "static", it will always return</span></span><br><span class="line"><span class="comment"> * the same target, allowing optimizations in the AOP framework. Dynamic</span></span><br><span class="line"><span class="comment"> * target sources can support pooling, hot swapping, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Application developers don't usually need to work with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> TargetSources&#125; directly: this is an AOP framework interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这里可以看，TargetSource 是用来获取调用 AOP 的那个当前『目标』。每当AOP代理处理一个方法调用时都会向TargetSource 的实现请求一个目标实例。</p><p>使用 Spring AOP 的开发者通常不需要直接和 TargetSource 打交道，但这提供了一种强大的方式来支持池化（pooling），热交换（hot swappable）和其它高级目标。 例如，一个使用池来管理实例的 TargetSource 可以为每个调用返回一个不同的目标实例。</p><p>如果你不指定一个TargetSource，一个缺省实现将被使用，它包装一个本地对象。对于每次调用它将返回相同的目标（像你期望的那样）。</p><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-targetsource" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a target source for bean instances. Uses any TargetSourceCreators if set.</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> null&#125; if no custom TargetSource should be used.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation uses the "customTargetSourceCreators" property.</span></span><br><span class="line"><span class="comment"> * Subclasses can override this method to use a different mechanism.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the class of the bean to create a TargetSource for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a TargetSource for this bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setCustomTargetSourceCreators</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TargetSource <span class="title">getCustomTargetSource</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// We can't create fancy target sources for directly registered singletons.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.customTargetSourceCreators != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line"><span class="keyword">this</span>.beanFactory != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.beanFactory.containsBean(beanName)) &#123;</span><br><span class="line"><span class="keyword">for</span> (TargetSourceCreator tsc : <span class="keyword">this</span>.customTargetSourceCreators) &#123;</span><br><span class="line">TargetSource ts = tsc.getTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ts != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Found a matching TargetSource.</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"TargetSourceCreator ["</span> + tsc +</span><br><span class="line"><span class="string">" found custom TargetSource for bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No custom TargetSource found.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取增强器"><a href="#获取增强器" class="headerlink" title="获取增强器"></a>获取增强器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于指定 bean 的增强方法的获取一定是包含两个步骤的，获取所有的增强以及寻找所有增强中适用于 bean 的增强并应用，那么 <code>findCandidateAdvisors</code> 与 <code>findAdvisorsThatCanApply</code> 便是做了这两件事情。当然，如果无法找到对应的增强器便返回  null。</p><p>由于我们分析的是使用注解进行的 AOP，所以对于 <code>findCandidateAdvisors</code> 的实现其实是由 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">        <span class="comment">// 当使用注解方式配置 AOP 的时候并不是丢弃了对 XML 配置的支持</span></span><br><span class="line">        <span class="comment">// 在这里调用父类方法加载配置文件中的 AOP 声明</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationAwareAspectJAutoProxyCreator</code> 间接继承了 <code>AbstractAdvisorAutoProxyCreator</code>，在实现获取增强的方法中除了保留父类的获取配置文件中定义的增强外，同时添加了获取 Bean 的注解增强的功能，那么其实现正是由<code>this.aspectJAdvisorsBuilder.buildAspectJAdvisors()</code>来实现的。</p><p>首先在没有接触代码的情况下，让我们理一下思路，看看增强器解析步骤</p><ol><li>获取所有 beanName，这一步骤中所有再 beanFactory 中注册的 Bean 都会被提取出来</li><li>遍历所有 beanName，并找出声明 AspectJ 注解的类，进行进一步处理</li><li>对标记为 AspectJ 注解的类进行增强器的提取</li><li>将提取结果加入缓存</li></ol><p>接下来看看实现，首先是对 Spring 中所有类进行分析，提取 Advisor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look for AspectJ-annotated aspect beans in the current bean factory,</span></span><br><span class="line"><span class="comment"> * and return to a list of Spring AOP Advisors representing them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Creates a Spring Advisor for each AspectJ advice method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the list of &#123;<span class="doctag">@link</span> org.springframework.aop.Advisor&#125; beans</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isEligibleBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">aspectNames = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">                     <span class="comment">// 获取所有 beanName</span></span><br><span class="line">String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line"><span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                     <span class="comment">// 循环所有的 beanName 找出对应的增强方法</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                          <span class="comment">// 不合法的 bean 则略过，由子类定义规则，默认返回 true</span></span><br><span class="line"><span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line"><span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">                         <span class="comment">// 获取对应的 bean 的类型</span></span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">                         <span class="comment">// 如果存在 Aspect 注解</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">aspectNames.add(beanName);</span><br><span class="line">AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line"><span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line"><span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                                  <span class="comment">// 解析标记 AspectJ 注解中的增强方法</span></span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">&#125;</span><br><span class="line">advisors.addAll(classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Per target or per this.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line"><span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">&#125;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line"><span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line"><span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 记录在缓存中</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line"><span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line"><span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisors.addAll(cachedAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们已经完成了 Advisor 的提取，其中增强器获取的工作委托给了 <code>getAdvisors</code> 方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取标记为 AspectJ 的类</span></span><br><span class="line">Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        <span class="comment">// 获取标记为 AspectJ 的 name</span></span><br><span class="line">String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">        <span class="comment">// 验证</span></span><br><span class="line">validate(aspectClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line"><span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line"><span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line"><span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line"><span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisors.add(advisor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line"><span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">          <span class="comment">// 如果寻找的增强器不为空而且又配置了增强延迟初始化那么需要在首位加入同步实例化增强器</span></span><br><span class="line">Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find introduction fields.</span></span><br><span class="line">      <span class="comment">// 获取 DeclareParents 注解</span></span><br><span class="line"><span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line"><span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisors.add(advisor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAdvisorMethods</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> List&lt;Method&gt; methods = <span class="keyword">new</span> LinkedList&lt;Method&gt;();</span><br><span class="line">ReflectionUtils.doWithMethods(aspectClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="comment">// Exclude pointcuts</span></span><br><span class="line">                 <span class="comment">// 对声明为 pointcut 的方法不处理</span></span><br><span class="line"><span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">methods.add(method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Collections.sort(methods, METHOD_COMPARATOR);</span><br><span class="line"><span class="keyword">return</span> methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通增强器的获取"><a href="#普通增强器的获取" class="headerlink" title="普通增强器的获取"></a>普通增强器的获取</h4><p>普通增强器的获取逻辑通过 <code>getAdvisor</code> 方法实现，实现步骤包括对切点的注解的获取以及根据注解信息生成增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 切点信息获取</span></span><br><span class="line">AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"><span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 根据切点信息生成增强器</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line"><span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="切点信息获取"><a href="#切点信息获取" class="headerlink" title="切点信息获取"></a>切点信息获取</h5><p>所谓获取切点信息就是制定注解的表达式信息的获取，如 <code>@Before(&quot;test()&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取方法上的注解</span></span><br><span class="line">AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line"><span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 AspectJExpressionPointcut 实例封装获取的信息</span></span><br><span class="line">AspectJExpressionPointcut ajexp =</span><br><span class="line"><span class="keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 提取得到的注解中的表达式，如</span></span><br><span class="line">        <span class="comment">// @Pointcut("execution(* *.*test*(..))") 中的 execution(* *.*test*(..))</span></span><br><span class="line">ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">ajexp.setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line"><span class="keyword">return</span> ajexp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">        <span class="comment">// 设置敏感的注解类</span></span><br><span class="line">Class&lt;?&gt;[] classesToLookFor = <span class="keyword">new</span> Class&lt;?&gt;[] &#123;</span><br><span class="line">Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class="line">AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class="line"><span class="keyword">if</span> (foundAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> foundAnnotation;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定方法上的注解并使用 AspectJAnnotation 封装</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;A extends Annotation&gt; <span class="function">AspectJAnnotation&lt;A&gt; <span class="title">findAnnotation</span><span class="params">(Method method, Class&lt;A&gt; toLookFor)</span> </span>&#123;</span><br><span class="line">A result = AnnotationUtils.findAnnotation(method, toLookFor);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AspectJAnnotation&lt;A&gt;(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="根据切点信息生成增强"><a href="#根据切点信息生成增强" class="headerlink" title="根据切点信息生成增强"></a>根据切点信息生成增强</h5><p>所有的增强都由 Advisor 的实现类 <code>InstantiationModelAwarePointcutAdvisorImpl</code> 统一封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(AspectJExpressionPointcut declaredPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// test()</span></span><br><span class="line"><span class="keyword">this</span>.declaredPointcut = declaredPointcut;</span><br><span class="line"><span class="keyword">this</span>.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class="line"><span class="keyword">this</span>.methodName = aspectJAdviceMethod.getName();</span><br><span class="line"><span class="keyword">this</span>.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class="line">      <span class="comment">// public void test.AspectJTest.beforeTest()</span></span><br><span class="line"><span class="keyword">this</span>.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line"><span class="keyword">this</span>.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line"><span class="keyword">this</span>.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">        <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.declarationOrder = declarationOrder;</span><br><span class="line">        <span class="comment">// test.AspectJTest</span></span><br><span class="line"><span class="keyword">this</span>.aspectName = aspectName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line"><span class="comment">// Static part of the pointcut is a lazy type.</span></span><br><span class="line">Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class="line">aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), <span class="keyword">this</span>.declaredPointcut);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span></span><br><span class="line"><span class="comment">// If it's not a dynamic pointcut, it may be optimized out</span></span><br><span class="line"><span class="comment">// by the Spring AOP infrastructure after the first evaluation.</span></span><br><span class="line"><span class="keyword">this</span>.pointcut = <span class="keyword">new</span> PerTargetInstantiationModelPointcut(</span><br><span class="line"><span class="keyword">this</span>.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line"><span class="keyword">this</span>.lazy = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// A singleton aspect.</span></span><br><span class="line"><span class="keyword">this</span>.pointcut = <span class="keyword">this</span>.declaredPointcut;</span><br><span class="line"><span class="keyword">this</span>.lazy = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">this</span>.instantiatedAdvice = instantiateAdvice(<span class="keyword">this</span>.declaredPointcut);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在封装过程中只是简单地将信息封装在类的实例中，所有的信息单纯地赋值，在<strong>实例初始化的过程中还完成了对于增强器的初始化</strong>。因为不同的增强所体现的逻辑是不同的，比如<code>@Before(&quot;test()&quot;)</code>与@<code>After(&quot;test()&quot;</code>标签的不同就是增强器增强的位置不同，所以就需要不同的增强器来完成不同的逻辑，而根据注解中的信息初始化对应的增强器就是在<code>instantiateAdvice</code>函数中实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Advice <span class="title">instantiateAdvice</span><span class="params">(AspectJExpressionPointcut pcut)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdvisorFactory.getAdvice(<span class="keyword">this</span>.aspectJAdviceMethod, pcut,</span><br><span class="line"><span class="keyword">this</span>.aspectInstanceFactory, <span class="keyword">this</span>.declarationOrder, <span class="keyword">this</span>.aspectName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">validate(candidateAspectClass);</span><br><span class="line"></span><br><span class="line">AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line"><span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we get here, we know we have an AspectJ method.</span></span><br><span class="line"><span class="comment">// Check that it's an AspectJ-annotated class</span></span><br><span class="line"><span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line"><span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractAspectJAdvice springAdvice;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据不同的注解类型封装不同的增强器</span></span><br><span class="line"><span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line"><span class="keyword">case</span> AtBefore:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(</span><br><span class="line">candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtAfter:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(</span><br><span class="line">candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(</span><br><span class="line">candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(</span><br><span class="line">candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtAround:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(</span><br><span class="line">candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtPointcut:</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now to configure the advice...</span></span><br><span class="line">springAdvice.setAspectName(aspectName);</span><br><span class="line">springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line"><span class="keyword">if</span> (argNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">&#125;</span><br><span class="line">springAdvice.calculateArgumentBindings();</span><br><span class="line"><span class="keyword">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 这里书上描述得有些奇怪，直接进入了 <code>MethodBeforeAdviceInterceptor</code> 解析了，但是我们并不知道这与 <code>AspectJMethodBeforeAdvice</code> 有何关系。后面查阅了一下网上资料。</p><p> <a href="http://lgbolgger.iteye.com/blog/2117214" target="_blank" rel="noopener">http://lgbolgger.iteye.com/blog/2117214</a></p><p> <a href="https://www.dengxiangxing.com/post/16229" target="_blank" rel="noopener">https://www.dengxiangxing.com/post/16229</a></p><p> <a href="http://www.voidcn.com/article/p-erexljic-bqk.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-erexljic-bqk.html</a></p></blockquote><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_41/Advice%20%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?raw=true" alt="Advice 结构图"></p><p>这里我们可以看出，<code>AspectJMethodBeforeAdvice</code> 和 <code>AspectJAfterReturningAdvice</code> 均没有实现  <code>MethodInterceptor</code> ，但是我们会发现 <code>AspectJMethodBeforeAdvice#before</code> 方法是被 <code>MethodBeforeAdviceInterceptor#invoke</code> 调用的（通过 idea 的 <code>call Hierarchy</code>），所以根据网上资料推测 <code>MethodInterceptor</code> 的 <code>invoke</code> 方法是直接调用的整个 AOP 流程的，而 <code>AspectJMethodBeforeAdvice</code> 虽然没有实现 <code>MethodInterceptor</code> 但是通过了 <code>MethodBeforeAdviceInterceptor</code> 适配器来适配解决了这个问题。而这二者的适配器分别是 <code>MethodBeforeAdviceAdapter</code>, <code>AfterReturningAdviceAdapter</code>。</p><blockquote><p> 不如我们后面开个 Spring 中的设计模式专题吧？</p></blockquote><p>这里我们后面再说其适配的时机。</p><h4 id="增加同步实例化增强器"><a href="#增加同步实例化增强器" class="headerlink" title="增加同步实例化增强器"></a>增加同步实例化增强器</h4><p>如果寻找的增强器不为空而且又配置了增强延迟初始化，那么就需要在首位加入同步实例增强器。同步实例化增强器 <code>SyntheticInstantiationAdvisor</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntheticInstantiationAdvisor</span> <span class="keyword">extends</span> <span class="title">DefaultPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SyntheticInstantiationAdvisor</span><span class="params">(<span class="keyword">final</span> MetadataAwareAspectInstanceFactory aif)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(aif.getAspectMetadata().getPerClausePointcut(), <span class="keyword">new</span> MethodBeforeAdvice() &#123;</span><br><span class="line">              <span class="comment">// 目标方法前调用，类似 @Before</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Simply instantiate the aspect</span></span><br><span class="line">aif.getAspectInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取-DeclareParents-注解"><a href="#获取-DeclareParents-注解" class="headerlink" title="获取 DeclareParents 注解"></a>获取 <code>DeclareParents</code> 注解</h4><p><code>DeclareParents</code> 主要用于引介增强的注解形式的实现，而其实现方式与普遍增强很类似，只不过使用 <code>DeclareParentsAdvisor</code> 对功能进行封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build a &#123;<span class="doctag">@link</span> org.springframework.aop.aspectj.DeclareParentsAdvisor&#125;</span></span><br><span class="line"><span class="comment"> * for the given introduction field.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Resulting Advisors will need to be evaluated for targets.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> introductionField the field to introspect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> null&#125; if not an Advisor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Advisor <span class="title">getDeclareParentsAdvisor</span><span class="params">(Field introductionField)</span> </span>&#123;</span><br><span class="line">DeclareParents declareParents = introductionField.getAnnotation(DeclareParents.class);</span><br><span class="line"><span class="keyword">if</span> (declareParents == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Not an introduction field</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DeclareParents.class == declareParents.defaultImpl()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"'defaultImpl' attribute must be set on DeclareParents"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DeclareParentsAdvisor(</span><br><span class="line">introductionField.getType(), declareParents.value(), declareParents.defaultImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找匹配的增强器"><a href="#寻找匹配的增强器" class="headerlink" title="寻找匹配的增强器"></a>寻找匹配的增强器</h3><p>前面的函数中已经完成了所有增强器的解析，但是对于所有增强器来讲，并不一定都适用于当前的 Bean，还要挑取适合的增强器，也就是满足我们配置的通配符的增强器。具体实现在 <code>findAdvisorsThatCanApply</code> 中。</p><p>还记得之前说过 <code>AnnotationAwareAspectJAutoProxyCreator</code> 间接继承了 <code>AbstractAdvisorAutoProxyCreator</code>，而 <code>findAdvisorsThatCanApply</code> 就是在 <code>AbstractAdvisorAutoProxyCreator</code> 中被调用的(其调用链可追溯到<code>postProcessAfterInitialization</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Search the given candidate Advisors to find all Advisors that</span></span><br><span class="line"><span class="comment"> * can apply to the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidateAdvisors the candidate Advisors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the target's bean class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the target's bean name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the List of applicable Advisors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ProxyCreationContext#getCurrentProxiedBeanName()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 过滤已经得到的 advisors</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>findAdvisorsThatCanApply</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the sublist of the &#123;<span class="doctag">@code</span> candidateAdvisors&#125; list</span></span><br><span class="line"><span class="comment"> * that is applicable to the given class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> candidateAdvisors the Advisors to evaluate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz the target class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> sublist of Advisors that can apply to an object of the given class</span></span><br><span class="line"><span class="comment"> * (may be the incoming List as-is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">        <span class="comment">// 首先处理引介增强</span></span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">            <span class="comment">// 引介增强已被处理</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">          <span class="comment">// 对于普通 bean 的处理</span></span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>findAdvisorsThatCanApply</code> 函数的主要功能是寻找所有增强器中适用于当前 class 的增强器。引介增强与普通的增强是处理不一样的，所以分开处理。而对于真正的匹配在 <code>canApply</code> 中实现。</p><h3 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h3><p><code>AbstractAutoProxyCreator#createProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an AOP proxy for the given bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment"> * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSource the TargetSource for the proxy,</span></span><br><span class="line"><span class="comment"> * already pre-configured to access the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the AOP proxy for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #buildAdvisors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 获取当前类中相关属性</span></span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">            <span class="comment">// 决定对于给定的 bean 是否应该使用 targetClass 而不是他的接口代理</span></span><br><span class="line">          <span class="comment">// 检查 proxyTargetClass 设置以及 preserveTargetClass 属性</span></span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 添加代理接口</span></span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// 加入增强器</span></span><br><span class="line">proxyFactory.addAdvisor(advisor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置要代理的类</span></span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">        <span class="comment">// 定制代理</span></span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来控制代理工程被配置之后，是否还允许修改通知</span></span><br><span class="line">        <span class="comment">// 缺省值为 false(即在代理被配置之后，不允许修改代理的配置)</span></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于代理类的创建及处理， Spring 委托给了 <code>ProxyFactory</code> 去处理，而在此函数中主要是对 <code>ProxyFactory</code> 的初始化操作，进而对真正的创建代理做准备，这些初始化操作包括如下内容：</p><ol><li>获取当前类的属性</li><li>添加代理接口</li><li>封装 Advisor 并加入到 ProxyFactory 中</li><li>设置要代理的类</li><li>当然在 Spring 中还为子类提供了定制的函数 <code>customizeProxyFactory</code>，子类可以在此函数中进行对 <code>ProxyFactory</code> 的进一步封装</li><li>进行获取代理操作</li></ol><p>其中，封装 Advisor 并加入到 <code>ProxyFactory</code> 中以及创建代理是两个相对繁琐的过程，可以通过 <code>ProxyFactory</code> 提供的 <code>addAdvisor</code> 方法直接将增强器置入代理创建工程中，但是拦截器封装为增强器还是急需要一定的逻辑的。</p><h4 id="封装-Advisor-并加入到-ProxyFactory-中"><a href="#封装-Advisor-并加入到-ProxyFactory-中" class="headerlink" title="封装 Advisor 并加入到 ProxyFactory 中"></a>封装 Advisor 并加入到 ProxyFactory 中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the advisors for the given bean, including the specific interceptors</span></span><br><span class="line"><span class="comment"> * as well as the common interceptor, all adapted to the Advisor interface.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment"> * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the list of Advisors for the given bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Advisor[] buildAdvisors(String beanName, Object[] specificInterceptors) &#123;</span><br><span class="line"><span class="comment">// Handle prototypes correctly...</span></span><br><span class="line">Advisor[] commonInterceptors = resolveInterceptorNames();</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; allInterceptors = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加入拦截器</span></span><br><span class="line">allInterceptors.addAll(Arrays.asList(specificInterceptors));</span><br><span class="line"><span class="keyword">if</span> (commonInterceptors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.applyCommonInterceptorsFirst) &#123;</span><br><span class="line">allInterceptors.addAll(<span class="number">0</span>, Arrays.asList(commonInterceptors));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">allInterceptors.addAll(Arrays.asList(commonInterceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">int</span> nrOfCommonInterceptors = commonInterceptors.length;</span><br><span class="line"><span class="keyword">int</span> nrOfSpecificInterceptors = (specificInterceptors != <span class="keyword">null</span> ? specificInterceptors.length : <span class="number">0</span>);</span><br><span class="line">logger.debug(<span class="string">"Creating implicit proxy for bean '"</span> + beanName + <span class="string">"' with "</span> + nrOfCommonInterceptors +</span><br><span class="line"><span class="string">" common interceptors and "</span> + nrOfSpecificInterceptors + <span class="string">" specific interceptors"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advisor[] advisors = <span class="keyword">new</span> Advisor[allInterceptors.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allInterceptors.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 拦截器进行封装转化为 Advisor</span></span><br><span class="line">advisors[i] = <span class="keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">wrap</span><span class="params">(Object adviceObject)</span> <span class="keyword">throws</span> UnknownAdviceTypeException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果要封装的对象本身就是 Advisor 类型的那么无需再做过多处理</span></span><br><span class="line"><span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) &#123;</span><br><span class="line"><span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 因为此封装方法只对 Advisor 与 Advice 两种类型的数据有效，如果不是将不能封装</span></span><br><span class="line"><span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(adviceObject);</span><br><span class="line">&#125;</span><br><span class="line">Advice advice = (Advice) adviceObject;</span><br><span class="line"><span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line"><span class="comment">// So well-known it doesn't even need an adapter.</span></span><br><span class="line">            <span class="comment">// 如果是 MethodInterceptor 类型则使用 DefaultPointcutAdvisor 封装</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果存在 Advisor 的适配器那么也同样需要进行封装</span></span><br><span class="line"><span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line"><span class="comment">// Check that it is supported.</span></span><br><span class="line"><span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前上文所说的适配器流程便在这里了。</p><p>由于 Spring 中涉及过多的拦截器、增强器、增强方法等方式来对逻辑进行增强，所以非常有必要统一封装成 Advisor 来进行代理的创建，完成了增强的封装过程，那么解析最重要的一步就是代理的创建与获取了。</p><p><code>ProxyFactory#getProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建代理-1"><a href="#创建代理-1" class="headerlink" title="创建代理"></a>创建代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses should call this to get a new AOP proxy. They should &lt;b&gt;not&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * create an AOP proxy with &#123;<span class="doctag">@code</span> this&#125; as an argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="comment">// 见下文描述</span></span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 if 语句可以看出有三个方面影响 Spring 选择 JDKProxy or CglibProxy：</p><ul><li>optimize: 用来控制通过 CGLIB 创建的代理是否使用激进的优化策略。除非完全了解 AOP 代理如何处理优化，否则不推荐用户使用这个设置。目前这个属性仅用于 CGLIB 代理，对于 JDK 动态代理（缺省代理）无效。</li><li>proxyTargetClass：这个属性为 true 时，目标类本身被代理而不是目标类的接口。如果这个属性值被设为 true，CGLIB 代理将被创建，设置方式： <code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;</code></li><li>hasNoUserSuppliedProxyInterfaces: 是否存在代理接口</li></ul><h5 id="对-JDK-与-Cglib-方式的总结"><a href="#对-JDK-与-Cglib-方式的总结" class="headerlink" title="对 JDK 与 Cglib 方式的总结"></a>对 JDK 与 Cglib 方式的总结</h5><ul><li>如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP</li><li>如果目标对象实现了接口，可以强制使用 CGLIB 实现 AOP</li><li>如果目标对象没有实现接口，必须采用 CGLIB 库，Spring 会自动在 JDK 动态代理和 CGLIB 之间转换</li></ul><h6 id="如何强制使用-CGLIB-实现-AOP"><a href="#如何强制使用-CGLIB-实现-AOP" class="headerlink" title="如何强制使用 CGLIB 实现 AOP"></a>如何强制使用 CGLIB 实现 AOP</h6><ol><li>添加 CGLIB 库</li><li>在 Spring 配置文件中加入 <code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;</code></li></ol><h6 id="JDK-动态代理和-CGLIB-字节码生成的区别"><a href="#JDK-动态代理和-CGLIB-字节码生成的区别" class="headerlink" title="JDK 动态代理和 CGLIB 字节码生成的区别"></a>JDK 动态代理和 CGLIB 字节码生成的区别</h6><ul><li>JDK 动态代理只能对实现了接口的类生成代理，而不能针对类</li><li>CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成 final</li></ul><h4 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h4><p>确定了使用哪种代理方式后便可以进行代理的创建了，但是创建之前我们有必要回顾一下两种方式的使用方法。这里可以参考我之前的<a href="https://binglau7.github.io/2017/06/11/AOP%E7%9A%84%E9%81%93%E7%90%86/" target="_blank" rel="noopener">AOP的道理</a>。</p><h5 id="JDK-代理分析"><a href="#JDK-代理分析" class="headerlink" title="JDK 代理分析"></a>JDK 代理分析</h5><p>继续之前的跟踪，可达 <code>JdkDynamicAopProxy#getProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前文章中分析过 JDK 动态代理的关键是创建自定义的 <code>InvocationHandler</code>，而 <code>InvocationHandler</code> 中包含了需要覆盖的函数 <code>getProxy</code>，而当前方法正是完成了这个操作。</p><p>既然<code>JdkDynamicAopProxy</code> 实现了 <code>InvocationHandler</code> 那它肯定有 <code>invoke</code> 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of &#123;<span class="doctag">@code</span> InvocationHandler.invoke&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span></span><br><span class="line"><span class="comment"> * unless a hook method throws an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">MethodInvocation invocation;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// equals 方法的处理</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line"><span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// hash 方法的处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line"><span class="keyword">return</span> hashCode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line"><span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line"><span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// isAssignableFrom(Class cls) 方法如果调用这个方法的 class 或者接口与其参数</span></span><br><span class="line">            <span class="comment">// 表示的类或接口相同或者是参数 cls 表示的类或接口的父类，则返回 true</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line"><span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// May be null. Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line"><span class="comment">// in case it comes from a pool.</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">targetClass = target.getClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">            <span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line"><span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line"><span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line"><span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                 <span class="comment">// 如果拦截器链为空直接调用切点方法</span></span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line">                 <span class="comment">// 将拦截器封装在 ReflectiveMethodInvocation，以便于使用其 proceed </span></span><br><span class="line">                 <span class="comment">// 进行链接表用拦截器</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">                 <span class="comment">// 执行拦截器链</span></span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Massage return value if necessary.</span></span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line"><span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line"><span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line"><span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">retVal = proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line"><span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line"><span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">targetSource.releaseTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line"><span class="comment">// Restore old proxy.</span></span><br><span class="line">AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数中最主要的工作就是创建了一个拦截器链，并使用 <code>ReflectiveMethodInvocation</code> 类进行了链的封装，而在 <code>ReflectiveMethodInvocation</code> 类的 <code>proceed</code> 方法中实现了拦截器的逐一调用，那么我们继续来探究，在 <code>proceed</code> 方法中是怎么实现前置增强的目标方法前调用后置增强在目标方法后调用的逻辑呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//We start with an index of -1 and increment early.</span></span><br><span class="line">        <span class="comment">// 执行完所有增强后执行切点方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下一个要执行的拦截器</span></span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line"><span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line"><span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line"><span class="comment">// been evaluated and found to match.</span></span><br><span class="line">            <span class="comment">// 动态匹配</span></span><br><span class="line">InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line"><span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line"><span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Dynamic matching failed.</span></span><br><span class="line"><span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">                 <span class="comment">// 不匹配则不执行拦截器</span></span><br><span class="line"><span class="keyword">return</span> proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line"><span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 普通拦截器，直接调用拦截器，比如：</span></span><br><span class="line"><span class="comment">            * ExposeInvocationInterceptor</span></span><br><span class="line"><span class="comment">            * DelegatePerTargetObjectIntroductionInterceptor,</span></span><br><span class="line"><span class="comment">            * MethodBeforeAdviceInterceptor</span></span><br><span class="line"><span class="comment">            * AspectJAroundAdvice</span></span><br><span class="line"><span class="comment">            * AspectJAfterAdvice</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="comment">// 将 this 作为参数传递以保证当前实例中调用链的执行</span></span><br><span class="line"><span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectiveMethodInvocation</code> 中的主要职责是维护了链接调用的计数器，记录着当前调用链接的位置，以便链可以有序地进行下去，那么在这个方法中并没有我们之前设想的维护各种增强的顺序，而是将此工作委托给了各个增强器，使各个增强器在内部进行逻辑实现。</p><h5 id="CGLIB-代理分析"><a href="#CGLIB-代理分析" class="headerlink" title="CGLIB 代理分析"></a>CGLIB 代理分析</h5><p>我们参考上述知道其入口也是在 getProxy 方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating CGLIB proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line"><span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">            <span class="comment">// 验证 class</span></span><br><span class="line">validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">            <span class="comment">// 配置及设置 Enhancer</span></span><br><span class="line">Enhancer enhancer = createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">enhancer.setClassLoader(classLoader);</span><br><span class="line"><span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置拦截器</span></span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line"><span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line"><span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (CodeGenerationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line"><span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line"><span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line"><span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line"><span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类以及创建代理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line">enhancer.setCallbacks(callbacks);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> ?</span><br><span class="line">enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span><br><span class="line">enhancer.create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数完整地阐述了一个创建 Spring 中的 Enhancer 的过程，这里最重要的是通过 getCallbacks 方法设置拦截器链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// Parameters used for optimization choices...</span></span><br><span class="line"><span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</span><br><span class="line"><span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</span><br><span class="line"><span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Choose an "aop" interceptor (used for AOP calls).</span></span><br><span class="line">        <span class="comment">// 将拦截器封装在 DynamicAdvisedInterceptor</span></span><br><span class="line">Callback aopInterceptor = <span class="keyword">new</span> DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Choose a "straight to target" interceptor. (used for calls that are</span></span><br><span class="line"><span class="comment">// unadvised but can return this). May be required to expose the proxy.</span></span><br><span class="line">Callback targetInterceptor;</span><br><span class="line"><span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">targetInterceptor = isStatic ?</span><br><span class="line"><span class="keyword">new</span> StaticUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line"><span class="keyword">new</span> DynamicUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">targetInterceptor = isStatic ?</span><br><span class="line"><span class="keyword">new</span> StaticUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line"><span class="keyword">new</span> DynamicUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Choose a "direct to target" dispatcher (used for</span></span><br><span class="line"><span class="comment">// unadvised calls to static targets that cannot return this).</span></span><br><span class="line">Callback targetDispatcher = isStatic ?</span><br><span class="line"><span class="keyword">new</span> StaticDispatcher(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) : <span class="keyword">new</span> SerializableNoOp();</span><br><span class="line"></span><br><span class="line">Callback[] mainCallbacks = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">                 <span class="comment">// 将拦截器链加入 Callback 中</span></span><br><span class="line">aopInterceptor,  <span class="comment">// for normal advice</span></span><br><span class="line">targetInterceptor,  <span class="comment">// invoke target without considering advice, if optimized</span></span><br><span class="line"><span class="keyword">new</span> SerializableNoOp(),  <span class="comment">// no override for methods mapped to this</span></span><br><span class="line">targetDispatcher, <span class="keyword">this</span>.advisedDispatcher,</span><br><span class="line"><span class="keyword">new</span> EqualsInterceptor(<span class="keyword">this</span>.advised),</span><br><span class="line"><span class="keyword">new</span> HashCodeInterceptor(<span class="keyword">this</span>.advised)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Callback[] callbacks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the target is a static one and the advice chain is frozen,</span></span><br><span class="line"><span class="comment">// then we can make some optimizations by sending the AOP calls</span></span><br><span class="line"><span class="comment">// direct to the target using the fixed chain for that method.</span></span><br><span class="line"><span class="keyword">if</span> (isStatic &amp;&amp; isFrozen) &#123;</span><br><span class="line">Method[] methods = rootClass.getMethods();</span><br><span class="line">Callback[] fixedCallbacks = <span class="keyword">new</span> Callback[methods.length];</span><br><span class="line"><span class="keyword">this</span>.fixedInterceptorMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(methods.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> small memory optimization here (can skip creation for methods with no advice)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; methods.length; x++) &#123;</span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</span><br><span class="line">fixedCallbacks[x] = <span class="keyword">new</span> FixedChainStaticTargetInterceptor(</span><br><span class="line">chain, <span class="keyword">this</span>.advised.getTargetSource().getTarget(), <span class="keyword">this</span>.advised.getTargetClass());</span><br><span class="line"><span class="keyword">this</span>.fixedInterceptorMap.put(methods[x].toString(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now copy both the callbacks from mainCallbacks</span></span><br><span class="line"><span class="comment">// and fixedCallbacks into the callbacks array.</span></span><br><span class="line">callbacks = <span class="keyword">new</span> Callback[mainCallbacks.length + fixedCallbacks.length];</span><br><span class="line">System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</span><br><span class="line">System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</span><br><span class="line"><span class="keyword">this</span>.fixedInterceptorOffset = mainCallbacks.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">callbacks = mainCallbacks;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getCallback 中 Spring 考虑了很多情况，但是对于我们来说，只需要理解最常用的就可以了，比如将 advised 属性封装在 <code>DynamicAdvisedInterceptor</code> 并加入在 callbacks 中，这么做的目的是什么呢？然后调用呢?</p><p>就我们所知，CGLIB 对于方法的拦截是通过将自定义的拦截器（实现 <code>MethodInterceptor</code> 接口）加入 Callback 中并在调用代理时直接激活拦截器中的 intercept 方法来实现的，那么在 getCallback 中正式实现了这样一个目的，<code>DynamicAdvisedInterceptor</code> 继承自 <code>MethodInterceptor</code> ，加入 Callback 中后，在再次调用代理时会直接调用 <code>DynamicAdvisedInterceptor</code> 中的 intercept 方法，由此推断，对于 CGLIB 方式实现的代理，其核心逻辑必然在 <code>DynamicAdvisedInterceptor</code> 中的 <code>intercept</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// May be null. Get as late as possible to minimize the time we</span></span><br><span class="line"><span class="comment">// "own" the target, in case it comes from a pool...</span></span><br><span class="line">target = getTarget();</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">targetClass = target.getClass();</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">// 获取拦截器链</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">Object retVal;</span><br><span class="line"><span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line"><span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line"><span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line"><span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line"><span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line"><span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">                    <span class="comment">// 如果拦截器链为空则直接激活原方法</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line">                    <span class="comment">// 进入链</span></span><br><span class="line">retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">&#125;</span><br><span class="line">retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">releaseTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line"><span class="comment">// Restore old proxy.</span></span><br><span class="line">AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现与 JDK 方式实现代理中的 invoke 方法大同小异，首先是构造链，然后封装此链进行串联调用，稍有区别的是 JDK 中直接构建 <code>ReflectiveMethodInvocation</code> ，而再 cglib 中使用 <code>CglibMethodInvocation</code> 。<code>CglibMethodInvocation</code> 继承自 <code>ReflectiveMethodInvocation</code>，但是 <code>proceed</code> 方法并没有重写。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态-AOP-使用示例&quot;&gt;&lt;a href=&quot;#动态-AOP-使用示例&quot; class=&quot;headerlink&quot; title=&quot;动态 AOP 使用示例&quot;&gt;&lt;/a&gt;动态 AOP 使用示例&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建用于拦截的 bean&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestBean&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String testStr = &lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建 Advisor&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AspectJTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Pointcut&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;execution(* *.test(..))&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Before&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;test()&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;beforeTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;beforeTest&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@After&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;test()&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;afterTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;afterTest&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Around&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;test()&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;aroundTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ProceedingJoinPoint p)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;brfore around&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object o = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            o = p.proceed();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;after around&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建配置文件&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;aop:aspectj-autoproxy&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;testBean&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;io.github.binglau.bean.TestBean&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;io.github.binglau.AspectJTest&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testAop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ApplicationContext ctx = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span class=&quot;string&quot;&gt;&quot;beanFactory.xml&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TestBean bean = (TestBean) ctx.getBean(&lt;span class=&quot;string&quot;&gt;&quot;testBean&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bean.test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不出意外结果&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brfore around&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beforeTest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;after around&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;afterTest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可知 &lt;code&gt;&amp;lt;aop:aspectj-autoproxy /&amp;gt;&lt;/code&gt; 是开启 aop 的关键，我们不妨由此入手。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kafka生产者分析——KafkaProducer</title>
    <link href="http://yoursite.com/2017/12/18/Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E5%88%86%E6%9E%90%E2%80%94%E2%80%94KafkaProducer/"/>
    <id>http://yoursite.com/2017/12/18/Kafka生产者分析——KafkaProducer/</id>
    <published>2017-12-18T14:15:26.000Z</published>
    <updated>2017-12-18T14:20:08.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 文章参考自《Apache  Kafka 源码剖析》</p><p> github 地址：<a href="https://github.com/BingLau7/kafka，里面有代码的相关注释" target="_blank" rel="noopener">https://github.com/BingLau7/kafka，里面有代码的相关注释</a></p><p> 具体部署方式不进行指导了，网上资料比较多</p></blockquote><h2 id="KafkaProducer-Demo"><a href="#KafkaProducer-Demo" class="headerlink" title="KafkaProducer Demo"></a>KafkaProducer Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isAsync = args.length == <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">/* 消息的发送方式：异步发送还是同步发送 */</span></span><br><span class="line">                !args[<span class="number">0</span>].trim().equalsIgnoreCase(<span class="string">"sync"</span>);</span><br><span class="line"></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        <span class="comment">/* 客户端的 ID */</span></span><br><span class="line">        props.put(<span class="string">"client.id"</span>, <span class="string">"DemoProducer"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 消息的 key 和 value 都是字节数组，为了将 Java 对象转化为字节数组，可以配置</span></span><br><span class="line"><span class="comment">        * "key.serializer" 和 "value.serializer" 两个序列化器，完成转化</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.IntegerSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* StringSerializer 用来将 String 对象序列化成字节数组 */</span></span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 生产者的核心类 */</span></span><br><span class="line">        KafkaProducer producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 向指定的 test 这个 topic 发送消息 */</span></span><br><span class="line">        String topic = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 消息的 key */</span></span><br><span class="line">        <span class="keyword">int</span> messageNo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String messageStr = <span class="string">"Message_"</span> + messageNo;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isAsync) &#123; <span class="comment">/* 异步发送消息 */</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                *  第一个参数是 ProducerRecord 类型的对象，封装了目标 Topic，消息的 kv</span></span><br><span class="line"><span class="comment">                *  第二个参数是一个 CallBack 对象，当生产者接收到 Kafka 发来的 ACK 确认消息的时候，</span></span><br><span class="line"><span class="comment">                *  会调用此 CallBack 对象的 onCompletion() 方法，实现回调功能</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, messageNo, messageStr),</span><br><span class="line">                        <span class="keyword">new</span> DemoCallBack(startTime, messageNo, messageStr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 同步发送消息 */</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * KafkaProducer.send() 方法的返回值类型是 Future&lt;RecordMetadata&gt;</span></span><br><span class="line"><span class="comment">                    * 这里通过 Future.get 方法，阻塞当前线程，等待 Kafka 服务端的 ACK 响应</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, messageNo, messageStr)).get();</span><br><span class="line">                    System.out.printf(<span class="string">"Send message: (%d, %s)\n"</span>, messageNo, messageStr);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 递增消息的 key */</span></span><br><span class="line">            ++messageNo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoCallBack</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 开始发送消息的时间戳 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoCallBack</span><span class="params">(<span class="keyword">long</span> startTime, <span class="keyword">int</span> key, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者成功发送消息，收到 Kafka 服务端发来的 ACK 确认消息后，会调用此回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata 生产者发送的消息的元数据，如果发送过程中出现异常，此参数为 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception 发送过程中出现的异常，如果发送成功为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"message: (%d, %s) send to partition %d, offset: %d, in %d\n"</span>,</span><br><span class="line">                    key, message, metadata.partition(), metadata.offset(), elapsedTime);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="KafkaProducer-分析"><a href="#KafkaProducer-分析" class="headerlink" title="KafkaProducer 分析"></a>KafkaProducer 分析</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_42/Kafka.png?raw=true" alt="KafkaProducer流程"></p><p>上图是一个  KafkaProducer 在发送消息的整个流程，我们就上面来进行一个宏观的了解：</p><ol><li>ProducerInterceptors 对消息进行拦截</li><li>Serializer 对消息的 key 和 value 进行序列化</li><li>Partitioner 为消息选择合适的 Partition</li><li>RecordAccumulator 收集消息，实现批量发送</li><li>Sender 从 RecordAccumulator 获取消息</li><li>构造 ClientRequest</li><li>将 ClientRequest 交给 NetworkClient，准备发送</li><li>NetworkClient 将请求放入 KafkaChannel 的缓存</li><li>执行网络 I/O，发送请求</li><li>收到响应，调用 ClientRequest 的回调函数</li><li>调用  RecordBatch 的回调函数，最终调用每个消息上注册的回调函数</li></ol><p>消息发送的过程中，涉及两个线程协同工作。主线程首先将业务数据封装或 ProducerRecord 对象，之后调用 <code>send()</code> 方法将消息放入 RecordAccummulator (消息收集器，也可以理解为主线程与 Sender 线程之间的缓冲区)中暂存。Sender 线程负责将消息信息构成请求，并最终执行网络 I/O 的线程，它从 RecordAccumulator 中取出消息并批量发送出去。需要注意的是，KafkaProducer 是线程安全的，多个线程间可以共享使用同一个 KafkaProucer 对象。</p><p>KafkaProducer 实现了 Producer 接口，在 Producer 接口中定义 KafkaProducer 对外提供的 API，分为四类方法：</p><ul><li><code>send()</code> 方法：发送消息，实际是将消息放入 RecordAccumulator 暂存，等待发送</li><li><code>flush()</code> 方法：刷新操作，等待 RecordAccumulator 中所有消息发送完成，在刷新之前就会阻塞调用的线程</li><li><code>partitionsFor()</code> 方法：在 KafkaProducer 中维护了一个 Metadata 对象用于存储 Kafka 集群的元素局，Metadata 中的元素局会定时更新。<code>partitionsFor()</code> 方法负责从 Metadata 中获取指定 Topic 中的分区信息。</li><li><code>close()</code> 方法：关闭此 Producer 对象，主要操作是设置 close 壁纸，等待 <code>RecordAccumulator</code> 中的消息清空，关闭 Sender 线程。</li></ul><h3 id="KafkaProducer-重要字段"><a href="#KafkaProducer-重要字段" class="headerlink" title="KafkaProducer 重要字段"></a>KafkaProducer 重要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clientId 的生成器，如果没有明确指定 client 的 id，则使用字段生成一个 ID */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger PRODUCER_CLIENT_ID_SEQUENCE = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 此生产者的唯一标识 */</span></span><br><span class="line"><span class="keyword">private</span> String clientId;</span><br><span class="line"><span class="comment">/* 分区选择器，根据一定的策略，将消息路由到合适的分区 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Partitioner partitioner;</span><br><span class="line"><span class="comment">/* 消息的最大长度，这个长度包含了消息头、序列化后的 key 和序列化后的 value 的长度 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxRequestSize;</span><br><span class="line"><span class="comment">/* 发送单个消息的缓冲区大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> totalMemorySize;</span><br><span class="line"><span class="comment">/* 存储 Kafka 集群的元数据 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Metadata metadata;</span><br><span class="line"><span class="comment">/* RecordAccumulator，用于手机并缓存消息，等待 Sender 线程发送 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RecordAccumulator accumulator;</span><br><span class="line"><span class="comment">/* 发送消息的 Sender 任务，实现了 Runnable 接口，在 ioThread 线程中执行 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sender sender;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Metrics metrics;</span><br><span class="line"><span class="comment">/* 执行 Sender 任务发送消息的线程，称为 『Sender 线程』 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Thread ioThread;</span><br><span class="line"><span class="comment">/* 压缩算法，可选项有 none、gzip、snappy、lz4.</span></span><br><span class="line"><span class="comment">* 这是针对 RecordAccumulator 中多条消息进行的压缩，所以消息越多，压缩效果越好 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CompressionType compressionType;</span><br><span class="line"><span class="comment">/* key 的序列化器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Serializer&lt;K&gt; keySerializer;</span><br><span class="line"><span class="comment">/* value 的序列化器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Serializer&lt;V&gt; valueSerializer;</span><br><span class="line"><span class="comment">/* 配置对象，使用反射初始化 KafkaProducer 配置的相对对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProducerConfig producerConfig;</span><br><span class="line"><span class="comment">/* 等待更新 Kafka 集群元数据的最大时长 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxBlockTimeMs;</span><br><span class="line"><span class="comment">/* 消息的超时时间，也就是从消息发送到收到 ACK 响应的最长时长 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> requestTimeoutMs;</span><br><span class="line"><span class="comment">/* ProducerInterceptor 集合，ProducerInterceptor 可以在消息发送之前对其进行拦截或修改；</span></span><br><span class="line"><span class="comment">* 也可以先于用户的 Callback，对 ACK 响应进行预处理 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProducerInterceptors&lt;K, V&gt; interceptors;</span><br></pre></td></tr></table></figure><p>在 KafkaProducer 的构造函数中，会初始化上面介绍的字段，其中有几个需要注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">KafkaProducer</span><span class="params">(ProducerConfig config, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">....</span><br><span class="line">         <span class="comment">/* 通过反色机制实例化配置的 partitioner 类，keySerializer 类，valueSerializer 类 */</span></span><br><span class="line">         <span class="keyword">this</span>.partitioner = config.getConfiguredInstance(ProducerConfig.PARTITIONER_CLASS_CONFIG, Partitioner.class);</span><br><span class="line">         <span class="keyword">long</span> retryBackoffMs = config.getLong(ProducerConfig.RETRY_BACKOFF_MS_CONFIG);</span><br><span class="line">         <span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">this</span>.keySerializer = config.getConfiguredInstance(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                     Serializer.class);</span><br><span class="line">             <span class="keyword">this</span>.keySerializer.configure(config.originals(), <span class="keyword">true</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             config.ignore(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG);</span><br><span class="line">             <span class="keyword">this</span>.keySerializer = keySerializer;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">this</span>.valueSerializer = config.getConfiguredInstance(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                     Serializer.class);</span><br><span class="line">             <span class="keyword">this</span>.valueSerializer.configure(config.originals(), <span class="keyword">false</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             config.ignore(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG);</span><br><span class="line">             <span class="keyword">this</span>.valueSerializer = valueSerializer;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// 创建并更新 Kafka 集群的元数据</span></span><br><span class="line">         <span class="keyword">this</span>.metadata = <span class="keyword">new</span> Metadata(retryBackoffMs, config.getLong(ProducerConfig.METADATA_MAX_AGE_CONFIG), <span class="keyword">true</span>, clusterResourceListeners);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 创建 RecordAccumulator */</span></span><br><span class="line">         <span class="keyword">this</span>.accumulator = <span class="keyword">new</span> RecordAccumulator(config.getInt(ProducerConfig.BATCH_SIZE_CONFIG),</span><br><span class="line">                 <span class="keyword">this</span>.totalMemorySize,</span><br><span class="line">                 <span class="keyword">this</span>.compressionType,</span><br><span class="line">                 config.getLong(ProducerConfig.LINGER_MS_CONFIG),</span><br><span class="line">                 retryBackoffMs,</span><br><span class="line">                 metrics,</span><br><span class="line">                 time);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">         <span class="comment">/* 创建 NetworkClient，这个是 KafkaProducer 网络 I/O 的核心，在后面会详细介绍 */</span></span><br><span class="line">         NetworkClient client = <span class="keyword">new</span> NetworkClient(</span><br><span class="line">                 <span class="keyword">new</span> Selector(config.getLong(ProducerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG), <span class="keyword">this</span>.metrics, time, <span class="string">"producer"</span>, channelBuilder),</span><br><span class="line">                 <span class="keyword">this</span>.metadata,</span><br><span class="line">                 clientId,</span><br><span class="line">                 config.getInt(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION),</span><br><span class="line">                 config.getLong(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG),</span><br><span class="line">                 config.getInt(ProducerConfig.SEND_BUFFER_CONFIG),</span><br><span class="line">                 config.getInt(ProducerConfig.RECEIVE_BUFFER_CONFIG),</span><br><span class="line">                 <span class="keyword">this</span>.requestTimeoutMs, time);</span><br><span class="line">  ...</span><br><span class="line">         String ioThreadName = <span class="string">"kafka-producer-network-thread"</span> + (clientId.length() &gt; <span class="number">0</span> ? <span class="string">" | "</span> + clientId : <span class="string">""</span>);</span><br><span class="line">         <span class="comment">/* 启动 Sender 对应的线程 */</span></span><br><span class="line">         <span class="keyword">this</span>.ioThread = <span class="keyword">new</span> KafkaThread(ioThreadName, <span class="keyword">this</span>.sender, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">this</span>.ioThread.start();</span><br><span class="line">         ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KafkaProducer 构造完成之后，我们来关注 KafkaProducer 的 <code>send()</code> 方法</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_42/KafkaProducer%23send(" alt="send方法流程图">.png?raw=true)</p><p>图中关键步骤:</p><ul><li>调用 <code>ProducerInterceptors.onSend()</code> 方法，通过 <code>ProducerInterceptor</code> 对 消息进行拦截或修改</li><li>调用 <code>watiOnMetadata()</code> 方法获取 Kafka 集群的信息，底层会唤醒 Send 线程更新 Metadata 中保存的 Kafka 集群元数据</li><li>调用 <code>Serializer.serialize()</code> 方法序列号消息的 key 和 value</li><li>调用 <code>partition()</code> 为消息选择合适的分区</li><li>调用 <code>RecordAccumulator.append()</code> 方法，将消息追加到 <code>RecordAccumulator</code> 中</li><li>唤醒 <code>Sender</code> 线程将 <code>RecordAccumulator</code> 中缓存的消息发送出去</li></ul><h3 id="ProducerInterceptors-amp-ProducerInterceptor"><a href="#ProducerInterceptors-amp-ProducerInterceptor" class="headerlink" title="ProducerInterceptors&amp;ProducerInterceptor"></a><code>ProducerInterceptors&amp;ProducerInterceptor</code></h3><p><code>ProducerInterceptors</code> 是一个 <code>ProducerInterceptor</code> 的集合，其 <code>onSend</code> 方法、<code>onAcknowledgement</code> 方法、<code>onSendError</code> 方法，实际上是循环调用其封装的 <code>ProducerInterceptor</code> 集合的对应方法。</p><p><code>ProducerIntercepto</code> 对象可以在消息发送之前对其进行拦截或修改，也可以先于用户的 Callback，对 ACK 响应进行预处理。如果要使用自定义 <code>ProducerInterceptor</code> 类，只要实现 <code>ProducerInterceptor</code> 接口，创建其对象并添加到 <code>ProducerInterceptors</code> 中即可。</p><h3 id="Kafka-集群元数据"><a href="#Kafka-集群元数据" class="headerlink" title="Kafka 集群元数据"></a>Kafka 集群元数据</h3><p>Kafka 中每个 Topic 中有个多个分区，这些分区的 Leader 副本可以分配在集群中不同的 Broker 上。在运行过程中，Leader 副本随时都可能出现故障而导致 Leader 副本重新选举，新的 Leader 副本会在其他 Broker 上继续提供对外服务，所以由于种种原因分区的数量以及 Leader 副本的分布是动态变化的。当需要提高某 Topic 的并发处理消息能力时，我们可以通过增加其分区的数量来实现。</p><p>在 KafkaProducer 中，使用 Node、TopicPartition、PartitionInfo 这三个类封装了 Kafka 集群的相关元数据，其主要字段：</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_42/Node&amp;TopicPartition&amp;PartitionInfo.jpg?raw=true" alt="Node&amp;TopicPartition&amp;PartitionInfo"></p><ul><li>Node 表示集群中的一个节点，Node 记录这个节点的 host、ip、port等新兴</li><li>TopicPartition 表示某个 Topic 的一个分区，其中的 topic 字段是 Topic 的名称，partition 则是该分区编号(ID)</li><li>PartitionInfo 表示一个分区的详细信息</li></ul><p>通过这三个类的组合，我们可以完整表示出 KafkaProducer 需要的集群元数据。这些元数据保存在 <code>Cluster</code> 这个类中，并按照不同的映射方式进行存放，方便查询。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_42/Cluster.jpg?raw=true" alt="Cluster"></p><ul><li>nodes: Kafka 集群中节点信息列表</li><li>nodesById：BrokerId 与 Node 节点之间对应关系，方便按照 BrokerId 进行索引</li><li>partitionsByTopicPartition：记录了 TopicPartition 与 PartitionInfo 之间的映射关系</li><li>partitionsByTopic：记录了 Topic 名称和 PartitionInfo 的映射关系，可以按照 Topic 名称查询其中全部分区的详细信息。</li><li>avaliablePartitionByTopic：Topic 与 PartitionInfo 的映射关系，这里的  <code>List&lt;PartitionInfo&gt;</code> 中存放的分区必须是有 Leader 副本的 Partition，而 partitionByTopic 中记录的分区则不一定有 Leader 副本，因为某些中间状态。</li><li>partitionsByNode: 记录了 Node 与 PartitionInfo 的映射关系，可以按照节点 Id 查询其上分布的全部分区的详细信息。</li></ul><p>Metadata 中封装了 Cluster 对象，并保持 Cluster 数据的最后更新时间、版本号（version）、是否需要更新等待信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Metadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Metadata.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TOPIC_EXPIRY_MS = <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TOPIC_EXPIRY_NEEDS_UPDATE = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 两次发出更新 Cluster 保存的元数据信息的最小时间差，默认为 100ms。防止更新操作过于频繁而造成</span></span><br><span class="line"><span class="comment">     * 网络阻塞和增加服务端压力。在 Kafka 中与重试操作有关的操作中，都有这种『退避(backoff)时间』</span></span><br><span class="line"><span class="comment">     * 设计的身影 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> refreshBackoffMs;</span><br><span class="line">    <span class="comment">/* 每隔多久更新一次 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> metadataExpireMs;</span><br><span class="line">    <span class="comment">/* 表示 Kafka 集群元数据的版本号。Kafka 集群元数据每更新成功一次，version++ */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="comment">/* 记录上次更新元数据的时间戳（也包含更新失败的情况） */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastRefreshMs;</span><br><span class="line">    <span class="comment">/* 上一次成功更新的时间戳 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastSuccessfulRefreshMs;</span><br><span class="line">    <span class="comment">/* 记录 Kafka 集群的元数据 */</span></span><br><span class="line">    <span class="keyword">private</span> Cluster cluster;</span><br><span class="line">    <span class="comment">/* 标识是否强制更新 Cluster，这是触发 Sender 线程更新集群元数据的条件之一 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needUpdate;</span><br><span class="line">    <span class="comment">/* Topics with expiry time */</span></span><br><span class="line">    <span class="comment">/* 记录了当前已知的所有 topic，在 cluster 字段中记录了 Topic 最新的元数据，并记录了其数据对应的过期时间 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Long&gt; topics;</span><br><span class="line">    <span class="comment">/* 监听 Metadata 更新的监听器集合。自定义 Metadata 监听实现 MetadataListener.onMetadataUpdate()</span></span><br><span class="line"><span class="comment">    * 方法即可，在更新 Metadata 中的 cluster 字段之前，会通知 listener 集合中全部 Listener 对象*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Listener&gt; listeners;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResourceListeners clusterResourceListeners;</span><br><span class="line">    <span class="comment">/* 是否需要更新全部 Topic 的元数据，一般情况下 KafkaProducer 只维护它用到的 Topic 的元数据，</span></span><br><span class="line"><span class="comment">     * 是集群中全部 Topic 的子集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needMetadataForAllTopics;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> topicExpiryEnabled;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Metadata 的方法比较简单，主要是操纵上面的几个字段，这里着重介绍主线程中使用到的 <code>requestUpdate()</code> 和 <code>awaitUpdate()</code> 方法。</p><ul><li><p><code>requestUpdate()</code> 方法将 <code>needUpdate</code> 字段修改为 <code>true</code> ，这样当 Sender 线程运行时更新 Metadata 记录的集群元数据，然后返回 version 字段的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">requestUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.needUpdate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p><code>awaitUpdate()</code> 方法主要是通过 version 版本号来判断元数据是否更新完成，更新为完成则阻塞等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">awaitUpdate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> lastVersion, <span class="keyword">final</span> <span class="keyword">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxWaitMs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Max time to wait for metadata updates should not be &lt; 0 milli seconds"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> remainingWaitMs = maxWaitMs;</span><br><span class="line">    <span class="comment">/* 比较版本号，通过版本号比较集群元数据是否更新完成 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.version &lt;= lastVersion) &#123;</span><br><span class="line">        <span class="comment">/* 主线程与 Sender 通过 wait/notify 同步，更新元数据的操作则交给 Sender 线程去完成 */</span></span><br><span class="line">        <span class="keyword">if</span> (remainingWaitMs != <span class="number">0</span>)</span><br><span class="line">            wait(remainingWaitMs);</span><br><span class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - begin;</span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);</span><br><span class="line">        remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，Metadata 中的字段可以由主线程读，Sedner 线程更新，因此它必须是线程安全的，这也是上面为什么所有方法都使用 synchronized 同步的原因。</p><p>下面介绍 <code>KafkaProducer.waitOnMetadta()</code> 方法(<code>KafkaProducer#doSend调用</code>)，它负责触发 Kafka 集群元数据的更新，并阻塞主线程等等更新完毕。它的主要步骤是：</p><ol><li>直接添加 topic 进入 metadata 中，如果已经存在则更新其过期时间</li><li>尝试获取 Topic 中分区的详细信息，失败后会调用 <code>requestUpdate()</code> 方法设置 <code>Metadata.needUpdate</code> 字段，并得到当前元数据版本号</li><li>唤醒 Sender 线程，由 Sender 线程更新 Metadata 中保存的 Kafka 集群元数据。</li><li>主线程调用 <code>awaitUpdate()</code> 方法，等待 Sender 线程完成更新</li><li>从 Metadata 中获取指定 Topic 分区的详细信息（即 PartitionInfo 集合）。若失败，则回到步骤2继续尝试，若等待时间超时，则抛出异常。</li></ol><p>其具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClusterAndWaitTime <span class="title">waitOnMetadata</span><span class="params">(String topic, Integer partition, <span class="keyword">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// add topic to metadata topic list if it is not there already and reset expiry</span></span><br><span class="line">    metadata.add(topic);</span><br><span class="line">    <span class="comment">/* 获取分区信息 */</span></span><br><span class="line">    Cluster cluster = metadata.fetch();</span><br><span class="line">    Integer partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">    <span class="comment">// Return cached metadata if we have it, and if the record's partition is either undefined</span></span><br><span class="line">    <span class="comment">// or within the known partition range</span></span><br><span class="line">    <span class="keyword">if</span> (partitionsCount != <span class="keyword">null</span> &amp;&amp; (partition == <span class="keyword">null</span> || partition &lt; partitionsCount))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = time.milliseconds();</span><br><span class="line">    <span class="keyword">long</span> remainingWaitMs = maxWaitMs;</span><br><span class="line">    <span class="keyword">long</span> elapsed;</span><br><span class="line">    <span class="comment">// Issue metadata requests until we have metadata for the topic or maxWaitTimeMs is exceeded.</span></span><br><span class="line">    <span class="comment">// In case we already have cached metadata for the topic, but the requested partition is greater</span></span><br><span class="line">    <span class="comment">// than expected, issue an update request only once. This is necessary in case the metadata</span></span><br><span class="line">    <span class="comment">// is stale and the number of partitions for this topic has increased in the meantime.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        log.trace(<span class="string">"Requesting metadata update for topic &#123;&#125;."</span>, topic);</span><br><span class="line">        <span class="comment">/* 获取失败之后调用 requestUpdate() 方法，并获取当前元数据版本号 */</span></span><br><span class="line">        <span class="keyword">int</span> version = metadata.requestUpdate();</span><br><span class="line">        <span class="comment">/* 唤醒 Sender 线程 */</span></span><br><span class="line">        sender.wakeup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* 阻塞等待元数据更新完毕 */</span></span><br><span class="line">            metadata.awaitUpdate(version, remainingWaitMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException ex) &#123;</span><br><span class="line">            <span class="comment">// Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cluster = metadata.fetch();</span><br><span class="line">        elapsed = time.milliseconds() - begin;</span><br><span class="line">        <span class="comment">/* 检测超时时间 */</span></span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);</span><br><span class="line">        <span class="comment">/* 检测权限 */</span></span><br><span class="line">        <span class="keyword">if</span> (cluster.unauthorizedTopics().contains(topic))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TopicAuthorizationException(topic);</span><br><span class="line">        remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">        partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">    &#125; <span class="keyword">while</span> (partitionsCount == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partition != <span class="keyword">null</span> &amp;&amp; partition &gt;= partitionsCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(</span><br><span class="line">                String.format(<span class="string">"Invalid partition given with record: %d is not in the range [0...%d)."</span>, partition, partitionsCount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, elapsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serializer-amp-Deserializer"><a href="#Serializer-amp-Deserializer" class="headerlink" title="Serializer&amp;Deserializer"></a><code>Serializer&amp;Deserializer</code></h3><p>客户端发送的消息的 key 和 value 都是 byte 数组， <code>Serializer</code> 和 <code>Deserializer</code> 接口提供了将 Java 对象序列号（反序列化）为 byte 数组的功能。在 KafkaProducer 中，根据配置文件，使用合适的 <code>Serializer</code> 。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_42/implementSerializer.jpg?raw=true" alt="ImplementSerializer"> </p></li></ul><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_42/implementDeserializer.jpg?raw=true" alt="ImplementDeserializer"></p><p>Kafka 已经为我们提供了 Java 基本类型的 Serializer 实现和 Deserializer 实现，我们也可以对 Java 复杂类型的自定义 Serializer 和 Deserializer 实现。</p><p>在 Serializer 接口中， <code>configure()</code> 方法是在执行序列化操作之前的配置，例如，在 <code>StringSerializer.configure()</code> 方法中会选择合适的编码（encoding），默认是 UTF-8；<code>serializer()</code> 方法是真正进行序列化的地方，将传入的 Java 对象序列化为 byte[]。<code>close()</code> 方法是在其后的关闭方法，多为空实现。</p><h3 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h3><p><code>KafkaProducer.send()</code> 方法的下一步操作是选择消息的分区。在有的应用场景中，由业务逻辑控制每个消息追加到合适的分区中，而有时候业务逻辑并不关心分区的选择。在 <code>KafkaProducer.partition()</code> 方法中，优先根据 <code>ProducerRecord</code> 中 <code>partition</code> 字段指定的序号选择分区，如果 <code>ProducerRecord.partition</code> 字段没有明确指定分区编号，则通过 <code>Partitioner.partition()</code> 方法选择 partition。</p><p>Kafka 提供了 Partitioner 接口的一个默认实现 <code>DefaultPartitioner</code></p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_42/DefaultPartitioner.jpg?raw=true" alt="DefaultPartitioner"></p><p>可以看到，之前介绍的 <code>ProducerInterceptor</code> 接口也继承了 <code>Configurable</code> 接口。</p><p>在创建 KafkaProducer 时传入的 key/value 配置项会保存到 <code>AbstractConfig</code> 的 <code>originals</code> 字段中，<code>AbstractConfig</code> 的核心方法是 <code>getConfiguredInstance()</code> 方法，其主要功能是通过反射机制实例化 <code>originals</code> 字段中指定的类。</p><p>设计 <code>Configurable</code> 接口的<strong>目的是统一反射后的初始化过程</strong>，对外提供同意的初始化接口。在 <code>AbstractConfig.getConfiguredInstance</code> 方法中通过反射构造出来的对象，都是通过无参构造函数构造成功的，需要初始化的字段个数和类型各式各样， <code>Configurable</code> 接口的 <code>configure()</code> 方法封装了对象初始化过程且只有一个参数 （<code>originals</code>）字段，这样对外的接口就变得统一了。 </p><p><code>DefaultPartitioner.partition()</code> 方法负责在 <code>ProducerRecord</code> 中没有明确指定分区编号的时候，为其选择合适的分区， <code>count</code> 不断递增，确保消息不会都发到同一个 <code>Partition</code> 里；如果消息有 key 的话，则对 key 进行 hash（murmur2），然后与分区数量取模，来确定 key 所在分区到达负载均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* counter 初始化为一个随机数，注意，这里是一个 AtomicInteger */</span></span><br><span class="line"><span class="comment">/* KafkaProducer 必须是一个线程安全类，多个业务发送数据时候也必须保证 Partitioner 线程安全 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compute the partition for the given record.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic The topic name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key The key to partition on (or null if no key)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyBytes serialized key to partition on (or null if no key)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value The value to partition on or null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueBytes serialized value to partition on or null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cluster The current cluster metadata</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 从 Cluster 中获取对应的 Topic 的分区信息 */</span></span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="comment">/* 分区数量 */</span></span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="comment">/* 没有 key 的情况 */</span></span><br><span class="line">    <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* 递增 counter */</span></span><br><span class="line">        <span class="keyword">int</span> nextValue = counter.getAndIncrement();</span><br><span class="line">        <span class="comment">/* 选择 avaliablePartitions */</span></span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">            <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">            <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 消息有可以的情况 */</span></span><br><span class="line">        <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 文章参考自《Apache  Kafka 源码剖析》&lt;/p&gt;
&lt;p&gt; github 地址：&lt;a href=&quot;https://github.com/BingLau7/kafka，里面有代码的相关注释&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/BingLau7/kafka，里面有代码的相关注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 具体部署方式不进行指导了，网上资料比较多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;KafkaProducer-Demo&quot;&gt;&lt;a href=&quot;#KafkaProducer-Demo&quot; class=&quot;headerlink&quot; title=&quot;KafkaProducer Demo&quot;&gt;&lt;/a&gt;KafkaProducer Demo&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ProducerDemo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isAsync = args.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;/* 消息的发送方式：异步发送还是同步发送 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                !args[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].trim().equalsIgnoreCase(&lt;span class=&quot;string&quot;&gt;&quot;sync&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Properties props = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Properties();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        props.put(&lt;span class=&quot;string&quot;&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;localhost:9092&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* 客户端的 ID */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        props.put(&lt;span class=&quot;string&quot;&gt;&quot;client.id&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;DemoProducer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;        * 消息的 key 和 value 都是字节数组，为了将 Java 对象转化为字节数组，可以配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;        * &quot;key.serializer&quot; 和 &quot;value.serializer&quot; 两个序列化器，完成转化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;        */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        props.put(&lt;span class=&quot;string&quot;&gt;&quot;key.serializer&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* StringSerializer 用来将 String 对象序列化成字节数组 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        props.put(&lt;span class=&quot;string&quot;&gt;&quot;value.serializer&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* 生产者的核心类 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        KafkaProducer producer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; KafkaProducer&amp;lt;&amp;gt;(props);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* 向指定的 test 这个 topic 发送消息 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String topic = &lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* 消息的 key */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; messageNo = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String messageStr = &lt;span class=&quot;string&quot;&gt;&quot;Message_&quot;&lt;/span&gt; + messageNo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isAsync) &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* 异步发送消息 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                *  第一个参数是 ProducerRecord 类型的对象，封装了目标 Topic，消息的 kv&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                *  第二个参数是一个 CallBack 对象，当生产者接收到 Kafka 发来的 ACK 确认消息的时候，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                *  会调用此 CallBack 对象的 onCompletion() 方法，实现回调功能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                producer.send(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProducerRecord&amp;lt;&amp;gt;(topic, messageNo, messageStr),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DemoCallBack(startTime, messageNo, messageStr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* 同步发送消息 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                    * KafkaProducer.send() 方法的返回值类型是 Future&amp;lt;RecordMetadata&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                    * 这里通过 Future.get 方法，阻塞当前线程，等待 Kafka 服务端的 ACK 响应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    producer.send(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProducerRecord&amp;lt;&amp;gt;(topic, messageNo, messageStr)).get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    System.out.printf(&lt;span class=&quot;string&quot;&gt;&quot;Send message: (%d, %s)\n&quot;&lt;/span&gt;, messageNo, messageStr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException | ExecutionException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;/* 递增消息的 key */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ++messageNo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DemoCallBack&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Callback&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 开始发送消息的时间戳 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; startTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String message;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DemoCallBack&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; startTime, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; key, String message)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.startTime = startTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.message = message;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 生产者成功发送消息，收到 Kafka 服务端发来的 ACK 确认消息后，会调用此回调函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; metadata 生产者发送的消息的元数据，如果发送过程中出现异常，此参数为 null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; exception 发送过程中出现的异常，如果发送成功为 null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCompletion&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(RecordMetadata metadata, Exception exception)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; elapsedTime = System.currentTimeMillis() - startTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (metadata != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.printf(&lt;span class=&quot;string&quot;&gt;&quot;message: (%d, %s) send to partition %d, offset: %d, in %d\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    key, message, metadata.partition(), metadata.offset(), elapsedTime);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            exception.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
      <category term="分布式与中间件" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch进阶</title>
    <link href="http://yoursite.com/2017/12/06/ElasticSearch%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2017/12/06/ElasticSearch进阶/</id>
    <published>2017-12-06T02:22:12.000Z</published>
    <updated>2017-12-07T14:16:00.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/mapping.html" target="_blank" rel="noopener">官方文档</a></p><p>简而言之，映射即为结构（虽然说 ElasticSearch 是一个无模式的搜索引擎）。</p><p>定义方式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT 'localhost:9200/my_index?pretty' -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123; </span><br><span class="line">      "properties": &#123;  // 字段定义</span><br><span class="line">        "title":    &#123; "type": "text"  &#125;, </span><br><span class="line">        "name":     &#123; "type": "text"  &#125;, </span><br><span class="line">        "age":      &#123; "type": "integer" &#125;,  </span><br><span class="line">        "created":  &#123;</span><br><span class="line">          "type":   "date",   // 类型定义</span><br><span class="line">          "format": "strict_date_optional_time||epoch_millis"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/mapping-types.html" target="_blank" rel="noopener">官方文档</a></p><p>每个字段类型可以指定为 Elasticsearch 提供的一个特定核心类型。Elasticsearch 有以下核心类型：</p><ul><li>string：字符串。<code>text</code> 与 <code>keyword</code></li><li>number: 数字。<code>long</code>, <code>integer</code>, <code>short</code>, <code>byte</code>, <code>double</code>, <code>float</code>, <code>half_float</code>, <code>scaled_float</code></li><li>date：日期。<code>date</code></li><li>boolean：布尔型。<code>boolean</code></li><li>binary：二进制。<code>binary</code></li><li>range: 范围值。<code>integer_range</code>, <code>float_range</code>, <code>long_range</code>, <code>double_range</code>, <code>date_range</code></li></ul><p>除了核心类型之外还有复杂的数组，对象，内嵌对象类型，地理位置，特有类型。</p><h5 id="公共属性"><a href="#公共属性" class="headerlink" title="公共属性"></a>公共属性</h5><ul><li>index_name：该属性定义将存储在索引中的字段名称。若未定义，字段将以对象的名字来命名。</li><li>index：可设置值为 analyzed 和 no。另外，对基于字符串的字段，也可以设置为 not_analyzed。如果设置为analyzed，该字段将被编入索引以供搜索。如果设置为 no，将无法搜索该字段。默认值为 analyzed。在基于字符串的字段中，还有一个额外的选项 not_analyzed。此设置意味着字段将不经分析而编入索引，<strong>使用原始值被编入索引，在搜索的过程中必须全部匹配</strong>。索引属性设置为 no 将使 include_in_all 属性失效。</li><li>store：这个属性的值可以是 yes 或 no，指定了该字段的原始值是否被写入索引中。默认值设置为no，这意味着在结果中不能返回该字段（然而，如果你使用<em>source字段，即使没有存储也可返回返回这个值），但是如果该值编入索引，仍可以基于它来搜索数据。</em></li><li>boost：该属性的默认值是1。基本上，它定义了在文档中该字段的重要性。boost 的值越高，字段中值的重要性也越高。</li><li>null<em>value：如果该字段并非索引文档的一部分，此属性指定应写入索引的值。默认的行为是忽略该字段。</em></li><li>copy<em>to：此属性指定一个字段，字段的所有值都将复制到该指定字段。</em></li><li>include_in_all：此属性指定该字段是否应包括在_all字段中。默认情况下，如果使用_all字段，所有字段都会包括</li></ul><p>具体深入到各个类型特有属性值，请参考官方文档，这里就不一一指出了。</p><h4 id="使用分析器"><a href="#使用分析器" class="headerlink" title="使用分析器"></a>使用分析器</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-analyzers.html" target="_blank" rel="noopener">官方文档</a></p><p>对于字符串类型的字段，可以指定 Elasticsearch 应该使用哪个分析器。分析器是一个用于分析数据或以我们想要的方式查询数据的工具。例如，用空格和小写字符把单词隔开时，不必担心用户发送的单词是小写还是大写。Elasticsearch 使我们能够在索引和查询时使用不同的分析器，并且可以在搜索过程的每个阶段选择处理数据的方式。使用分析器时，只需在指定字段的正确属性上设置它的名字，就这么简单。</p><h5 id="开箱机用的分析器"><a href="#开箱机用的分析器" class="headerlink" title="开箱机用的分析器"></a>开箱机用的分析器</h5><p>Elasticsearch 允许我们使用众多默认定义的分析器中的一种。如下分析器可以开箱即用。</p><ul><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-standard-analyzer.html" target="_blank" rel="noopener">Standard Analyzer</a></p><p>方便大多数欧洲语言的标准分析器。</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-simple-analyzer.html" target="_blank" rel="noopener">Simple Analyzer</a></p><p>基于非字母字符来分离所提供的值，并将其转换为小写形式。</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-whitespace-analyzer.html" target="_blank" rel="noopener">Whitespace Analyzer</a></p><p>基于空格</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-stop-analyzer.html" target="_blank" rel="noopener">Stop Analyzer</a></p><p>类似于 Simple，除了 Simple 提供的之外，还基于提供的停用词过滤数据</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-keyword-analyzer.html" target="_blank" rel="noopener">Keyword Analyzer</a></p><p>非常简单的分析器，只传入提供的值。你可以通过指定字段为 <code>not_analyzed</code> 来达到相同的目的。</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-pattern-analyzer.html" target="_blank" rel="noopener">Pattern Analyzer</a></p><p>通过正则来分离文本</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-lang-analyzer.html" target="_blank" rel="noopener">Language Analyzers</a></p><p>特定语言环境下工作，支持多种语言。</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-fingerprint-analyzer.html" target="_blank" rel="noopener">Fingerprint Analyzer</a></p><p>基于自己创建的一个检测重复的 fingerprint 分析器。</p></li></ul><h5 id="定义自己的分析器"><a href="#定义自己的分析器" class="headerlink" title="定义自己的分析器"></a>定义自己的分析器</h5><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/analysis-custom-analyzer.html" target="_blank" rel="noopener">官方文档</a></p><p>通过简单设置过滤器来定义自己的分析器</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_custom_analyzer"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:      <span class="string">"custom"</span>,</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"char_filter"</span>: [</span><br><span class="line">            <span class="string">"html_strip"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"asciifolding"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个 my_custom_analyzer 的分析器</p><h3 id="扩展索引结构"><a href="#扩展索引结构" class="headerlink" title="扩展索引结构"></a>扩展索引结构</h3><h4 id="元字段"><a href="#元字段" class="headerlink" title="元字段"></a>元字段</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/mapping-fields.html" target="_blank" rel="noopener">官方文档</a></p><ul><li><p><code>_id</code></p><p>存储着索引时设置的实际标识符</p></li><li><p><code>_uid</code></p><p><code>_type</code> 与 <code>_id</code> 结合，文档唯一标识符</p></li><li><p><code>_type</code></p><p>文档类型</p></li><li><p><code>_all</code></p><p>存储其他字段中的数据以便于搜索。</p></li><li><p><code>_index</code></p><p>存储文档相关索引信息。</p></li><li><p><code>_source</code></p><p>可以生成索引过程中存储发送到 ElasticSearch 的原始 JSON 文档。</p></li><li><p><code>_size</code></p><p>自动索引 <code>_source</code> 字段的原始大小。</p></li></ul><h4 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/nested.html" target="_blank" rel="noopener">官方文档</a></p><p>基本上，通过使用嵌套对象，Elasticsearch 允许我们连接一个主文档和多个附属文档。主文档及嵌套文档一同被索引，放置于索引的同一段上（实际在同一块上），确保为该数据结构获取最佳性能。更改文档也是一样的，除非使用更新API，你需要同时索引父文档和其他所有嵌套文档。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"group"</span> : <span class="string">"fans"</span>,</span><br><span class="line">  <span class="attr">"user"</span> : [ </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"first"</span> : <span class="string">"John"</span>,</span><br><span class="line">      <span class="attr">"last"</span> :  <span class="string">"Smith"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"first"</span> : <span class="string">"Alice"</span>,</span><br><span class="line">      <span class="attr">"last"</span> :  <span class="string">"White"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"user.first"</span>: <span class="string">"Alice"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"user.last"</span>:  <span class="string">"Smith"</span> &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h3><p>随着时间的推移和持续索引数据，越来越多的段被创建。因此，搜索性能可能会降低，而且索引可能比原先大，因为它仍含有被删除的文件。这使得段合并有了用武之地。</p><p>段合并的处理过程是：底层的 Lucene 库获取若干段，并在这些段信息的基础上创建一个新的段。由此产生的段拥有所有存储在原始段中的文档，除了被标记为删除的那些之外。合并操作之后，源段将从磁盘上删除。这是因为段合并在CPU和I/O的使用方面代价是相当高的，关键是要适当地控制这个过程被调用的时机和频率。</p><h3 id="段合并的必要性"><a href="#段合并的必要性" class="headerlink" title="段合并的必要性"></a>段合并的必要性</h3><ol><li>构成索引的段越多，搜索速度越慢，需要使用的Lucene内存也越多。</li><li>索引使用的磁盘空间和资源，例如文件描述符。如果从索引中删除许多文档，直到合并发生，则这些文档只是被标记为已删除，而没有在物理上删除。因而，大多数占用了CPU和内存的文档可能并不存在！</li></ol><p>好在Elasticsearch使用合理的默认值做段合并，这些默认值很可能不再需要做任何更改。</p><h4 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h4><p>三种策略：</p><ul><li>tiered：这是默认合并策略，合并尺寸大致相似的段，并考虑到每个层（tier）允许的最大段数量；</li><li>log_byte_size：这个合并策略下，随着时间推移，将产生由索引大小的对数构成的索引，其中存在着一些较大的段以及一些合并因子较小的段等；</li><li>log_doc：这个策略类似于log_byte_size合并策略，但根据索引中的文档数而非段的实际字节数来操作。</li></ul><h4 id="合并调度器"><a href="#合并调度器" class="headerlink" title="合并调度器"></a>合并调度器</h4><p>指示 ElasticSearch 合并过程的方式，有如下可能：</p><ul><li>并发合并调度器：这是默认的合并过程，在独立的线程中执行，定义好的线程数量可以并行合并。</li><li>串行合并调度器：这一合并过程在调用线程（即执行索引的线程）中执行。合并进程会一直阻塞线程直到合并完成。调度器可使用index.merge.scheduler.type参数设置。若要使用串行合并调度器，需把参数值设为serial；若要使用并发调度器，则需把参数值设为concurrent。</li></ul><h3 id="路由介绍"><a href="#路由介绍" class="headerlink" title="路由介绍"></a>路由介绍</h3><p>默认情况下，Elasticsearch 会在所有索引的分片中均匀地分配文档。然而，这并不总是理想情况。为了获得文档，Elasticsearch必须查询所有分片并合并结果。然而，如果你可以把数据按照一定的依据来划分（例如，客户端标识符），就可以使用一个强大的文档和查询分布控制机制：路由。简而言之，<strong>它允许选择用于索引和搜索数据的分片。</strong></p><h4 id="默认索引过程"><a href="#默认索引过程" class="headerlink" title="默认索引过程"></a>默认索引过程</h4><p>默认情况下，Elasticsearch 计算文档标识符的散列值，以此为基础将文档放置于一个可用的主分片上。接着，这些文档被重新分配至副本。</p><h4 id="默认搜索过程"><a href="#默认搜索过程" class="headerlink" title="默认搜索过程"></a>默认搜索过程</h4><p>一般而言，我们将查询发送到 Elasticsearch 的一个节点，Elasticsearch将会根据搜索类型来执行查询。这通常意味着它首先查询所有节点得到标识符和匹配文档的得分，接着发送一个内部查询，但仅发送到相关的分片（包含所需文档的分片），最后获取所需文档来构建响应。</p><p>如下图所示</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_40/ES-search-process.jpg?raw=true" alt="ES搜索过程"></p><p>假使把单个用户的所有文档放置于单个分片之中，并对此分片查询，会出现什么情况？是否对性能来说不明智？不，这种操作是相当便利的，也正是路由所允许的。</p><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/search.html#search-routing" target="_blank" rel="noopener">官方文档</a></p><p>要记住，使用路由时，你仍然应该为与路由值相同的值添加一个过滤器。这是因为，路由值的数量或许会比索引分片的数量多。因此，一些不同的属性值可以指向相同的分片，如果你忽略过滤，得到的数据并非是路由的单个值，而是特定分片中驻留的所有路由值。</p><h5 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h5><p>最简单的方法（但并不总是最方便的一个）是使用路由参数来提供路由值。索引或查询时，你可以添加路由参数到HTTP，或使用你所选择的客户端库来设置。</p><p>添加到固定路由值中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /twitter/tweet?routing=kimchy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span> : <span class="string">"kimchy"</span>,</span><br><span class="line">    <span class="attr">"postDate"</span> : <span class="string">"2009-11-15T14:12:12"</span>,</span><br><span class="line">    <span class="attr">"message"</span> : <span class="string">"trying out Elasticsearch"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从路由值中查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /twitter/tweet/_search?routing=kimchy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span> : &#123;</span><br><span class="line">                <span class="attr">"query_string"</span> : &#123;</span><br><span class="line">                    <span class="attr">"query"</span> : <span class="string">"some query string here"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"term"</span> : &#123; <span class="attr">"user"</span> : <span class="string">"kimchy"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="路由字段"><a href="#路由字段" class="headerlink" title="路由字段"></a>路由字段</h5><p>为每个发送到Elasticsearch的请求指定路由值并不方便。事实上，在索引过程中，Elasticsearch允许指定一个字段，用该字段的值作为路由值。这样只需要在查询时提供路由参数。为此，在类型定义中需要添加以下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"_routing": &#123;</span><br><span class="line">  "required": true,</span><br><span class="line">  "path": "userId"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述定义意味着需要提供路由值（<code>&quot;required&quot;:true</code>属性），否则，索引请求将失败。除此之外，我们还指定了path属性，说明文档的哪个字段值应被设置为路由值，在上述示例中，我们使用了 userId 字段值。这两个参数意味着用于索引的每个文档都需要定义 userId 字段。</p><p>添加路由部分后，整个更新的映射文件将如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">  <span class="attr">"post"</span>: &#123;</span><br><span class="line">      <span class="attr">"_routing"</span>: &#123;</span><br><span class="line">      <span class="attr">"required"</span>: <span class="literal">true</span>, </span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"userId"</span></span><br><span class="line">      &#125;, </span><br><span class="line">     <span class="attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="attr">"id"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"long"</span>, <span class="attr">"store"</span>: <span class="string">"yes"</span>, <span class="attr">"precision_ step"</span>: <span class="string">"0"</span>&#125;,</span><br><span class="line">      <span class="attr">"name"</span>: &#123;<span class="attr">"type"</span> :<span class="string">"string"</span>, <span class="attr">"store"</span>: <span class="string">"yes"</span>, <span class="attr">"index"</span>: <span class="string">"analyzed"</span>&#125;, </span><br><span class="line">      <span class="attr">"contents"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"store"</span>: <span class="string">"no"</span>, <span class="attr">"index"</span>: <span class="string">"analyzed"</span> &#125;,</span><br><span class="line">      <span class="attr">"userId"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"long"</span>, <span class="attr">"store"</span>: <span class="string">"yes"</span>, <span class="attr">"precision_ step"</span>: <span class="string">"0"</span>&#125; </span><br><span class="line">      &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想使用上述映射来建 post 索引可以这样:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/posts/post/ 1' -d '&#123;</span><br><span class="line">  "id": 1, </span><br><span class="line">  "name":" New post", </span><br><span class="line">  "contents": "New test post", </span><br><span class="line">  "userId": 1234567 </span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>这样 ElasticSearch 将使用 1234567 作为索引时的路由值。</p><h2 id="其他查询"><a href="#其他查询" class="headerlink" title="其他查询"></a>其他查询</h2><h3 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/compound-queries.html" target="_blank" rel="noopener">官方文档</a></p><p>复合查询就是支持可以把多个查询连接起来，或者改变其他查询的行为。</p><h4 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-bool-query.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"must"</span> : &#123;</span><br><span class="line">        <span class="attr">"term"</span> : &#123; <span class="attr">"user"</span> : <span class="string">"kimchy"</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"term"</span> : &#123; <span class="attr">"tag"</span> : <span class="string">"tech"</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"must_not"</span> : &#123;</span><br><span class="line">        <span class="attr">"range"</span> : &#123;</span><br><span class="line">          <span class="attr">"age"</span> : &#123; <span class="attr">"gte"</span> : <span class="number">10</span>, <span class="attr">"lte"</span> : <span class="number">20</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"should"</span> : [</span><br><span class="line">        &#123; <span class="attr">"term"</span> : &#123; <span class="attr">"tag"</span> : <span class="string">"wow"</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">"term"</span> : &#123; <span class="attr">"tag"</span> : <span class="string">"elasticsearch"</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"minimum_should_match"</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"boost"</span> : <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过布尔查询来封装无限数量的查询，并通过下面描述的节点之一使用一个逻辑值来连接它们。</p><ul><li>should：被它封装的布尔查询可能被匹配，也可能不被匹配。被匹配的should节点数目由minimum_should_match参数控制。</li><li>must：被它封装的布尔查询必须被匹配，文档才会返回。</li><li>must_not：被它封装的布尔查询必须不被匹配，文档才会返回。</li></ul><p>上述每个节点都可以在单个布尔查询中出现多次。这允许建立非常复杂的查询，有多个嵌套级别（在一个布尔查询中包含另一个布尔查询）。记住，结果文档的得分将由文档匹配的所有封装的查询得分总和计算得到。</p><p>除了上述部分以外，还可以在查询主体中添加以下参数控制其行为。</p><ul><li>boost：此参数指定了查询使用的加权值，默认为1.0。加权值越高，匹配文档的得分越高。</li><li>minimum_should_match：此参数的值描述了文档被视为匹配时，应该匹配的should子句的最少数量。举例来说，它可以是个整数值，比如2，也可以是个百分比，比如75%。</li><li>disable_coord：此参数的默认值为false，允许启用或禁用分数因子的计算，该计算是基于文档包含的所有查询词条。如果得分不必太精确，但要查询快点，那么应该将它设置为true。</li></ul><h4 id="加权查询"><a href="#加权查询" class="headerlink" title="加权查询"></a>加权查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-boosting-query.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"boosting"</span> : &#123;</span><br><span class="line">            <span class="attr">"positive"</span> : &#123;</span><br><span class="line">                <span class="attr">"term"</span> : &#123;</span><br><span class="line">                    <span class="attr">"field1"</span> : <span class="string">"value1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"negative"</span> : &#123;</span><br><span class="line">                 <span class="attr">"term"</span> : &#123;</span><br><span class="line">                     <span class="attr">"field2"</span> : <span class="string">"value2"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"negative_boost"</span> : <span class="number">0.2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加权查询封装了两个查询，并且降低其中一个查询返回文档的得分。加权查询中有三个节点需要定义：</p><ul><li>positive部分，包含所返回文档得分不会被改变的查询；</li><li>negative部分，返回的文档得分将被降低；</li><li>negative_boost部分，包含用来降低negative部分查询得分的加权值。</li></ul><p>加权查询的优点是，positive 部分和 negative 部分包含的查询结果都会出现在搜索结果中，而某些查询的得分将被降低。如果使用布尔查询的 must_not 节点，将得不到这样的结果。</p><h4 id="constant-score-查询"><a href="#constant-score-查询" class="headerlink" title="constant_score 查询"></a>constant_score 查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-constant-score-query.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"term"</span> : &#123; <span class="attr">"user"</span> : <span class="string">"kimchy"</span>&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"boost"</span> : <span class="number">1.2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constant_score 查询封装了另一个查询（或过滤），并为每一个所封装查询（或过滤）返回的文档返回一个常量得分。它<strong>允许我们严格控制与一个查询或过滤匹配的文档得分</strong>。</p><h3 id="function-score-查询"><a href="#function-score-查询" class="headerlink" title="function_score 查询"></a>function_score 查询</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-function-score-query.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"function_score"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: &#123; <span class="attr">"match_all"</span>: &#123;&#125; &#125;,</span><br><span class="line">            <span class="attr">"boost"</span>: <span class="string">"5"</span>,</span><br><span class="line">            <span class="attr">"random_score"</span>: &#123;&#125;, </span><br><span class="line">            <span class="attr">"boost_mode"</span>:<span class="string">"multiply"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function_score 查询允许我们通过提供一些计算函数来修改检索文档的得分。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="后过滤器"><a href="#后过滤器" class="headerlink" title="后过滤器"></a>后过滤器</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/search-request-post-filter.html" target="_blank" rel="noopener">官方文档</a></p><p>出于性能考虑，当你需要对搜索结果和聚合结果做不同的过滤时，你才应该使用 <code>post_filter</code>， <code>post_filter</code> 的特性是在查询之后 执行，任何过滤对性能带来的好处（比如缓存）都会完全失去。</p><p>在我们需要不同过滤时， <code>post_filter</code> 只与聚合一起使用。</p><p>在任何搜索中使用过滤器，只需在于 query 节点相同级别上添加一个 filter 节点。如果你只想要过滤器，也可以完全忽略 query 节点。示例，搜索 title 字段并向其添加过滤器：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"match"</span>: &#123;<span class="attr">"title"</span>: <span class="string">"Catch-22"</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"post_filter"</span>: &#123;</span><br><span class="line">      <span class="attr">"term"</span>: &#123;<span class="attr">"year"</span>: <span class="number">1961</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回结果会缩小到过滤器指定的范围中。</p><h4 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-filter-context.html" target="_blank" rel="noopener">官方文档</a></p><p>绝大部分字段与 query 相同，具体可参照文档。</p><h4 id="filter-or-post-filter"><a href="#filter-or-post-filter" class="headerlink" title="filter or post_filter"></a>filter or post_filter</h4><p><a href="https://stackoverflow.com/questions/32085557/elasticsearch-post-filter-or-filter" target="_blank" rel="noopener">资料</a></p><blockquote><p>To sum it up</p><ul><li>a <code>filtered</code> query affects <strong>both search results and aggregations</strong></li><li>while a <code>post_filter</code> <strong>only affects the search results but NOT the aggregations</strong></li></ul></blockquote><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/search-request-sort.html" target="_blank" rel="noopener">官方文档</a></p><p>默认是以 <code>_score</code> 的倒叙排序的</p><h4 id="指定字段排序"><a href="#指定字段排序" class="headerlink" title="指定字段排序"></a>指定字段排序</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sort"</span> : [</span><br><span class="line">        &#123; <span class="attr">"post_date"</span> : &#123;<span class="attr">"order"</span> : <span class="string">"asc"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"user"</span>,</span><br><span class="line">        &#123; <span class="attr">"name"</span> : <span class="string">"desc"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">"age"</span> : <span class="string">"desc"</span> &#125;,</span><br><span class="line">        <span class="string">"_score"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"term"</span> : &#123; <span class="attr">"user"</span> : <span class="string">"kimchy"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于指定在 <code>sore</code> 里面的 array 字段。排序数组中的字段，如果字段相同就采用下一个字段来确定顺序。</p><blockquote><p>The order defaults to <code>desc</code> when sorting on the <code>_score</code>, and defaults to <code>asc</code> when sorting on anything else.</p></blockquote><h4 id="指定缺少字段行为"><a href="#指定缺少字段行为" class="headerlink" title="指定缺少字段行为"></a>指定缺少字段行为</h4><p>如果排序字段有缺失可以指定为第一个(<code>_first</code>)或最后一个(<code>_last</code>)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sort"</span> : [</span><br><span class="line">        &#123; <span class="attr">"price"</span> : &#123;<span class="attr">"missing"</span> : <span class="string">"_last"</span>&#125; &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"term"</span> : &#123; <span class="attr">"product"</span> : <span class="string">"chocolate"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态排序"><a href="#动态排序" class="headerlink" title="动态排序"></a>动态排序</h4><p>ElasticSearch 允许我们使用具有多个值得字段进行排序，可以使用脚本来控制排序比较告诉 ElasticSearch 如果计算应用于排序的值来达到目的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"term"</span> : &#123; <span class="attr">"user"</span> : <span class="string">"kimchy"</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span> : &#123;</span><br><span class="line">        <span class="attr">"_script"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"number"</span>,</span><br><span class="line">            <span class="attr">"script"</span> : &#123;</span><br><span class="line">                <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">                <span class="attr">"source"</span>: <span class="string">"doc['field_name'].value * params.factor"</span>,</span><br><span class="line">                <span class="attr">"params"</span> : &#123;</span><br><span class="line">                    <span class="attr">"factor"</span> : <span class="number">1.1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"order"</span> : <span class="string">"asc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html" target="_blank" rel="noopener">官方文档</a></p><p>ElasticSearch 的 Explain API 会给出查询的文档的具体计算解释，无论这个文档是否匹配到了这条查询。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /twitter/tweet/0/_explain</span><br><span class="line">&#123;</span><br><span class="line">      <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123; <span class="attr">"message"</span> : <span class="string">"elasticsearch"</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>: <span class="string">"twitter"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>: <span class="string">"tweet"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>: <span class="string">"0"</span>,</span><br><span class="line">   <span class="attr">"matched"</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"explanation"</span>: &#123;</span><br><span class="line">      <span class="attr">"value"</span>: <span class="number">1.6943599</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"weight(message:elasticsearch in 0) [PerFieldSimilarity], result of:"</span>,</span><br><span class="line">      <span class="attr">"details"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">1.6943599</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"score(doc=0,freq=1.0 = termFreq=1.0\n), product of:"</span>,</span><br><span class="line">            <span class="attr">"details"</span>: [</span><br><span class="line">               &#123;</span><br><span class="line">                  <span class="attr">"value"</span>: <span class="number">1.3862944</span>,</span><br><span class="line">                  <span class="attr">"description"</span>: <span class="string">"idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:"</span>,</span><br><span class="line">                  <span class="attr">"details"</span>: [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">1.0</span>,</span><br><span class="line">                        <span class="attr">"description"</span>: <span class="string">"docFreq"</span>,</span><br><span class="line">                        <span class="attr">"details"</span>: []</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">5.0</span>,</span><br><span class="line">                        <span class="attr">"description"</span>: <span class="string">"docCount"</span>,</span><br><span class="line">                        <span class="attr">"details"</span>: []</span><br><span class="line">                      &#125;</span><br><span class="line">                   ]</span><br><span class="line">               &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"value"</span>: <span class="number">1.2222223</span>,</span><br><span class="line">                  <span class="attr">"description"</span>: <span class="string">"tfNorm, computed as (freq * (k1 + 1)) / (freq + k1 * (1 - b + b * fieldLength / avgFieldLength)) from:"</span>,</span><br><span class="line">                  <span class="attr">"details"</span>: [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">1.0</span>,</span><br><span class="line">                        <span class="attr">"description"</span>: <span class="string">"termFreq=1.0"</span>,</span><br><span class="line">                        <span class="attr">"details"</span>: []</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">1.2</span>,</span><br><span class="line">                        <span class="attr">"description"</span>: <span class="string">"parameter k1"</span>,</span><br><span class="line">                        <span class="attr">"details"</span>: []</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">0.75</span>,</span><br><span class="line">                        <span class="attr">"description"</span>: <span class="string">"parameter b"</span>,</span><br><span class="line">                        <span class="attr">"details"</span>: []</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">5.4</span>,</span><br><span class="line">                        <span class="attr">"description"</span>: <span class="string">"avgFieldLength"</span>,</span><br><span class="line">                        <span class="attr">"details"</span>: []</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">3.0</span>,</span><br><span class="line">                        <span class="attr">"description"</span>: <span class="string">"fieldLength"</span>,</span><br><span class="line">                        <span class="attr">"details"</span>: []</span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;</span><br><span class="line">            ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来有点复杂，这里最重要的内容就是对文档计算得到的总分，如果总分等于0，则该文档将不能匹配给定的查询。另一个重要内容是关于不同打分项的描述信息。根据查询类型的不同，打分项会以不同方式对最后得分产生影响。</p><h2 id="搜索进阶"><a href="#搜索进阶" class="headerlink" title="搜索进阶"></a>搜索进阶</h2><h3 id="Apache-Lucene-评分简介"><a href="#Apache-Lucene-评分简介" class="headerlink" title="Apache Lucene 评分简介"></a>Apache Lucene 评分简介</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/guide/2.x/scoring-theory.html#tfidf" target="_blank" rel="noopener">官方文档</a></p><p>TF/IDF 算法的实用计算公式如下：<br>$$<br>score(q, d) = coord(q, d) <em> queryNorm(q) </em> \sum_{tinq} (tf(tind)<em>idf(t)^2 </em> boot(t) * norm(t,d))<br>$$<br>其中 q 是查询 d 是文档。还有两个不直接依赖于查询词条的因子 coord 和 queryNorm。</p><p>公式中这两个元素跟查询中的每个词计算而得的总和相乘。另一方面，该总和由给定词的词频、逆文档频率、词条加权和规范（长度规范）相乘而来。</p><p>上述规则的好处是，你不需要记住全部内容。应该知道的是影响文档评分的因素。下面是一些派生自上述等式的规则</p><h4 id="派生规则"><a href="#派生规则" class="headerlink" title="派生规则"></a>派生规则</h4><ul><li>匹配的词条越罕见，文档的得分越高；</li><li>文档的字段越小，文档的得分越高；</li><li>字段的加权越高，文档的得分越高；</li><li>我们可以看到，文档匹配的查询词条数目越高、字段越少（意味着索引的词条越少），Lucene给文档的分数越高。同时，罕见词条比常见词条更受评分的青睐。</li></ul><h3 id="ElasticSearch-脚本功能"><a href="#ElasticSearch-脚本功能" class="headerlink" title="ElasticSearch 脚本功能"></a>ElasticSearch 脚本功能</h3><p>Elasticsearch有几个可以使用脚本的功能。你已经看过一些例子，如更新文件、过滤和搜索。<br>Elasticsearch使用脚本执行的任何请求中，我们会注意到以下相似的属性。</p><ul><li>script: 实际包含的脚本代码</li><li>lang: 定义实用的脚本语言，默认为 mvel</li><li>params: 此对象包含参数及其值。每个定义的参数可以通过指定参数名称在脚本中使用。通过使用参数，我们可以编写更干净的代码。由于可以缓存，使用参数的脚本比嵌入常数的代码执行得更快。</li></ul><p>实例：排序的脚本功能</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"function_score"</span>: &#123;</span><br><span class="line">    <span class="attr">"functions"</span>: [</span><br><span class="line">      &#123; ...location clause... &#125;, </span><br><span class="line">      &#123; ...price clause... &#125;, </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"script_score"</span>: &#123;</span><br><span class="line">          <span class="attr">"params"</span>: &#123; </span><br><span class="line">            <span class="attr">"threshold"</span>: <span class="number">80</span>,</span><br><span class="line">            <span class="attr">"discount"</span>: <span class="number">0.1</span>,</span><br><span class="line">            <span class="attr">"target"</span>: <span class="number">10</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"script"</span>: <span class="string">"price  = doc['price'].value; margin = doc['margin'].value;</span></span><br><span class="line"><span class="string">          if (price &lt; threshold) &#123; return price * margin / target &#125;;</span></span><br><span class="line"><span class="string">          return price * (1 - discount) * margin / target;"</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="脚本执行中可用对象"><a href="#脚本执行中可用对象" class="headerlink" title="脚本执行中可用对象"></a>脚本执行中可用对象</h4><p>在不同的操作过程中，Elasticsearch允许在脚本中使用不同的对象。比如，在搜索过程中，下列对象是可用的。</p><ul><li><em>doc（也可以用doc）：这是个 <code>org.elasticsearch.search.lookup.DocLookup</code> 对象的实例。通过它可以访问当前找到的文档，附带计算的得分和字段的值。</em></li><li>source：这是个 <code>org.elasticsearch.search.lookup.SourceLookup</code>对象的实例，通过它可以访问当前文档的 source，以及定义在 source 中的值。</li><li>fields：这是个 <code>org.elasticsearch.search.lookup.FieldsLookup</code> 对象的实例，通过它可以访问文档的所有字段。</li></ul><p>另一方面，在文档更新过程中，Elasticsearch 只通过 _source 属性公开了 ctx 对象，通过它可以访问当前文档。</p><p>我们之前看到过，在文档字段和字段值的上下文中提到了几种方法。现在让我们通过下面的例子，看看如何获取title字段的值。</p><p>在括号中，你可以看到 Elasticsearch 从 library 索引中为我们的一个示例文档返回的值：</p><ul><li>doc.title.value（crime）；</li><li>source.title（CrimeandPunishment）；</li><li>fields.title.value（null）。</li></ul><p>有点疑惑，不是吗？在索引期间，一个字段值作为 source 文档的一部分被发送到 Elasticsearch。Elasticsearch 可以存储此信息，而且<strong>默认的就是存储</strong>。此外，文档被解析，<strong>每个被标记成 stored 的字段可能都存储在索引中</strong>（也就是说，store 属性设置为 true；否则，默认情况下，字段不存储）。最后，字段值可以配置成 indexed。这意味着分析该字段值，划分为标记，并放置在索引中。</p><p>综上所述，一个字段可能以如下方式存储在索引中：</p><ul><li>作为_source文档的一部分；</li><li>一个存储并未经解析的值；</li><li>一个解析成若干标记的值。</li></ul><h4 id="使用其他脚本语言"><a href="#使用其他脚本语言" class="headerlink" title="使用其他脚本语言"></a>使用其他脚本语言</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/5.6/scripting.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/search-aggregations.html" target="_blank" rel="noopener">官方文档</a></p><p>提供基于搜索查询的聚合功能，它基于简单的结构建立而成，可用进行组合以便于构建复杂的数据，所以称为聚合。聚合可以被看作是在一组文档上（查询得到）分析得到的信息的结果。 </p><h4 id="Metric-度量聚合"><a href="#Metric-度量聚合" class="headerlink" title="Metric 度量聚合"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/search-aggregations-metrics.html" target="_blank" rel="noopener"><em>Metric</em></a> 度量聚合</h4><h5 id="min、max、sum、avg-聚合"><a href="#min、max、sum、avg-聚合" class="headerlink" title="min、max、sum、avg 聚合"></a>min、max、sum、avg 聚合</h5><p>min、max、sum 和 avg 聚合的使用很相似。它们对于给定字段分别返回最小值、最大值、总和和平均值。任何数值型字段都可以作为这些值的源。比如下面通过 <code>grade</code> 计算平均值然后返回字段标识为 <code>avg_grade</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /exams/_search?size=0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"avg_grade"</span> : &#123; <span class="attr">"avg"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"grade"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "avg_grade": &#123;</span><br><span class="line">            "value": 75.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="value-count"><a href="#value-count" class="headerlink" title="value count"></a>value count</h5><p>value_count 聚合跟前面描述的聚合类似，只是输入字段不一定要是数值型的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"types_count"</span> : &#123; <span class="attr">"value_count"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"type"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "types_count": &#123;</span><br><span class="line">            "value": 7</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="脚本聚合"><a href="#脚本聚合" class="headerlink" title="脚本聚合"></a>脚本聚合</h5><p>使用 script 做到 value_count 聚合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"type_count"</span> : &#123;</span><br><span class="line">            <span class="attr">"value_count"</span> : &#123;</span><br><span class="line">                <span class="attr">"script"</span> : &#123;</span><br><span class="line">                    <span class="attr">"source"</span> : <span class="string">"doc['type'].value"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stats-和-extended-status-更多信息-聚合"><a href="#stats-和-extended-status-更多信息-聚合" class="headerlink" title="stats 和 extended_status(更多信息) 聚合"></a>stats 和 extended_status(更多信息) 聚合</h5><p>stats 和 extended_stats 聚合可以看成是在单一聚合对象中返回所有前面描述聚合的一种聚合。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST /exams/_search?size=0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"grades_stats"</span> : &#123; <span class="attr">"stats"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"grade"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "grades_stats": &#123;</span><br><span class="line">            "count": 2,</span><br><span class="line">            "min": 50.0,</span><br><span class="line">            "max": 100.0,</span><br><span class="line">            "avg": 75.0,</span><br><span class="line">            "sum": 150.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GET /exams/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"grades_stats"</span> : &#123; <span class="attr">"extended_stats"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"grade"</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "grades_stats": &#123;</span><br><span class="line">           "count": 2,</span><br><span class="line">           "min": 50.0,</span><br><span class="line">           "max": 100.0,</span><br><span class="line">           "avg": 75.0,</span><br><span class="line">           "sum": 150.0,</span><br><span class="line">           "sum_of_squares": 12500.0,</span><br><span class="line">           "variance": 625.0,</span><br><span class="line">           "std_deviation": 25.0,</span><br><span class="line">           "std_deviation_bounds": &#123;</span><br><span class="line">            "upper": 125.0,</span><br><span class="line">            "lower": 25.0</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多查看文档</p><h4 id="Bucketing-桶聚合"><a href="#Bucketing-桶聚合" class="headerlink" title="Bucketing 桶聚合"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/search-aggregations-bucket.html" target="_blank" rel="noopener"><em>Bucketing</em></a> 桶聚合</h4><p>桶聚合返回很多子集，并限定输入数据到一个特殊的叫做桶的子集中。</p><h5 id="terms-聚合"><a href="#terms-聚合" class="headerlink" title="terms 聚合"></a>terms 聚合</h5><p>terms 聚合为字段中每个词条返回一个桶。这允许你对生成字段每个值得统计。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"genres"</span> : &#123;</span><br><span class="line">            <span class="attr">"terms"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"genre"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations" : &#123;</span><br><span class="line">        "genres" : &#123;</span><br><span class="line">            "doc_count_error_upper_bound": 0, </span><br><span class="line">            "sum_other_doc_count": 0, </span><br><span class="line">            "buckets" : [ </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="string">"electronic"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">6</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="string">"rock"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">3</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span> : <span class="string">"jazz"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span> : <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="range-聚合"><a href="#range-聚合" class="headerlink" title="range 聚合"></a>range 聚合</h5><p>range 聚合使用定义的范围来创建桶。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"price_ranges"</span> : &#123;</span><br><span class="line">            <span class="attr">"range"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"price"</span>,</span><br><span class="line">                <span class="attr">"ranges"</span> : [</span><br><span class="line">                    &#123; <span class="attr">"to"</span> : <span class="number">100.0</span> &#125;,</span><br><span class="line">                    &#123; <span class="attr">"from"</span> : <span class="number">100.0</span>, <span class="attr">"to"</span> : <span class="number">200.0</span> &#125;,</span><br><span class="line">                    &#123; <span class="attr">"from"</span> : <span class="number">200.0</span> &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "price_ranges" : &#123;</span><br><span class="line">            "buckets": [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"*-100.0"</span>,</span><br><span class="line">                    <span class="attr">"to"</span>: <span class="number">100.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"100.0-200.0"</span>,</span><br><span class="line">                    <span class="attr">"from"</span>: <span class="number">100.0</span>,</span><br><span class="line">                    <span class="attr">"to"</span>: <span class="number">200.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"200.0-*"</span>,</span><br><span class="line">                    <span class="attr">"from"</span>: <span class="number">200.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="date-range-聚合"><a href="#date-range-聚合" class="headerlink" title="date_range 聚合"></a>date_range 聚合</h5><p>date_range 聚合类似于 range，但它专用在使用日期类型的字段。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"date_range"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"date"</span>,</span><br><span class="line">                <span class="attr">"format"</span>: <span class="string">"MM-yyy"</span>,</span><br><span class="line">                <span class="attr">"ranges"</span>: [</span><br><span class="line">                    &#123; <span class="attr">"to"</span>: <span class="string">"now-10M/M"</span> &#125;, </span><br><span class="line">                    &#123; <span class="attr">"from"</span>: <span class="string">"now-10M/M"</span> &#125; </span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "range": &#123;</span><br><span class="line">            "buckets": [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"to"</span>: <span class="number">1.4436576E12</span>,</span><br><span class="line">                    <span class="attr">"to_as_string"</span>: <span class="string">"10-2015"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">7</span>,</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"*-10-2015"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"from"</span>: <span class="number">1.4436576E12</span>,</span><br><span class="line">                    <span class="attr">"from_as_string"</span>: <span class="string">"10-2015"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"10-2015-*"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="missing-聚合"><a href="#missing-聚合" class="headerlink" title="missing 聚合"></a>missing 聚合</h5><p>基于字段数据的单个桶集合，创建当前文档集上下文中缺少字段值（实际上缺少字段或设置了配置的 NULL 值）的所有文档的桶。 此聚合器通常会与其他字段数据存储桶聚合器（如 range）一起使用，以返回由于缺少字段数据值而无法放置在其他存储桶中的所有文档的信息。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"products_without_a_price"</span> : &#123;</span><br><span class="line">            <span class="attr">"missing"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations" : &#123;</span><br><span class="line">        "products_without_a_price" : &#123;</span><br><span class="line">            "doc_count" : 00</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="nested-聚合"><a href="#nested-聚合" class="headerlink" title="nested 聚合"></a>nested 聚合</h5><p>针对 nested 结构的聚合</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123; <span class="attr">"name"</span> : <span class="string">"led tv"</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"resellers"</span> : &#123;</span><br><span class="line">            <span class="attr">"nested"</span> : &#123;</span><br><span class="line">                <span class="attr">"path"</span> : <span class="string">"resellers"</span> # nested</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">                <span class="attr">"min_price"</span> : &#123; <span class="attr">"min"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"resellers.price"</span> &#125; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "aggregations": &#123;</span><br><span class="line">    "resellers": &#123;</span><br><span class="line">      "doc_count": 0,</span><br><span class="line">      "min_price": &#123;</span><br><span class="line">        "value": 350</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="histogram-聚合"><a href="#histogram-聚合" class="headerlink" title="histogram 聚合"></a>histogram 聚合</h5><p>想象为柱状图一样，针对某个 field 的多个值进行聚合。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"prices"</span> : &#123;</span><br><span class="line">            <span class="attr">"histogram"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"price"</span>,</span><br><span class="line">                <span class="attr">"interval"</span> : <span class="number">50</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "aggregations": &#123;</span><br><span class="line">        "prices" : &#123;</span><br><span class="line">            "buckets": [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">0.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">50.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">100.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">150.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="number">200.0</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟多其他的聚合可以查看官方文档.</p><h3 id="建议器"><a href="#建议器" class="headerlink" title="建议器"></a>建议器</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/search-suggesters.html" target="_blank" rel="noopener">官方文档</a></p><p>我们可以把建议器看成这样的功能：在考虑性能的情况下，允许纠正用户的拼写错误，以及构建一个自动完成功能。</p><h4 id="建议器类型"><a href="#建议器类型" class="headerlink" title="建议器类型"></a>建议器类型</h4><ul><li>term：更正每个传入的单词，在非短语查询中很有用。</li><li>phrase：工作在短语上，返回一个恰当的短语。</li><li>completion：在索引中存储复杂的数据结构，提供快速高效的自动完成功能。</li><li>context：配合 completion 使用，给其搜索文档字段提供某些上下文信息以供更好的进行 completion</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>如果我们需要在查询结果中得到建议，例如使用 <code>match</code> 查询并尝试为 tring out Elasticsearc 短语得到一个建议，该短语包含一个拼写错误的词条。为此我们可以：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST twitter/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"message"</span>: <span class="string">"tring out Elasticsearch"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"suggest"</span> : &#123;</span><br><span class="line">    <span class="attr">"my-suggestion"</span> : &#123;</span><br><span class="line">      <span class="attr">"text"</span> : <span class="string">"trying out Elasticsearch"</span>,</span><br><span class="line">      <span class="attr">"term"</span> : &#123;</span><br><span class="line">        <span class="attr">"field"</span> : <span class="string">"message"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望为同样的文本得到多个建议，则可把建议嵌入 suggest 对象中，并把 text 属性设置为选择的建议对象。（省略 query 结构）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"suggest"</span>: &#123;</span><br><span class="line">    <span class="attr">"my-suggest-1"</span> : &#123;</span><br><span class="line">      <span class="attr">"text"</span> : <span class="string">"tring out Elasticsearch"</span>,</span><br><span class="line">      <span class="attr">"term"</span> : &#123;</span><br><span class="line">        <span class="attr">"field"</span> : <span class="string">"message"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"my-suggest-2"</span> : &#123;</span><br><span class="line">      <span class="attr">"text"</span> : <span class="string">"kmichy"</span>,</span><br><span class="line">      <span class="attr">"term"</span> : &#123;</span><br><span class="line">        <span class="attr">"field"</span> : <span class="string">"user"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span> : <span class="number">105</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;,</span><br><span class="line">  "hits" : &#123;</span><br><span class="line">    []</span><br><span class="line">  &#125;,</span><br><span class="line">  "suggest" : &#123;</span><br><span class="line">    "my-suggest-1" : [</span><br><span class="line">      &#123;</span><br><span class="line">        "text" : "tring",  // 原始单测</span><br><span class="line">        "offset" : 0,      // 原本的偏移值</span><br><span class="line">        "length" : 5,      // 单词长度</span><br><span class="line">        "options" : [      // 建议</span><br><span class="line">          &#123;</span><br><span class="line">            "text" : "trying",  // 建议的文本</span><br><span class="line">            "score" : 0.8,      // 建议的得分，越高越好</span><br><span class="line">            "freq" : 2          // 建议的频率，代表我们执行建议查询的索引上，该单词出现在文档中的次数</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"text"</span> : <span class="string">"out"</span>,</span><br><span class="line">        <span class="attr">"offset"</span> : <span class="number">6</span>,</span><br><span class="line">        <span class="attr">"length"</span> : <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"options"</span> : [ ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"text"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">        <span class="attr">"offset"</span> : <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"length"</span> : <span class="number">13</span>,</span><br><span class="line">        <span class="attr">"options"</span> : [ ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    "my-suggest-2" : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"text"</span> : <span class="string">"kmichy"</span>,</span><br><span class="line">        <span class="attr">"offset"</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"length"</span> : <span class="number">6</span>,</span><br><span class="line">        <span class="attr">"options"</span> : [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"text"</span> : <span class="string">"kimchy"</span>,</span><br><span class="line">            <span class="attr">"score"</span> : <span class="number">0.8333333</span>,</span><br><span class="line">            <span class="attr">"freq"</span> : <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 suggest 的命名只是示例，最好使用有意义的命名。</p><h4 id="建议器公用配置"><a href="#建议器公用配置" class="headerlink" title="建议器公用配置"></a>建议器公用配置</h4><ul><li>text：这个选项定义了我们希望得到建议的文本。此参数是必须的。</li><li>field：这是另一个必须提供的参数。field参数设置了为哪个字段生成建议。</li><li>analyzer：这个选项定义了分析器的名字，该分析器用作分析text参数提供的文本。如果未设置，Elasticsearch将使用field参数所指定的字段所用的分析器。</li><li>size：这个参数默认为5，指定了text参数中每个词条可以返回的建议的最大数字。</li><li>sort：此选项允许指定 Elasticsearch 返回的建议如何排序。默认情况下，此选项设置成 score，Elasticsearch将首先按照建议的得分排，然后按文档频率，最后按词条排。第二个可能值为 frequency，意味着结果首先按文档频率排，然后按分数，最后按词条。</li></ul><p>具体到各个建议器的使用推荐查看文档，玩法太多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;h3 id=&quot;映射&quot;&gt;&lt;a href=&quot;#映射&quot; class=&quot;headerlink&quot; title=&quot;映射&quot;&gt;&lt;/a&gt;映射&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.0/mapping.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简而言之，映射即为结构（虽然说 ElasticSearch 是一个无模式的搜索引擎）。&lt;/p&gt;
&lt;p&gt;定义方式：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -XPUT &#39;localhost:9200/my_index?pretty&#39; -H &#39;Content-Type: application/json&#39; -d&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;mappings&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;doc&quot;&lt;/span&gt;: &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &quot;properties&quot;: &amp;#123;  // 字段定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;title&quot;:    &amp;#123; &quot;type&quot;: &quot;text&quot;  &amp;#125;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;name&quot;:     &amp;#123; &quot;type&quot;: &quot;text&quot;  &amp;#125;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;age&quot;:      &amp;#123; &quot;type&quot;: &quot;integer&quot; &amp;#125;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;created&quot;:  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &quot;type&quot;:   &quot;date&quot;,   // 类型定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型与线程</title>
    <link href="http://yoursite.com/2017/12/02/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/12/02/Java-内存模型与线程/</id>
    <published>2017-12-02T15:28:58.000Z</published>
    <updated>2017-12-02T15:47:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h2><p>所谓并发的时代，其实不仅仅提现在并发友好的库、框架、语言在兴起，而是这种并发的思想，早已融入到计算机最底层中了。</p><p>『让计算机并发执行若干个运算任务』与『更充分地利用计算机处理器的效能』之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是绝大多数的<strong>运算任务都不可能只靠处理器『计算』就能完成</strong>，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。</p><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不<strong>加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲</strong>：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当<strong>运算结束后再从缓存同步回内存之中</strong>，这样处理器就无须等待缓慢的内存读写了。</p><p>嫌上面文字太长了，<strong>简单说来</strong>就是：计算机计算太快了，等不及慢的主存了，加了 L3、L2、L1 以及寄存器4个高速缓存就是为了让 IO 能快点。</p><p>由此产生出了一个问题</p><a id="more"></a><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>在多处理器系统中，每个处理器<strong>都有自己的高速缓存</strong>，而<strong>它们又共享同一主内存</strong>（Main Memory），如图12-1所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及DragonProtocol等。</p><h3 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h3><p>内存模型可以理解为<strong>在特定的操作协议（上述协议）下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。</p><p>不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_39/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86%E5%99%A8%E4%BA%A4%E4%BA%92.png?raw=true" alt="处理器、高速缓存、主内存间的交互关系"></p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。</p><p>与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。</p><blockquote><p> 对处理器的重排序感兴趣的同学可以去看看《深入理解计算机系统》的第 4 章 处理器体系架构</p></blockquote><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>之所以有 Java 内存模型（Java Memory Model，JMM）存在的意义是为了屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java 内存模型的<strong>主要目标是定义程序中各个变量的访问规则</strong>，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它<strong>包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，<strong>Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</strong></p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_39/Java%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%BA%BF%E7%A8%8B%E4%BA%A4%E4%BA%92.png?raw=true" alt="线程、主内存、工作内存三者的交互关系"></p><p>Java 内存模型规定了<strong>所有的变量都存储在主内存</strong>（MainMemory）中（非系统主内存，虚拟机内存一部分）。<strong>每条线程还有自己的工作内存</strong>（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，<strong>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行</strong>，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>，线程、主内存、工作内存三者的交互关系如图所示。</p><h3 id="内存见交互操作"><a href="#内存见交互操作" class="headerlink" title="内存见交互操作"></a>内存见交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，<strong>虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的</strong>（对于 double 和 long 类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。</p><ul><li>lock（锁定）：作用于主内存的变量，它<strong>把一个变量标识为一条线程独占的状态</strong>。   </li><li>unlock（解锁）：作用于主内存的变量，它<strong>把一个处于锁定状态的变量释放出来</strong>，释放后的变量才可以被其他线程锁定。   </li><li>read（读取）：作用于主内存的变量，它<strong>把一个变量的值从主内存传输到线程的工作内存中</strong>，以便随后的load动作使用。   </li><li>load（载入）：作用于工作内存的变量，它<strong>把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</strong>   </li><li>use（使用）：作用于工作内存的变量，它<strong>把工作内存中一个变量的值传递给执行引擎</strong>，<strong>每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</strong>   </li><li>assign（赋值）：作用于工作内存的变量，它<strong>把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</strong>   </li><li>store（存储）：作用于工作内存的变量，它<strong>把工作内存中一个变量的值传送到主内存中</strong>，以便随后的write操作使用。   </li><li>write（写入）：作用于主内存的变量，它<strong>把store操作从工作内存中得到的变量的值放入主内存的变量中</strong>。</li></ul><p>略解释一下以上的操作：</p><ul><li>把一个变量从主内存复制到工作内存： 顺序执行 read、 load</li><li>把一个变量从工作内存同步回主内存：顺序执行 store、 write</li></ul><p>注意<strong>『顺序执行』不代表是连续执行</strong>。</p><p>除此之外，Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则：</p><ul><li>不允许 read 和 load、store 和 write 操作之一单独出现，即<strong>不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现</strong>。</li><li>不允许一个线程丢弃它的最近的 assign 操作，即<strong>变量在工作内存中改变了之后必须把该变化同步回主内存</strong>。</li><li><strong>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中</strong>。</li><li><strong>一个新的变量只能在主内存中『诞生』</strong>，不允许在工作内存中直接使用一个未被初始化（ load 或 assign ）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。</li><li>一<strong>个变量在同一个时刻只允许一条线程对其进行 lock 操作</strong>，但 lock 操作可以被同一条线程重复执行多次，<strong>多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</strong>。   </li><li><strong>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</strong>   </li><li><strong>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</strong>   </li><li><strong>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中</strong>（执行 store、write 操作）。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>当一个变量定义为 volatile 之后，它将具备两种特性</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>保证此变量对所有线程的<strong>可见性</strong>，这里的『可见性』是<strong>指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</strong>。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。</p><p>可见性常被误解，认为以下描述成立：『volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的』。这句话的论据部分并没有错，但是<strong>其论据并不能得出『基于volatile变量的运算在并发下是安全的』</strong>。</p><p><strong>volatile 变量在各个线程的工作内存中不存在一致性问题</strong>（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。我们可以看看下面这个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increaes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADES_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADES_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;THREADES_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        increaes();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码发起了 20 个线程，每个对 race 进行了 10000 次自增操作，如果这段代码正确运行的话，结果应该是 200000 ，但总是会事与愿违。</p><blockquote><p> 这儿有一点特别奇怪，我在 idea 上面运行上述代码发现一直不能停止，后面试了试 Thread.activeCount() 的值，发现我这边不开启任何子线程数值都是 2。然后将当前线程组打印出来。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;      System.out.println(Thread.activeCount());</span><br><span class="line">&gt;          ThreadGroup group = Thread.currentThread().getThreadGroup();</span><br><span class="line">&gt;          group.list();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p> 结果如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  2</span><br><span class="line">&gt;  java.lang.ThreadGroup[name=main,maxpri=10]</span><br><span class="line">&gt;      Thread[main,5,main]</span><br><span class="line">&gt;      Thread[Monitor Ctrl-Break,5,main]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p> 然后根据去 Monitor Ctrl-Break 查资料发现</p><p> java 实际开始运行的类是com.intellij.rt.execution.application.AppMain。AppMain 通过反射调用我们写的类，还会创建另一个名叫 Monitor Ctrl-Break 的线程，从名字看应该是监控 Ctrl-Break 中断信号的。</p><p> <a href="https://www.zhihu.com/question/59297272" target="_blank" rel="noopener">https://www.zhihu.com/question/59297272</a></p><p> 还蛮有趣的</p></blockquote><p>问题就出现在自增运算『race++』之中，我们用 Javap 反编译这段代码后会得到下面的代码，发现只有一行代码的<code>increase()</code> 方法在 Class 文件中是由4条字节码指令构成的（return 指令不是由 race++ 产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当 getstatic 指令把 race 的值取到操作栈顶时，volatile 关键字保证了 race 的值在此时是正确的，但是在执行 iconst_1、iadd 这些指令的时候，其他线程可能已经把 race 的值加大了，而在操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 race 值同步回主内存之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increaes</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">       0: getstatic     #2                  // Field race:I</span><br><span class="line">       <span class="number">3</span>: iconst_1</span><br><span class="line">       <span class="number">4</span>: iadd</span><br><span class="line">       5: putstatic     #2                  // Field race:I</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure><p>客观来说这样也不严谨，因为字节码的一个指令也并不意味这是一个院子操作。</p><p>由于volatile变量只能保证可见性，在<strong>不符合以下两条规则的运算场景中，我们仍然要通过加锁</strong>（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><h4 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h4><blockquote><p> 可查看文章开头的 <strong>volatile变量法则</strong></p></blockquote><p>使用 volatile 变量的第二个语义是<strong>禁止指令重排序优化</strong>，<strong>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</strong>。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。</p><p>上述有些不太好理解，那么我们就看实例吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为 volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程 A 中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><p>如果定义 initialized 变量时没有使用 volatile 修饰，就可能会由于指令重排序的优化，<strong>导致位于线程 A 中最后一句的代码<code>initialized=true</code> 被提前执行</strong>（这里虽然使用 Java 作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程 B 中使用配置信息的代码就可能出现错误，而 volatile 关键字则可以避免此类情况的发生。</p><p>下面这个例子说明一下 <strong>volatile 关键字是如何禁止指令重排序优化</strong>的。下面是一段标准的 DCL 单例代码，可观察加入 volatile 和未加入 volatile 关键字时所生成汇编代码的差别。(使用 HSDIS )（我们就通过行数找）</p><p>加入前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x00000001086f3207: movabs $0x107ba5abe,%r10</span><br><span class="line">0x00000001086f3211: callq  *%r10              ;*monitorexit</span><br><span class="line">                                              ; - VolatileSingleton::getInstance@28 (line 14)</span><br><span class="line"></span><br><span class="line">0x00000001086f3214: jmpq   0x00000001086f2fe6  ;*new</span><br><span class="line">                                              ; - VolatileSingleton::getInstance@17 (line 12)</span><br><span class="line"></span><br><span class="line">0x00000001086f3219: mov    %rax,%rbx</span><br><span class="line">0x00000001086f321c: jmp    0x00000001086f3221  ;*invokespecial &lt;init&gt;</span><br><span class="line">                                              ; - VolatileSingleton::getInstance@21 (line 12)</span><br><span class="line"></span><br><span class="line">0x00000001086f321e: mov    %rax,%rbx</span><br></pre></td></tr></table></figure><p>加入后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x000000010eff4100: mov    (%rsp),%r10</span><br><span class="line">0x000000010eff4104: shr    $0x3,%r10</span><br><span class="line">0x000000010eff4108: movabs $0x76ab81e48,%r11  ;   &#123;oop(a &apos;java/lang/Class&apos; = &apos;VolatileSingleton&apos;)&#125;</span><br><span class="line">0x000000010eff4112: mov    %r10d,0x68(%r11)</span><br><span class="line">0x000000010eff4116: movabs $0x76ab81e48,%r10  ;   &#123;oop(a &apos;java/lang/Class&apos; = &apos;VolatileSingleton&apos;)&#125;</span><br><span class="line">0x000000010eff4120: shr    $0x9,%r10</span><br><span class="line">0x000000010eff4124: movabs $0x1038b7000,%r11</span><br><span class="line">0x000000010eff412e: mov    %r12b,(%r11,%r10,1)</span><br><span class="line">0x000000010eff4132: lock addl $0x0,(%rsp)     ;*putstatic instance</span><br><span class="line">                                              ; - VolatileSingleton::getInstance@24 (line 12)</span><br></pre></td></tr></table></figure><p>虽然看不是很懂，但是还是很明显有一个重排序的区别以及 <code>lock addl $0x0,(%rsp)</code> 这个操作在赋值后（<code>mov    (%rsp),%r10</code>）的区别。</p><p>这个操作相当于一个<strong>内存屏障</strong>（Memory Barrier 或 Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个 CPU 访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。</p><blockquote><p> 内存屏障</p><p> 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br> 内存屏障可以被分为以下几种类型</p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p><p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_39/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png?raw=true" alt="内存屏障"></p></li></ul></blockquote><p>在某些情况下，volatile 的同步机制的性能确实要优于锁（使用 synchronized 关键字或 java.util.concurrent 包里面的锁），但是由于<strong>虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为 volatile 就会比 synchronized 快多少</strong>。如果让volatile自己与自己比较，那可以确定一个原则：<strong>volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些</strong>，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下 volatile 的总开销仍然要比锁低，我<strong>们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求</strong>。</p><h4 id="JOJO，这是我最后的实例了"><a href="#JOJO，这是我最后的实例了" class="headerlink" title="JOJO，这是我最后的实例了"></a>JOJO，这是我最后的实例了</h4><p>最后，我们回顾一下 Java 内存模型中对 volatile 变量定义的特殊规则。假定 T 表示一个线程，V 和 W 分别表示两个 volatile 型变量，那么在进行 read、load、use、assign、store 和 write 操作时需要满足如下规则：</p><ul><li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值）。（<strong>线程中 use 在 load 之后，只有后面出现 use 才能出现 load，use 可以理解与 load、read 必须一起连续出现</strong>）。</li><li>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改）。（<strong>线程中 store 在 assign 之后，只有后面出现 store 才能出现 assign，assign 可以理解与 store、write 必须一起连续出现</strong>）</li><li>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或as-sign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）。</li></ul><h3 id="对于-long-和-double-变量的特殊规则"><a href="#对于-long-和-double-变量的特殊规则" class="headerlink" title="对于 long 和 double 变量的特殊规则"></a>对于 long 和 double 变量的特殊规则</h3><p>Java内存模型要求 lock、unlock、read、load、assign、use、store、write 这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的 load、store、read 和 write 这4个操作的原子性，这点就是所谓的 <strong>long 和 double 的非原子性协定</strong>（Nonatomic Treatment ofdouble and long Variables）。</p><p>Java 内存模型虽然允许虚拟机不把 long 和 double 变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还『强烈建议』虚拟机这样实现。在实际开发中，目前<strong>各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待</strong>，因此我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile。</p><h3 id="原子性，可见性与有序性"><a href="#原子性，可见性与有序性" class="headerlink" title="原子性，可见性与有序性"></a>原子性，可见性与有序性</h3><p><strong>Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这 3 个特征来建立的</strong>，我们逐个来看一下哪些操作实现了这 3 个特性。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write，我们大致可以认为基本数据类型的访问读写是具备原子性的。</p><p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却<strong>提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性</strong>。</p><h4 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是<strong>通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的</strong>，无论是普通变量还是volatile变量都是如此，普通变量与 volatile 变量的区别是，<strong>volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</strong>。因此，可以说 <strong>volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点</strong>。</p><p>除了 volatile 之外，Java 还有两个关键字能实现可见性</p><ul><li>synchronized。同步块的可见性是由『对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）』这条规则获得的</li><li>final。被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把『this』的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到『初始化了一半』的对象），那在其他线程中就能看见 final 字段的值。</li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java程序中天然的有序性可以总结为一句话：<strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。</strong></p><p>前半句是指“线程内表现为串行的语义”（Within-Thread As-If-SerialSemantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><p><strong>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性</strong>，volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由『一个变量在同一个时刻只允许一条线程对其进行lock操作』这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p><blockquote><p> 介绍完并发中 3 种重要的特性后，读者有没有发现 synchronized 关键字在需要这 3 种特性的时候都可以作为其中一种的解决方案？看起来很『万能』吧。的确，大部分的并发控制操作都能使用 synchronized 来完成。synchronized 的『万能』也间接造就了它被程序员滥用的局面，<strong>越『万能』的并发控制，通常会伴随着越大的性能影响</strong>。</p></blockquote><h4 id="Java-中重排序-happens-before-规则"><a href="#Java-中重排序-happens-before-规则" class="headerlink" title="Java 中重排序 happens-before 规则"></a>Java 中重排序 happens-before 规则</h4><p>Happens-before 的前后两个操作不会被重排序且后者对前者的内存可见。</p><ul><li><strong>程序次序法则</strong>：线程中的每个动作 A 都 happens-before 于该线程中的每一个动作 B，其中，在程序中，所有的动作 B 都能出现在 A 之后。</li><li><strong>监视器锁法则</strong>：对一个监视器锁的解锁 happens-before 于每一个后续对同一监视器锁的加锁。</li><li><strong>volatile变量法则</strong>：对 volatile 域的写入操作 happens-before 于每一个后续对同一个域的读写操作。</li><li><strong>线程启动法则</strong>：在一个线程里，对 Thread.start 的调用会 happens-before 于每个启动线程的动作。</li><li><strong>线程终结法则</strong>：线程中的任何动作都 happens-before 于其他线程检测到这个线程已经终结、或者从 Thread.join 调用中成功返回，或 Thread.isAlive 返回 false。</li><li><strong>中断法则</strong>：一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断。</li><li><strong>终结法则</strong>：一个对象的构造函数的结束 happens-before 于这个对象finalizer的开始。</li><li><strong>传递性</strong>：如果 A happens-before 于 B，且 B happens-before 于 C，则 A happens-before 于 C</li></ul><p>这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><h5 id="实例（『时间上的先后顺序』与『happens-before』之间的不同）"><a href="#实例（『时间上的先后顺序』与『happens-before』之间的不同）" class="headerlink" title="实例（『时间上的先后顺序』与『happens-before』之间的不同）"></a>实例（『时间上的先后顺序』与『happens-before』之间的不同）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个普通的 bean 操作，存在线程 A 和 B，线程 A 先（时间上的先后）调用了<code>setValue(1)</code>，然后线程 B 调用了同一个对象的<code>getValue()</code>，那么线程B收到的返回值是什么？</p><p>这里分析一下 happens-before 的各种规则。</p><ol><li>由于两个方法分别由线程 A 和线程 B 调用，不在一个线程中，所以程序次序规则在这里不适用；</li><li>由于没有同步块，自然就不会发生 lock 和 unlock 操作，所以管程锁定规则不适用；</li><li>由于 value 变量没有被 volatile 关键字修饰，所以 volatile 变量规则不适用；</li><li>后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系；</li><li>因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起。</li></ol><p>因此我们可以判定尽管线程 A 在操作时间上先于线程 B，但是无法确定线程 B 中<code>getValue()</code>方法的返回结果，换句话说，这里面的操作不是线程安全的。</p><p>通过上面的例子，我们可以得出结论：一个操作“时间上的先发生”不代表这个操作会是“先行发生”，那如果一个操作“先行发生”是否就能推导出这个操作必定是『时间上的先发生』呢？<strong>很遗憾，这个推论也是不成立的</strong>，一个典型的例子就是多次提到的“指令重排序”。看下面这个简单代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下操作在同一个线程中执行</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>根据程序次序规则，<code>int i=1</code> 的操作先行发生于 <code>int j=2</code>，但是 <code>intj=2</code> 的代码完全可能先被处理器执行，这并不影响 happens-before 原则的正确性，因为我们在这条线程之中没有办法感知到这点。</p><p>时间先后顺序与 happens-before 原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以 happens-before 原则为准。</p><h2 id="Java-与线程"><a href="#Java-与线程" class="headerlink" title="Java 与线程"></a>Java 与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>我们知道，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。</p><p>主流的操作系统都提供了线程实现，Java 语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行 start() 且还未结束的 java.lang.Thread 类的实例就代表了一个线程。我们注意到 Thread 类与大部分的Java API有显著的差别，它的所有关键方法都是声明为 Native 的。在 Java API 中，一个 Native 方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用 Native 方法，不过，通常最高效率的手段也就是平台相关的手段）。</p><p>实现线程主要有3种方式：<strong>使用内核线程实现</strong>、使用<strong>用户线程实现</strong>和使用<strong>用户线程加轻量级进程混合实现</strong>。</p><h4 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h4><p>内核线程（Kernel-Level Thread, KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，<strong>这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上</strong>。<strong>每个内核线程可以视为内核的一个分身</strong>，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。</p><p>程序一般不会直接去使用内核线程，而是去<strong>使用内核线程的一种高级接口——轻量级进程</strong>（Light Weight Process, LWP），轻量级进程就是我们通常意义上所讲的线程，由于<strong>每个轻量级进程都由一个内核线程支持</strong>，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间 1:1 的关系称为一对一的线程模型。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_39/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB.png?raw=true" alt="轻量级进程与内核线程之间 1:1 的关系"></p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作。</p><p>但是轻量级进程具有它的局限性：</p><ul><li>首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。</li><li>其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</li></ul><h4 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h4><p>狭义上的用户线程指的是<strong>完全建立在用户空间的线程库上</strong>，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。<strong>如果程序实现得当，这种线程不需要切换到内核态</strong>，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间 1:N 的关系称为一对多的线程模型。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_39/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB.png?raw=true" alt="进程与用户线程之间的关系"></p><p>使用用户线程的<strong>优势在于不需要系统内核支援</strong>，<strong>劣势也在于没有系统内核的支援</strong>，所有的线程操作都需要用户程序自己处理。</p><h4 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h4><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，<strong>既存在用户线程，也存在轻量级进程</strong>。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而<strong>操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险</strong>。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_39/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png?raw=true" alt="用户线程与轻量级进程之间的关系"></p><h4 id="Java-线程的实现"><a href="#Java-线程的实现" class="headerlink" title="Java 线程的实现"></a>Java 线程的实现</h4><p>在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了 Java 虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定 Java 线程需要使用哪种线程模型来实现。线程模型只对线程的并发规模和操作成本产生影响，对 Java 程序的编码和运行过程来说，这些差异都是透明的。</p><p>Java SE 最常用的 JVM 是 Oracle/Sun 研发的 HotSpot VM。在这个 JVM 的较新版本所支持的所有平台上，它都是使用 1:1 线程模型的——除了Solaris之外，它是个特例。</p><p>这是HotSpot VM在Solaris上所支持的线程模型：<a href="http://www.oracle.com/technetwork/java/threads-140302.html" target="_blank" rel="noopener">Java(TM) and Solaris(TM) Threading</a></p><h3 id="Java-线程调度"><a href="#Java-线程调度" class="headerlink" title="Java 线程调度"></a>Java 线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Schedul-ing）。<strong>Java使用的线程调度方式就是抢占式调度。</strong></p><h4 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h4><p>线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。</p><p>协同式多线程的<strong>最大好处是实现简单</strong>，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。Lua语言中的“协同例程”就是这类实现。它的<strong>坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里</strong>。</p><h4 id="抢占式线程调度"><a href="#抢占式线程调度" class="headerlink" title="抢占式线程调度"></a>抢占式线程调度</h4><p>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下。</p><ul><li>New：创建后尚未启动的线程处于这种状态。   </li><li>Runable：Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是<strong>处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间</strong>。   </li><li>Waiting：<strong>处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。</strong>以下方法会让线程陷入无限期的等待状态：   <ul><li>没有设置Timeout参数的Object.wait()方法。</li><li>没有设置Timeout参数的Thread.join()方法。</li><li>LockSup-port.park()方法。   </li></ul></li><li>Timed Waiting：<strong>处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒</strong>。以下方法会让线程进入限期等待状态：<ul><li>Thread.sleep()方法。   </li><li>设置了Timeout参数的Object.wait()方法。   </li><li>设置了Timeout参数的Thread.join()方法。   </li><li>LockSupport.parkNanos()方法。</li><li>LockSupport.parkUntil()方法。</li></ul></li><li>Blocked：线程被阻塞了，<strong>『阻塞状态』与『等待状态』的区别是：『阻塞状态』在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而『等待状态』则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</strong>   </li><li>Terminated：已终止线程的线程状态，线程已经结束执行。</li></ul><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_39/%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%E5%9B%BE.png?raw=true" alt="线程状态转换关系"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>《深入理解 Java 虚拟机》</p><p>《深入理解计算机系统》</p><p><a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">Java内存访问重排序的研究</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;预热&quot;&gt;&lt;a href=&quot;#预热&quot; class=&quot;headerlink&quot; title=&quot;预热&quot;&gt;&lt;/a&gt;预热&lt;/h2&gt;&lt;p&gt;所谓并发的时代，其实不仅仅提现在并发友好的库、框架、语言在兴起，而是这种并发的思想，早已融入到计算机最底层中了。&lt;/p&gt;
&lt;p&gt;『让计算机并发执行若干个运算任务』与『更充分地利用计算机处理器的效能』之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是绝大多数的&lt;strong&gt;运算任务都不可能只靠处理器『计算』就能完成&lt;/strong&gt;，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。&lt;/p&gt;
&lt;p&gt;由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不&lt;strong&gt;加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲&lt;/strong&gt;：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当&lt;strong&gt;运算结束后再从缓存同步回内存之中&lt;/strong&gt;，这样处理器就无须等待缓慢的内存读写了。&lt;/p&gt;
&lt;p&gt;嫌上面文字太长了，&lt;strong&gt;简单说来&lt;/strong&gt;就是：计算机计算太快了，等不及慢的主存了，加了 L3、L2、L1 以及寄存器4个高速缓存就是为了让 IO 能快点。&lt;/p&gt;
&lt;p&gt;由此产生出了一个问题&lt;/p&gt;
    
    </summary>
    
      <category term="基础原理" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码解析-容器的功能扩展-后续</title>
    <link href="http://yoursite.com/2017/11/26/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95-%E5%90%8E%E7%BB%AD/"/>
    <id>http://yoursite.com/2017/11/26/Spring-源码解析-容器的功能扩展-后续/</id>
    <published>2017-11-25T17:19:40.000Z</published>
    <updated>2017-11-25T17:20:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文承接自： <a href="https://binglau7.github.io/2017/11/25/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95-BeanFactory%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener">Spring-源码解析-容器的功能扩展-BeanFactory功能扩展</a></p><p>依照前文继续分析: <code>AbstractApplicationContext#refresh()</code></p><h2 id="BeanFactory-的后处理"><a href="#BeanFactory-的后处理" class="headerlink" title="BeanFactory 的后处理"></a>BeanFactory 的后处理</h2><p>BeanFacotry 作为 Spring 中容器功能的基础，用于存放所有已经加载的 bean，为了保证程序上的高可扩展性，Spring 针对 BeanFactory 做了大量的扩展，比如我们熟知的 PostProcessor 等都是在这里实现的。</p><a id="more"></a><h3 id="激活注册的-BeanFactoryPostProcessor"><a href="#激活注册的-BeanFactoryPostProcessor" class="headerlink" title="激活注册的 BeanFactoryPostProcessor"></a>激活注册的 BeanFactoryPostProcessor</h3><p><code>BeanFactoryPostProcessor</code> 接口跟 <code>BeanPostProcessor</code> 类似，可以对 bean 的定义（配置元数据）进行处理。也就是说，Spring IoC 容器允许 <code>BeanFactoryPostProcessor</code> 在容器实际实例化任何其他的 bean 之前读取配置元数据，并有可能修改它。如果你愿意，你可以配置多个 <code>BeanFactoryPostProcessor</code>。你还能通过设置 order 属性来控制 <code>BeanFactoryPostProcessor</code> 的执行次序（仅当 <code>BeanFactoryPostProcessor</code> 实现了<code>Ordered</code> 接口时你才可以设置此属性，因此在实现 <code>BeanFactoryPostProcessor</code> 时，就应当考虑实现 <code>Ordered</code> 接口）。</p><p>如果你想改变实际的 bean 实例（例如从配置元数据创建的对象），那么你最好使用 <code>BeanPostProcessor</code>。同样地，<code>BeanFactoryPostProcessor</code> 的作用域范围是容器级的。它只和你所使用的容器有关。如果你在容器中定义一个 <code>BeanFactoryPostProcessor</code>，它仅仅对此容器中的 bean 进行后置处理。<code>BeanFactoryPostProcessor</code> 不会对定义在另一个容器中的 bean 进行后置处理，即使这两个容器都是在同一层次上。</p><h4 id="BeanFactoryPostProcessor-的典型应用：PropertyPlaceholderConfigurer"><a href="#BeanFactoryPostProcessor-的典型应用：PropertyPlaceholderConfigurer" class="headerlink" title="BeanFactoryPostProcessor 的典型应用：PropertyPlaceholderConfigurer"></a>BeanFactoryPostProcessor 的典型应用：PropertyPlaceholderConfigurer</h4><p>指定配置文件使用。</p><p><code>PropertyPlaceholderConfigurer</code> 这个类间接继承了 <code>BeanFactoryPostProcessor</code> 接口。这是一个很特别的接口，当 Spring 加载任何实现了这个接口的 bean 的配置时，都会在 bean 工厂载入所有 bean 的配置之后执行 <code>postProcessBeanFactory</code> 方法。在 <code>PropertyResourceConfigurer</code> 类中实现了 <code>postProcessBeanFactory</code> 方法，在方法中先后调用了<code>mergeProperties</code>、<code>convertProperties</code>、<code>processProperties</code> 这3个方法，分别得到配置，将得到的配置，将得到的配置转换为合适的类型，最后将配置内容告知 <code>BeanFactory</code>。</p><h3 id="激活-BeanFactoryPostProcessor"><a href="#激活-BeanFactoryPostProcessor" class="headerlink" title="激活 BeanFactoryPostProcessor"></a>激活 BeanFactoryPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"><span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 对 BeanDefinitionRegistry 类型的处理</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> LinkedList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors =</span><br><span class="line"><span class="keyword">new</span> LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 硬编码注册的后处理器</span></span><br><span class="line">            <span class="comment">// 这里有个疑问，书上应该是 Spring 3 版本应该是在这里调用了 getBeanFactoryPostProcessors() </span></span><br><span class="line">            <span class="comment">// 而在当前 4.3.8 版本时候是在外部调用，而且整体函数被抽离</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"><span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">BeanDefinitionRegistryPostProcessor registryPostProcessor =</span><br><span class="line">(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                     <span class="comment">// 对于 BeanDefinitionRegistryPostPorcessor 类型，在 BeanFactoryPostProcessor</span></span><br><span class="line">                     <span class="comment">// 的基础 上还有自己定义的方法，需要先调用</span></span><br><span class="line">registryPostProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryPostProcessors.add(registryPostProcessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 记录常规 BeanFactoryPostProcessor</span></span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"><span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line"><span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">            <span class="comment">// 1. 这里是之前篇章提过的在之前功能扩展中注册 ApplicationListenerDetector 的意义所在</span></span><br><span class="line">            <span class="comment">// 2. 对于配置中读取的 BeanFactoryPostProcessor 的处理</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">            <span class="comment">// 首先处理实现 PriorityOrdered 的 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 优先级排序</span></span><br><span class="line">sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">            <span class="comment">// 加入 registryPostProcessors</span></span><br><span class="line">registryPostProcessors.addAll(priorityOrderedPostProcessors);</span><br><span class="line">          <span class="comment">// 激活 BeanDefinitionRegistryPostProcessors 优先级部分</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">registryPostProcessors.addAll(orderedPostProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">            <span class="comment">// 添加其他类型的 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="keyword">false</span>;</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);</span><br><span class="line">registryPostProcessors.add(pp);</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">pp.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">reiterate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">            <span class="comment">// 激活 postProcessBeanFactory 方法，之前激活的是 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);</span><br><span class="line">            <span class="comment">// 常规 BeanFactoryPostProcessor</span></span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// 对于配置读取的 BeanFactoryPostProcessor 的处理</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">        <span class="comment">// 对后处理器进行分类</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 已经处理过的，处理 BeanDefinitionRegistery 的时候(应该叫已经添加到处理序列中)</span></span><br><span class="line"><span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line"><span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">        <span class="comment">// 按优先级进行排序</span></span><br><span class="line">sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 按 order 进排序</span></span><br><span class="line">sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">        <span class="comment">// 无序，直接调用</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"><span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>BeanFactoryPostProcessor</code> 的处理主要分两种情况进行，一个是对于 <code>BeanDefinitionRegistry</code> 类的特殊处理，另一种是对普通的 <code>BeanFactoryPostProcessor</code> 进行处理。而对于<strong>每种情况都需要考虑硬编码注入注册的后处理器以及通过配置注入的后处理器</strong>。</p><p>对于 <code>BeanDefinitionRegistry</code> 类型的处理类的处理主要包括以下内容。</p><ol><li><p>对于硬编码注册的后处理器的处理，主要是通过 <code>AbstractApplicationContext</code> 中的添加处理器方法<code>addBeanFactoryPostProcessor</code> 进行添加。</p><p>添加后的处理器会存放入 <code>beanFactoryPostProcessors</code> 中，而在处理 <code>BeanFactoryPostProcessor</code> 时候会首先检测 <code>beanFactoryPostProcessor</code> 是否有数据。当然，<code>BeanDefinitionRegistryPostProcessor</code> 继承自 <code>BeanFactoryPostProcessor</code>，不但有 <code>BeanFactoryPostProcessor</code> 的特性，同事还有自己定义的个性化方法，也需要在此调用。所以，这里需要从 <code>beanFactoryPostProcessors</code> 中挑出 <code>BeanDefinitionRegistryPostProcessor</code> 的后处理器，并进行其 <code>postProcessBeanDefinitionRegistry</code> 方法的激活。</p></li><li><p>记录后处理器主要使用了三个 List 完成</p><ul><li><code>registryPostProcessors</code>：记录通过硬编码方式注册的 <code>BeanDefinitionRegistryPostProcessor</code> 类型的处理器。</li><li><code>regularPostProcessors</code>：记录通过硬编码方式注册的 <code>BeanFactoryPostProcessor</code> 类型的处理器。</li><li><code>registryPostProcessorBeans</code>：记录通过配置方式注册的 <code>BeanDefinitionRegistryPostProcessor</code> 类型的处理器。</li></ul></li><li><p>对以上所记录的 List 中的后处理器进行统一调用 <code>BeanFactoryPostProcessor</code> 的 <code>postProcessBeanFactory</code> 方法。</p></li><li><p>对 <code>beanFactoryPostProcessors</code> 中非 <code>BeanDefinitionRegistryPostProcessor</code> 类型的后处理器进行统一的<code>BeanFactoryPostProcessor</code> 的 <code>postProcessBeanFactory</code> 方法调用。</p></li><li><p>普通 beanFactory 处理。</p></li></ol><h3 id="注册-BeanPostProcessor"><a href="#注册-BeanPostProcessor" class="headerlink" title="注册 BeanPostProcessor"></a>注册 BeanPostProcessor</h3><p>真正的调用是在 bean 的实例化阶段进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line"><span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line"><span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * BeanPostProcessorChecker 是一个普通的信息打印，可能会有些情况，</span></span><br><span class="line"><span class="comment">        * 当 Spring 的配置中的后处理器还没有被注册就已经开始了 bean 的初始化时</span></span><br><span class="line"><span class="comment">        * 便会打印出 BeanPostProcessorChecker 中设定的信息</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line"><span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">        <span class="comment">// 使用 PriorityOrdered 接口保证顺序</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">        <span class="comment">// MergedBeanDefinitionPostProcessor</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">        <span class="comment">// 使用 Ordered 接口保证顺序</span></span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 无序 BeanPostProcessor</span></span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">priorityOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">        <span class="comment">// 注册所有实现 PriorityOrdered 的 BeanPostProcessors</span></span><br><span class="line">sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">        <span class="comment">// 注册所有实现 Ordered 的 BeanPostProcessors</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">orderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">        <span class="comment">// 注册所有无序的 BeanPostProcessors</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">nonOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">        <span class="comment">// 注册所有 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor, 并非重复注册</span></span><br><span class="line">        <span class="comment">// 在 beanFactory.addBeanPostProcessor 中会先移除以及存在的 BeanPostProcessor</span></span><br><span class="line">sortPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line"><span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">        <span class="comment">// 添加 ApplicationListener 探测器</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比 <code>BeanFactoryPostProcessor</code> 的处理要区分两种情况，一种方式是通过硬编码方式的处理，另一种是通过配置文件方式的处理。</p><p>对于 <code>BeanFactoryPostProcessor</code> 的处理，不但要实现注册功能，而且<strong>还要实现对后处理器的激活操作</strong>，所以需要载入配置中的定义，并进行激活；而对于 <code>BeanPostProcessor</code> 并<strong>不需要马上调用</strong>，再说，硬编码的方式实现的功能是将后处理器提取并调用，这里并不需要调用，当然不需要考虑硬编码的方式了，这里的功能只需要将配置文件的 <code>BeanPostProcessor</code> 提取出来并注册进入 beanFactory 就可以了。</p><h3 id="初始化-ApplicationEventMulticaster"><a href="#初始化-ApplicationEventMulticaster" class="headerlink" title="初始化 ApplicationEventMulticaster"></a>初始化 ApplicationEventMulticaster</h3><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><ol><li><p>定义事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(Object source, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> TestEvent) &#123;</span><br><span class="line">            TestEvent testEvent = (TestEvent) event;</span><br><span class="line">            testEvent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testListener"</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.TestListener"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beanFactory.xml"</span>);</span><br><span class="line">    TestEvent event = <span class="keyword">new</span> TestEvent(<span class="string">"hello"</span>, <span class="string">"msg"</span>);</span><br><span class="line">    ctx.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><code>initApplicationEventMulticaster</code> 的方式比较简单，无非考虑两种情况。</p><ul><li>如果用户自定义了事件广播器，那么使用用户自定义的事件广播器。</li><li>如果用户没有自定义事件广播器，那么使用默认的 <code>ApplicationEventMulticaster</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line"><span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此推断其中默认实现的广播器 <code>SimpleApplicationEventMulticaster</code> 中有逻辑来存储监听器并在合适的时候调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以推断，当产生 Spring 事件的时候会默认使用 <code>SimpleApplicationEventMulticaster</code> 的 <code>multicastEvent</code> 来广播事件，遍历所有监听器，并使用监听器中的 <code>onApplicationEvent</code> 方法来进行监听器的处理。而对于每个监听器来说其实都可以获取到产生的事件，但是是否进行处理则由事件监听器来决定。</p><h3 id="注册监听器"><a href="#注册监听器" class="headerlink" title="注册监听器"></a>注册监听器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">        <span class="comment">// 硬编码方式注册的监听器处理</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// 配置文件注册的监听器处理</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">        <span class="comment">// 提前发布一些消息告诉我们已经有了一个广播器</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化非延迟加载单例"><a href="#初始化非延迟加载单例" class="headerlink" title="初始化非延迟加载单例"></a>初始化非延迟加载单例</h2><p>完成 BeanFactory 的初始化工作，其中包括 ConversionService 的设置、配置冻结以及非延迟加载的 bean 的初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line"><span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line"><span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">        <span class="comment">// 冻结所有的 bean 定义，说明注册的 bean 定义将不被修改或任何进一步的处理</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">        <span class="comment">// 初始化剩下的单实例(非惰性)</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConversionService-的设置"><a href="#ConversionService-的设置" class="headerlink" title="ConversionService 的设置"></a>ConversionService 的设置</h3><p>之前我们提到过使用自定义类型转换器，那么，在Spring中还提供了另一种转换方式：使用 <code>Converter</code>。</p><h4 id="具体使用-1"><a href="#具体使用-1" class="headerlink" title="具体使用"></a>具体使用</h4><ol><li><p>定义转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String2DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">LocalDate</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> DateTimeFormatter formatter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalDate.parse(source, formatter);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"conversionService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"converters"</span>&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"io.github.binglau.String2DateConverter"</span> /&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试（方便起见直接调用测试）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">    conversionService.addConverter(<span class="keyword">new</span> String2DateConverter());</span><br><span class="line"></span><br><span class="line">    LocalDate date = conversionService.convert(<span class="string">"2017-09-22"</span>, LocalDate.class);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="冻结配置"><a href="#冻结配置" class="headerlink" title="冻结配置"></a>冻结配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freezeConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.configurationFrozen = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化非延迟加载"><a href="#初始化非延迟加载" class="headerlink" title="初始化非延迟加载"></a>初始化非延迟加载</h3><p><code>ApplicationContext</code> 实现的默认行为就是在启动时将所有单例 bean 提前进行实例化。提前实例化意味着作为初始化过程的一部分，<code>ApplicationContext</code> 实例会创建并配置所有的单例 bean。通常情况下这是一件好事，因为这样在配置中的任何错误就会即刻被发现（否则的话可能要花几个小时甚至几天）。而这个实例化的过程就是在 <code>finishBeanFactoryInitialization</code> 中完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line"><span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line"><span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="keyword">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h2><p>在 Spring 中还提供了 <code>Lifecycle</code> 接口，<code>Lifecycle</code> 中包含 <code>start/stop</code> 方法，实现此接口后 Spring 会保证在启动的时候调用其 start 方法开始生命周期，并在 Spring 关闭的时候调用 stop 方法来结束生命周期，通常用来配置后台程序，在启动后一直运行（如对 MQ 进行轮询等）。而 <code>ApplicationContext</code> 的初始化最后正是保证了这一功能的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish the final event.</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initLifecycleProcessor"><a href="#initLifecycleProcessor" class="headerlink" title="initLifecycleProcessor"></a>initLifecycleProcessor</h3><p>当 ApplicationContext 启动或停止时，它会通过 <code>LifecycleProcessor</code> 来与所有声明的 bean 的周期做状态检查，而 <code>LifecycleProcessor</code> 的使用前首先需要初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using LifecycleProcessor ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to locate LifecycleProcessor with name '"</span> +</span><br><span class="line">LIFECYCLE_PROCESSOR_BEAN_NAME +</span><br><span class="line"><span class="string">"': using default ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>启动所有实现了 <code>Lifecycle</code> 接口的 bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">startBeans(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBeans</span><span class="params">(<span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> HashMap&lt;Integer, LifecycleGroup&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, ? extends Lifecycle&gt; entry : lifecycleBeans.entrySet()) &#123;</span><br><span class="line">Lifecycle bean = entry.getValue();</span><br><span class="line"><span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line"><span class="keyword">int</span> phase = getPhase(bean);</span><br><span class="line">LifecycleGroup group = phases.get(phase);</span><br><span class="line"><span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">group = <span class="keyword">new</span> LifecycleGroup(phase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">phases.put(phase, group);</span><br><span class="line">&#125;</span><br><span class="line">group.add(entry.getKey(), bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(phases.keySet());</span><br><span class="line">Collections.sort(keys);</span><br><span class="line"><span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">phases.get(key).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="publishEvent"><a href="#publishEvent" class="headerlink" title="publishEvent"></a>publishEvent</h3><p>当晚餐 ApplicationContext 初始化的时候，要通过 Spring 中的事件发布机制来发出 ContextRefreshedEvent 事件，以保证对应的监听器可以做进一步的逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Publishing event in "</span> + getDisplayName() + <span class="string">": "</span> + event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">ApplicationEvent applicationEvent;</span><br><span class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">applicationEvent = (ApplicationEvent) event;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;Object&gt;(<span class="keyword">this</span>, event);</span><br><span class="line"><span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish event via parent context as well...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerApplicationContext"><a href="#registerApplicationContext" class="headerlink" title="registerApplicationContext"></a>registerApplicationContext</h3><p>注册 LiveBeansView MBean（如果处于活动状态）</p><p>关于 LiveBeansView：</p><blockquote><p> Adapter for live beans view exposure, building a snapshot of current beans and their dependencies from either a local <code>ApplicationContext</code> (with a local <code>LiveBeansView</code> bean definition) or all registered ApplicationContexts (driven by the <a href="https://docs.spring.io/autorepo/docs/spring/4.2.1.RELEASE/javadoc-api/org/springframework/context/support/LiveBeansView.html#MBEAN_DOMAIN_PROPERTY_NAME" target="_blank" rel="noopener">“spring.liveBeansView.mbeanDomain”</a> environment property).</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerApplicationContext</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">String mbeanDomain = applicationContext.getEnvironment().getProperty(MBEAN_DOMAIN_PROPERTY_NAME);</span><br><span class="line"><span class="keyword">if</span> (mbeanDomain != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (applicationContexts) &#123;</span><br><span class="line"><span class="keyword">if</span> (applicationContexts.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">applicationName = applicationContext.getApplicationName();</span><br><span class="line">server.registerMBean(<span class="keyword">new</span> LiveBeansView(),</span><br><span class="line"><span class="keyword">new</span> ObjectName(mbeanDomain, MBEAN_APPLICATION_KEY, applicationName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Failed to register LiveBeansView MBean"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">applicationContexts.add(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文承接自： &lt;a href=&quot;https://binglau7.github.io/2017/11/25/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95-BeanFactory%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring-源码解析-容器的功能扩展-BeanFactory功能扩展&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;依照前文继续分析: &lt;code&gt;AbstractApplicationContext#refresh()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;BeanFactory-的后处理&quot;&gt;&lt;a href=&quot;#BeanFactory-的后处理&quot; class=&quot;headerlink&quot; title=&quot;BeanFactory 的后处理&quot;&gt;&lt;/a&gt;BeanFactory 的后处理&lt;/h2&gt;&lt;p&gt;BeanFacotry 作为 Spring 中容器功能的基础，用于存放所有已经加载的 bean，为了保证程序上的高可扩展性，Spring 针对 BeanFactory 做了大量的扩展，比如我们熟知的 PostProcessor 等都是在这里实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring-源码解析-容器的功能扩展-BeanFactory功能扩展</title>
    <link href="http://yoursite.com/2017/11/25/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95-BeanFactory%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/11/25/Spring-源码解析-容器的功能扩展-BeanFactory功能扩展/</id>
    <published>2017-11-25T05:39:14.000Z</published>
    <updated>2017-11-25T09:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前分析是建立在<code>BeanFactory</code>  接口以及它的实现类 <code>XmlBeanFactory</code> 来进行分析的， <code>ApplicationContext</code> 包含了 <code>BeanFactory</code> 的所有功能，多数情况我们都会使用 <code>ApplicationConetxt</code>。其加载方式如下:</p><p><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beanFactory.xml&quot;);</code></p><p>所以我们就以 <code>ClassPathXmlApplicationContext</code> 来作为分析的切入点：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(configLocations, refresh, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassPathXmlApplicationContext</code> 可以对数组进行解析并进行加载。而对于解析及功能实现都在 <code>refresh()</code> 中实现。</p><h2 id="设置配置路径"><a href="#设置配置路径" class="headerlink" title="设置配置路径"></a>设置配置路径</h2><p>在 <code>ClassPathXmlApplicationContext</code> 中支持多个配置文件以数组方式同时传入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... locations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数主要用于解析给定的路径数组，当然，如果数组中包含特殊符号，如<code>${var}</code>，那么在resolvePath中会搜寻匹配的系统变量并替换。</p><h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><p>置了路径之后，便可以根据路径做配置文件的解析以及各种功能的实现了。<strong>可以说 <code>refresh</code> 函数中包含了几乎 ApplicationContext 中提供的全部功能</strong>，而且此函数中逻辑非常清晰明了，使我们很容易分析对应的层次及逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">         <span class="comment">// 准备刷新的上下文环境</span></span><br><span class="line">prepareRefresh(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">         <span class="comment">// 初始化 BeanFactory，并进行 XML 文件读取</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">         <span class="comment">// 对 BeanFactory 进行各种功能填充</span></span><br><span class="line">prepareBeanFactory(beanFactory); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">              <span class="comment">// 子类覆盖方法做额外的处理</span></span><br><span class="line">postProcessBeanFactory(beanFactory); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 激活各种 BeanFactory 处理器</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">              <span class="comment">// 注册拦截 Bean 创建的 Bean 处理器，这里只是注册，真正的调用是在 getBean 时候</span></span><br><span class="line">registerBeanPostProcessors(beanFactory); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">              <span class="comment">// 为上下文初始化 Message 源，即不同语言的消息体，国际化处理</span></span><br><span class="line">initMessageSource(); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">              <span class="comment">// 初始化应用消息广播器，并放入 "applicationEventMulticaster" bean 中</span></span><br><span class="line">initApplicationEventMulticaster(); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">              <span class="comment">// 留给子类来初始化其他的 bean</span></span><br><span class="line">onRefresh(); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">              <span class="comment">// 在所有注册的 bean 中查找 Listerner bean，注册到消息广播器中</span></span><br><span class="line">registerListeners(); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">              <span class="comment">// 初始化剩下的单实例(非惰性的)</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">              <span class="comment">// 完成刷新过程，通知生命周期处理器 lifecycleProcessor 刷新过程，同时发出 ContextRefreshEvent 通知别人</span></span><br><span class="line">finishRefresh(); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>初始化前的准备工作，例如对系统属性或者环境变量进行准备及验证。</p><p>在某种情况下项目的使用需要读取某些系统变量，而这个变量的设置很可能会影响着系统的正确性，那么<code>ClassPathXmlApplicationContext</code>为我们提供的这个准备函数就显得非常必要，它可以在 Spring 启动的时候提前对必须的变量进行存在性验证。</p></li><li><p>初始化BeanFactory，并进行XML文件读取。</p><p>之前有提到<code>ClassPathXmlApplicationContext</code>包含着<code>BeanFactory</code>所提供的一切特征，那么在这一步骤中将会复用 <code>BeanFactory</code> 中的配置文件读取解析及其他功能，这一步之后， <code>ClassPathXmlApplicationContext</code> 实际上就已经包含了 <code>BeanFactory</code> 所提供的功能，也就是可以进行 Bean 的提取等基础操作了。</p></li><li><p>对BeanFactory进行各种功能填充。</p><p>@Qualifier与@Autowired应该是大家非常熟悉的注解，那么这两个注解正是在这一步骤中增加的支持。</p></li><li><p>子类覆盖方法做额外的处理。</p><p>Spring 之所以强大，除了它功能上为大家提供了便例外，还有一方面是它的完美架构，开放式的架构让使用它的程序员很容易根据业务需要扩展已经存在的功能。</p></li><li><p>激活各种BeanFactory处理器。</p></li><li><p>注册拦截bean创建的bean处理器，这里只是注册，真正的调用是在getBean时候。</p></li><li><p>为上下文初始化 Message 源，即对不同语言的消息体进行国际化处理。</p></li><li><p>初始化应用消息广播器，并放入 <code>applicationEventMulticaster</code> bean 中。</p></li><li><p>留给子类来初始化其他的bean。</p></li><li><p>在所有注册的bean中查找 listener bean，注册到消息广播器中。</p></li><li><p>初始化剩下的单实例（非惰性的）。</p></li><li><p>完成刷新过程，通知生命周期处理器<code>lifecycleProcessor</code>刷新过程，同时发出<code>ContextRefreshEvent</code>通知别人。</p></li></ol><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><code>prepareRefresh</code>函数主要是做些准备工作，例如对系统属性及环境变量的初始化及验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">   <span class="comment">// 留给子类覆盖</span></span><br><span class="line">initPropertySources();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line"><span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">     <span class="comment">// 验证需要的属性文件是否都已经放入环境中</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line"><span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>initPropertySources</code> 正符合 Spring 的开放式结构设计，给用户最大扩展 Spring 的能力。用户可以根据自身的需要重写 <code>initPropertySources</code> 方法，并在方法中进行个性化的属性处理及设置。</li><li><code>validateRequiredProperties</code> 则是通过继承重写的方式对属性进行验证。</li></ol><h2 id="加载-BeanFactory"><a href="#加载-BeanFactory" class="headerlink" title="加载 BeanFactory"></a>加载 BeanFactory</h2><p>经过 <code>obtainFreshBeanFactory</code> 之后 <code>ApplicationContext</code> 就已经拥有了 <code>BeanFactory</code> 的全部功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 初始化 BeanFactory，并进行 XML 文件读取，并将得到的 BeanFactory 记录在当前实体的属性中</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line">     <span class="comment">// 返回当前实体的 beanFactory 属性</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 创建 DefaultListableBeanFactory</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory(); <span class="comment">// 1</span></span><br><span class="line">         <span class="comment">// 为了序列化指定 id，如果需要的话，让这个 BeanFactory 从 id 反序列化到 BeanFactory 对象</span></span><br><span class="line">beanFactory.setSerializationId(getId()); <span class="comment">// 2</span></span><br><span class="line">         <span class="comment">// 定制 beanFactory，设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖</span></span><br><span class="line">customizeBeanFactory(beanFactory); <span class="comment">// 3</span></span><br><span class="line">         <span class="comment">// 初始化 DocumentReader，并进行 XML 文件读取及解析</span></span><br><span class="line">loadBeanDefinitions(beanFactory); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory; <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建 DefaultListableBeanFactory</li><li>指定序列化 ID</li><li>定制 BeanFactory</li><li>加载 BeanDefinition</li><li>使用全局变量记录 BeanFactory 类实例</li></ol><h3 id="定制-BeanFactory"><a href="#定制-BeanFactory" class="headerlink" title="定制 BeanFactory"></a>定制 <code>BeanFactory</code></h3><p>增加是否允许覆盖是否允许扩展的设置（通过子类覆盖）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果属性 allowBeanDefinitionOverriding 不为空，设置给 beanFactory 对象相应属性</span></span><br><span class="line">     <span class="comment">// 此属性的含义：是否允许覆盖同名称的不同定义的对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 如果属性 allowCircularReferences 不为空，设置给 beanFactory 对象相应属性，</span></span><br><span class="line">     <span class="comment">// 此属性的含义：是否允许 bean 之间存在循环依赖</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载-BeanDefinition"><a href="#加载-BeanDefinition" class="headerlink" title="加载 BeanDefinition"></a>加载 BeanDefinition</h3><p>与之前解析 <code>XmlBeanFactory</code> 一样，初始化 <code>DefaultListableBeanFactory</code> 之后需要 <code>XmlBeanDefinitionReader</code> 来读取 XML，接下来是初始化 <code>XmlBeanDefinitionReader</code> 的步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">     <span class="comment">// 为指定的 BeanFactory 创建 XmlBeanDefinitionReader</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line"><span class="comment">// resource loading environment.</span></span><br><span class="line">     <span class="comment">// 对 beanDefinitionReader 进行环境变量的设置</span></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line"><span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">     <span class="comment">// 对 BeanDefinitionReader 进行设置，可以覆盖</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化了 <code>DefaultListableBeanFactory</code> 和 <code>XmlBeanDefinitionReader</code> 后就可以进行配置文件的读取了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的套路之前基本都已经说到了。</p><h2 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h2><p>在进入函数 <code>prepareBeanFactory</code> 前，Spring 已经完成了对配置的解析，而 <code>ApplicationContext</code> 在功能上的扩展也由此展开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line">   <span class="comment">// 设置 beanFactory 的 classLoader 为当前 context 的 classLoader</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置 beanFactory 的表达式语言处理器，默认可使用 #&#123;bean.xxx&#125; 的形式来调用相关属性值</span></span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    <span class="comment">// 为beanFactory 增加了一个默认的 propertyEditor，这个主要是对 bean 的属性等设置管理的一个工具</span></span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">     <span class="comment">// 添加 BeanPostProcessor</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">     <span class="comment">// 设置了几个忽略自动装配的接口</span></span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">     <span class="comment">// 设置了几个自动装配的特殊规则</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">     <span class="comment">// 4.3.4 后添加的</span></span><br><span class="line">     <span class="comment">// 避免 BeanPostProcessor 被 getBeanNamesForType 调用</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">     <span class="comment">// 增加对 AspectJ 的支持</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line"><span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line">     <span class="comment">// 添加默认的系统环境 bean</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数主要进行了几个方面的扩展</p><ul><li>增加对<code>SPEL</code>语言的支持。</li><li>增加对属性编辑器的支持。</li><li>增加对一些内置类，比如<code>EnvironmentAware</code>、<code>MessageSourceAware</code>的信息注入。</li><li>设置了依赖功能可忽略的接口。</li><li>注册一些固定依赖的属性。</li><li>注册 <code>ApplicationListenerDetector</code></li><li>增加AspectJ的支持（会在后面进行详细的讲解）。</li><li>将相关环境变量及属性注册以单例模式注册。</li></ul><h3 id="增加-SPEL-语言的支持"><a href="#增加-SPEL-语言的支持" class="headerlink" title="增加 SPEL 语言的支持"></a>增加 SPEL 语言的支持</h3><p>在运行时构建复杂表达式、存取对象图属性、对象方法调用等，并且能与 Spring 功能完美整合，比如能用来配置bean 定义。SpEL 是单独模块，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</p><p>我们进入这个方法发现它只是简单指定了一个 <code>StandardBeanExpressionResolver</code> 进行语言解析器的注册，之后在我们之前说的 <code>bean</code> 进行初始化时候的属性填充时候会调用 <code>AbstractAutowireCapableBeanFactory</code> 类的 <code>applyPropertyValues</code> 函数来完成功能。同时，也是在这个步骤中一般通过 <code>AbstractBeanFactory</code> 中的 <code>evaluateBeanDefinitionString</code> 方法区完成 SPEL 的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">evaluateBeanDefinitionString</span><span class="params">(String value, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanExpressionResolver == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">Scope scope = (beanDefinition != <span class="keyword">null</span> ? getRegisteredScope(beanDefinition.getScope()) : <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.beanExpressionResolver.evaluate(value, <span class="keyword">new</span> BeanExpressionContext(<span class="keyword">this</span>, scope));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加属性注册编辑器"><a href="#增加属性注册编辑器" class="headerlink" title="增加属性注册编辑器"></a>增加属性注册编辑器</h3><p>对于自定义属性的注入如果在原生属性编辑器（<code>PropertyEditor</code>）不支持的情况下，可以使用两种方法：</p><ul><li><p>自定义属性编辑器</p><p>继承 <code>PropertyEditorSupport</code> 重写 <code>setAsText</code> 方法</p></li><li><p>注册 Spring 自带的属性编辑器 <code>CustomDateEditor</code></p></li></ul><p>在这里 <code>beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</code> 这段语句中我们可以探究一下 <code>ResourceEditorRegistrar</code> 的实现其中的 <code>doRegisterEditor</code> 方法中（被核心方法 <code>registerCustomEditors</code> 调用）可以看到提到了自定义属性中使用的关键代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRegisterEditor</span><span class="params">(PropertyEditorRegistry registry, Class&lt;?&gt; requiredType, PropertyEditor editor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> PropertyEditorRegistrySupport) &#123;</span><br><span class="line">((PropertyEditorRegistrySupport) registry).overrideDefaultEditor(requiredType, editor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">registry.registerCustomEditor(requiredType, editor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再回头看 <code>registerCustomEditors</code> 可以看到内部无非是注册了一系列的常用类型的属性编辑器。那什么时候能调用到它呢？</p><p>借助 idea 的调用链工具我们可以看到</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_37/ResourceEditorRegistrar%E7%9A%84registerCustomEditors%E6%96%B9%E6%B3%95.jpg?raw=true" alt="ResourceEditorRegistrar的registerCustomEditors方法"></p><p>在 <code>AbstractBeanFactory</code> 中的 <code>registerCustomEditors</code> 方法中被调用过，继续下去我们可以看到一个熟悉的方法就是 <code>AbstractBeanFactory</code> 类中的 <code>initBeanWrapper</code> 方法，这是在 bean 初始化时候使用的一个方法，<a href="https://binglau7.github.io/2017/11/20/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E5%88%9B%E5%BB%BA-bean/#instantiateBean-不带参数的构造函数实例化过程" target="_blank" rel="noopener">详见</a>。</p><p>此时，逻辑已经明了了，在 bean 的初始化之后会调用 <code>ResourceEditorRegistrar</code> 的 <code>registerCustomEditors</code> 方法进行批量的通用属性编辑器注册。注册后，在属性填充的环节便可以直接让 Spring 使用这些编辑器进行熟悉的解析了。</p><p>既然提到了<code>BeanWrapper</code>，这里也有必要强调下，Spring 中用于封装 bean 的是 <code>BeanWrapper</code> 类型，而它又间接继承了 <code>PropertyEditorRegistry</code> 类型，也就是我们之前反复看到的方法参数 <code>PropertyEditorRegistry registry</code>，其实大部分情况下都是 <code>BeanWrapper</code>，对于 <code>BeanWrapper</code> 在 Spring 中的默认实现是<code>BeanWrapperImpl</code>，而 <code>BeanWrapperImpl</code> 除了实现 <code>BeanWrapper</code> 接口外还继承了<code>PropertyEditorRegistrySupport</code>，在 <code>PropertyEditorRegistrySupport</code> 中有这样一个方法 <code>createDefaultEditors</code> 定义了一系列常用的属性编辑器方便我们进行配置。</p><h3 id="添加-ApplicationContextAwareProcessor-处理器"><a href="#添加-ApplicationContextAwareProcessor-处理器" class="headerlink" title="添加 ApplicationContextAwareProcessor 处理器"></a>添加 <code>ApplicationContextAwareProcessor</code> 处理器</h3><p><code>beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</code> （不加这行自己都忘了自己说到了哪儿）</p><p>我们继续通过 <code>AbstractApplicationContext</code> 的 <code>prepareBeanFactory</code> 方法的主线来进行函数跟踪。对于 <code>beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this))</code> 其实主要目的就是注册个 <code>BeanPostProcessor</code>，而真正的逻辑还是在 <code>ApplicationContextAwareProcessor</code> 中。</p><p><code>ApplicationContextAwareProcessor</code> 实现 <code>BeanPostProcessor</code> 接口，我们回顾下之前讲过的内容，在 bean 实例化的时候，也就是 Spring 激活 bean 的 <code>init-method</code> 的前后，会调用 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法和 <code>postProcessAfterInitialization</code> 方法。同样，对于<code>ApplicationContextAwareProcessor</code> 我们也关心这两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>… 过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">(bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware || bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware || bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现这些 <code>Aware</code> 接口的 bean 在被初始化之后，可以取得一些对应的资源。</p><h3 id="设置忽略依赖"><a href="#设置忽略依赖" class="headerlink" title="设置忽略依赖"></a>设置忽略依赖</h3><p><code>invokeAwareInterfaces</code> 方法中间接调用的 <code>Aware</code> 类已经不是普通的 bean 了，如 <code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code> 等，那么当然需要在 Spring 做 bean 的依赖注入的时候忽略它们。而 <code>ignoreDependencyInterface</code> 的作用正是在此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br></pre></td></tr></table></figure><h3 id="注册依赖"><a href="#注册依赖" class="headerlink" title="注册依赖"></a>注册依赖</h3><p>Spring中有了忽略依赖的功能，当然也必不可少地会有注册依赖的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>当注册了依赖解析后，例如当注册了对 <code>BeanFactory.class</code> 的解析依赖后，当 bean 的属性注入的时候，一旦检测到属性为 <code>BeanFactory</code> 类型便会将 <code>beanFactory</code> 的实例注入进去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前分析是建立在&lt;code&gt;BeanFactory&lt;/code&gt;  接口以及它的实现类 &lt;code&gt;XmlBeanFactory&lt;/code&gt; 来进行分析的， &lt;code&gt;ApplicationContext&lt;/code&gt; 包含了 &lt;code&gt;BeanFactory&lt;/code&gt; 的所有功能，多数情况我们都会使用 &lt;code&gt;ApplicationConetxt&lt;/code&gt;。其加载方式如下:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext ctx = new ClassPathXmlApplicationContext(&amp;quot;beanFactory.xml&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以我们就以 &lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt; 来作为分析的切入点：&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch基础</title>
    <link href="http://yoursite.com/2017/11/23/ElasticSearch%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/11/23/ElasticSearch基础/</id>
    <published>2017-11-23T06:09:33.000Z</published>
    <updated>2017-12-07T14:16:00.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="增删查改范例"><a href="#增删查改范例" class="headerlink" title="增删查改范例"></a>增删查改范例</h2><blockquote><p> Restful vs Java API</p></blockquote><h3 id="Java-API-说明"><a href="#Java-API-说明" class="headerlink" title="Java API 说明"></a>Java API 说明</h3><p>需要添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要获取 client 实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Settings settings = Settings.EMPTY;</span><br><span class="line">TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getLocalHost(), <span class="number">9300</span>));</span><br></pre></td></tr></table></figure><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h4 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h4><p><code>curl -XPOST &#39;localhost:9200/books/es/1&#39; -d &#39;{&quot;title&quot;: &quot;Elasticsearch Server&quot;, &quot;published&quot;: 2013}&#39;</code></p><p>返回：</p><p><code>{&quot;_index&quot;:&quot;books&quot;,&quot;_type&quot;:&quot;es&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;_version&quot;:1,&quot;result&quot;:&quot;created&quot;,&quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0},&quot;created&quot;:true}</code></p><a id="more"></a><h4 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// add，可以直接使用 json 添加，也可以像下面一样使用</span></span><br><span class="line">        XContentBuilder builder = XContentFactory.jsonBuilder().startObject()</span><br><span class="line">                .field(<span class="string">"title"</span>, <span class="string">"Mastering Elasticsearch"</span>).field(<span class="string">"published"</span>, <span class="string">"2013"</span>).endObject();</span><br><span class="line">        String json = builder.string();</span><br><span class="line">        System.out.println(json);</span><br><span class="line">        <span class="comment">// IndexResponse indexResponse = client.prepareIndex("books", "es", "2")</span></span><br><span class="line">        <span class="comment">// .setSource(json, XContentType.JSON).get();</span></span><br><span class="line">        IndexResponse indexResponse = client.prepareIndex(<span class="string">"books"</span>, <span class="string">"es"</span>, <span class="string">"2"</span>)</span><br><span class="line">                .setSource(builder).get();</span><br><span class="line">        System.out.println(indexResponse);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;"title":"Mastering Elasticsearch","published":"2013"&#125; // JSON</span></span><br><span class="line"><span class="comment">IndexResponse[index=books,type=es,id=2,version=1,result=created,shards=&#123;"total":2,"successful":1,"failed":0&#125;] // indexResponse</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><h4 id="Restful-1"><a href="#Restful-1" class="headerlink" title="Restful"></a>Restful</h4><p><code>curl -XGET &#39;localhost:9200/books/_search?pretty&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span> : <span class="number">41</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">"hits"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"books"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"es"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"title"</span> : <span class="string">"Mastering Elasticsearch"</span>,</span><br><span class="line">          <span class="attr">"published"</span> : <span class="number">2013</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"books"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"es"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"title"</span> : <span class="string">"Elasticsearch Server"</span>,</span><br><span class="line">          <span class="attr">"published"</span> : <span class="number">2013</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"books"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"solr"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"title"</span> : <span class="string">"Apache Solr 4 Cookbook"</span>,</span><br><span class="line">          <span class="attr">"published"</span> : <span class="number">2012</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>curl -XGET &#39;localhost:9200/books/_search?pretty&amp;q=title:elasticsearch&#39;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span> : <span class="number">12</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"max_score"</span> : <span class="number">0.7373906</span>,</span><br><span class="line">    <span class="attr">"hits"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"books"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"es"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">0.7373906</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"title"</span> : <span class="string">"Elasticsearch Server"</span>,</span><br><span class="line">          <span class="attr">"published"</span> : <span class="number">2013</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span> : <span class="string">"books"</span>,</span><br><span class="line">        <span class="attr">"_type"</span> : <span class="string">"es"</span>,</span><br><span class="line">        <span class="attr">"_id"</span> : <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span> : <span class="number">0.25811607</span>,</span><br><span class="line">        <span class="attr">"_source"</span> : &#123;</span><br><span class="line">          <span class="attr">"title"</span> : <span class="string">"Mastering Elasticsearch"</span>,</span><br><span class="line">          <span class="attr">"published"</span> : <span class="number">2013</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-API-1"><a href="#Java-API-1" class="headerlink" title="Java API"></a>Java API</h4><h5 id="通过-id-查询"><a href="#通过-id-查询" class="headerlink" title="通过 id 查询"></a>通过 id 查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// get by id</span></span><br><span class="line">        GetResponse response = client.prepareGet(<span class="string">"books"</span>, <span class="string">"es"</span>, <span class="string">"2"</span>).get();</span><br><span class="line">        System.out.println(response);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;"_index":"books","_type":"es","_id":"2","_version":1,"found":true,"_source":&#123;"title":"Mastering Elasticsearch","published":"2013"&#125;&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h5 id="通过-query-查询"><a href="#通过-query-查询" class="headerlink" title="通过 query 查询"></a>通过 query 查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        SearchResponse response = client.prepareSearch(<span class="string">"books"</span>)</span><br><span class="line">                .setQuery(</span><br><span class="line">                        QueryBuilders.termsQuery(<span class="string">"title"</span>,<span class="string">"elasticsearch"</span>)</span><br><span class="line">                )</span><br><span class="line">                .get();</span><br><span class="line">        System.out.println(response);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;"took":11,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"skipped":0,"failed":0&#125;,"hits":&#123;"total":2,"max_score":0.7373906,"hits":[&#123;"_index":"books","_type":"es","_id":"1","_score":0.7373906,"_source":&#123;"title": "Elasticsearch Server", "published": 2013&#125;&#125;,&#123;"_index":"books","_type":"es","_id":"2","_score":0.25811607,"_source":&#123;"title":"Mastering Elasticsearch","published":"2013"&#125;&#125;]&#125;&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h4 id="Restful-2"><a href="#Restful-2" class="headerlink" title="Restful"></a>Restful</h4><p>更新索引中的文档是一项复杂的任务。在内部，ElasticSearch 必须首先后去文档，从 <code>_source</code> 属性获得数据，删除旧的文件，更改 <code>_source</code> 属性，然后把它作为新的文档来索引。它如此复杂，因为信息一旦在 Lucene 的倒排索引中存储，就不能再被更改。</p><p><code>curl -XPOST &#39;localhost:9200/books/es/2/_update&#39; -d &#39;{&quot;script&quot;: &quot;ctx._source.published = \&quot;2017\&quot;&quot; }&#39;</code></p><p><code>{&quot;_index&quot;:&quot;books&quot;,&quot;_type&quot;:&quot;es&quot;,&quot;_id&quot;:&quot;2&quot;,&quot;_version&quot;:2,&quot;result&quot;:&quot;updated&quot;,&quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0}}</code></p><p>结果验证:</p><p><code>curl -XGET &#39;localhost:9200/books/_search?pretty&amp;q=title:mastering&#39;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"took"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"timed_out"</span> : <span class="keyword">false</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">"skipped"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"hits"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">"max_score"</span> : <span class="number">0.25811607</span>,</span><br><span class="line">    <span class="string">"hits"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"_index"</span> : <span class="string">"books"</span>,</span><br><span class="line">        <span class="string">"_type"</span> : <span class="string">"es"</span>,</span><br><span class="line">        <span class="string">"_id"</span> : <span class="string">"2"</span>,</span><br><span class="line">        <span class="string">"_score"</span> : <span class="number">0.25811607</span>,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"title"</span> : <span class="string">"Mastering Elasticsearch"</span>,</span><br><span class="line">          <span class="string">"published"</span> : <span class="string">"2017"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-API-2"><a href="#Java-API-2" class="headerlink" title="Java API"></a>Java API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// use prepareUpdate</span></span><br><span class="line">        UpdateResponse response = client.prepareUpdate(<span class="string">"books"</span>, <span class="string">"es"</span>, <span class="string">"2"</span>).setScript(</span><br><span class="line">                <span class="keyword">new</span> Script(<span class="string">"ctx._source.published = \"2017\""</span>)</span><br><span class="line">        ).get();</span><br><span class="line">        UpdateResponse response = client.prepareUpdate(<span class="string">"books"</span>, <span class="string">"es"</span>, <span class="string">"2"</span>)</span><br><span class="line">                .setDoc(</span><br><span class="line">                        XContentFactory.jsonBuilder().startObject().field(<span class="string">"published"</span>, <span class="string">"2017"</span>).endObject()</span><br><span class="line">                )</span><br><span class="line">                .get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use UpdateRequest</span></span><br><span class="line">        UpdateResponse response = client.update(</span><br><span class="line">                <span class="keyword">new</span> UpdateRequest(<span class="string">"books"</span>, <span class="string">"es"</span>, <span class="string">"2"</span>)</span><br><span class="line">                        .doc(</span><br><span class="line">                                XContentFactory.jsonBuilder().startObject().field(<span class="string">"published"</span>, <span class="string">"2017"</span>).endObject()</span><br><span class="line">                        )</span><br><span class="line">        ).get();</span><br><span class="line">        System.out.println(response);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">UpdateResponse[index=books,type=es,id=2,version=2,result=updated,shards=ShardInfo&#123;total=2, successful=1, failures=[]&#125;]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h4 id="Restful-3"><a href="#Restful-3" class="headerlink" title="Restful"></a>Restful</h4><p><code>curl -XDELETE &#39;localhost:9200/books/es/2&#39;</code></p><p><code>{&quot;found&quot;:true,&quot;_index&quot;:&quot;books&quot;,&quot;_type&quot;:&quot;es&quot;,&quot;_id&quot;:&quot;2&quot;,&quot;_version&quot;:3,&quot;result&quot;:&quot;deleted&quot;,&quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0}}</code></p><p>结果验证:</p><p><code>curl -XGET &#39;localhost:9200/books/_search?pretty&amp;q=title:mastering&#39;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"took"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"timed_out"</span> : <span class="keyword">false</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">"skipped"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"hits"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"max_score"</span> : <span class="keyword">null</span>,</span><br><span class="line">    <span class="string">"hits"</span> : [ ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-API-3"><a href="#Java-API-3" class="headerlink" title="Java API"></a>Java API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        DeleteResponse response = client.prepareDelete(<span class="string">"books"</span>, <span class="string">"es"</span>, <span class="string">"2"</span>).get();</span><br><span class="line">        System.out.println(response);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DeleteResponse[index=books,type=es,id=2,version=5,result=deleted,shards=ShardInfo&#123;total=2, successful=1, failures=[]&#125;]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="数据架构的主要概念"><a href="#数据架构的主要概念" class="headerlink" title="数据架构的主要概念"></a>数据架构的主要概念</h3><ul><li><p>索引</p><p>索引（index） 是 Elasticsearch 对逻辑数据的逻辑存储，所以它可以分为更小的部分。你可以<strong>把索引看成关系型数据库的表</strong>。然而，索引的结构是为快速有效的全文索引准备的，特别是<strong>它不存储原始值</strong>。Elasticsearch 可以把索引存放在一台机器或者分散在多台服务器上，<strong>每个索引有一或多个分片（shard），每个分片可以有多个副本（replica）。</strong></p></li><li><p>文档</p><p>存储在 Elasticsearch 中的<strong>主要实体</strong>叫文档（ document）。用关系型数据库来类比的话，<strong>一个文档相当于数据库表中的一行记录</strong>。</p><p>文档由多个字段组成，每个字段可能多次出现在一个文档里，这样的字段叫<strong>多值字段</strong>（multivalued）。每个字段有类型，如文本、数值、日期等。字段类型也可以是复杂类型，一个字段包含其他子文档或者数组。</p><p><strong>每个文档存储在一个索引中并有一个 Elasticsearch 自动生成的唯一标识符和文档类型</strong>。文档需要有对应文档类型的唯一标识符，这意味着在一个索引中，<strong>两个不同类型的文档可以有相同的唯一标识符</strong>。</p></li><li><p>文档类型</p><p>在 Elasticsearch 中，一个索引对象可以存储很多不同用途的对象。例如，一个博客应用程序可以保存文章和评论。文档类型让我们轻易地区分单个索引中的不同对象。每个文档可以有不同的结构，但在实际部署中，将文件按类型区分对数据操作有很大帮助。当然，需要记住一个限制，<strong>不同的文档类型不能为相同的属性设置 不同的类型。例如，在同一索引中的所有文档类型中，一个叫 title 的字段必须具有相同的类型。</strong></p></li><li><p>映射</p><p><strong>文档中的每个字段都必须根据不同类型做相应的分析。Elasticsearch 在映射中存储有关字段的信息</strong>。每一个 文档类型都有自己的映射，即使我们没有明确定义。</p></li></ul><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ul><li><p>节点和集群</p><p>Elasticsearch 可以运行在许多互相合作的服务器上。这些服务器称为集群（cluster），形成集群的每个服务器称为节点（node）。</p></li><li><p>分片</p><p>当有大量的文档时，由于内存的限制、硬盘能力、处理能力不足、<strong>无法足够快地响应客户端请求等</strong>，<strong>一个节点可能不够。在这种情况下，数据可以分为较小的称为分片（shard）的部分</strong>（其中<strong>每个分片都是一个独立的ApacheLucene 索引</strong>）。每个分片可以放在不同的服务器上，因此，数据可以在集群的节点中传播。<strong>当你查询的索引分布在多个分片上时，Elasticsearch 会把查询发送给每个相关的分片，并将结果合并在一起，而应用程序并不知道分片的存在。此外，多个分片可以加快索引。</strong></p></li><li><p>副本</p><p>为了<strong>提高查询吞吐量或实现高可用性</strong>，可以使用分片副本。<strong>副本（replica）只是一个分片的精确复制</strong>，每个分片可以有零个或多个副本。换句话说，<strong>Elasticsearch 可以有许多相同的分片，其中之一被自动选择去更改索引操作。这种特殊的分片称为主分片（primaryshard），其余称为副本分片（replicashard）</strong>。在主分片丢失时，例如该分片数据所在服务器不可用，集群将副本提升为新的主分片。</p><p>​</p></li></ul><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><h4 id="词条查询（term）"><a href="#词条查询（term）" class="headerlink" title="词条查询（term）"></a>词条查询（<code>term</code>）</h4><p>词条查询是 Elasticsearch 中的一个简单查询。<strong>它仅匹配在给定字段中含有该词条的文档，而且是确切的、未经分析的词条</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                                    </span><br><span class="line">     &#123;</span><br><span class="line">       "query" : &#123;</span><br><span class="line">          "term" : &#123;</span><br><span class="line">             "title": "elasticsearch" </span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;'</span><br><span class="line">     </span><br><span class="line"><span class="meta">#</span> 另外的查询 json</span><br><span class="line">          &#123;</span><br><span class="line">            "query" : &#123;</span><br><span class="line">               "term" : &#123;</span><br><span class="line">                  "title": &#123;</span><br><span class="line">                       "value": "elasticsearch",</span><br><span class="line">                       "boost": 10.0</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;'</span><br></pre></td></tr></table></figure><p>由于索引内容全改为小写，所以搜索的也改为小写</p><h4 id="多词条查询（terms-tags）"><a href="#多词条查询（terms-tags）" class="headerlink" title="多词条查询（terms-tags）"></a>多词条查询（<code>terms-tags</code>）</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">     <span class="attr">"terms"</span> : &#123;</span><br><span class="line">        <span class="attr">"published"</span> : [ <span class="string">"2013"</span>, <span class="string">"2012"</span> ]</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配所有文件（match-all）"><a href="#匹配所有文件（match-all）" class="headerlink" title="匹配所有文件（match_all）"></a>匹配所有文件（<code>match_all</code>）</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">     <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用词（common）"><a href="#常用词（common）" class="headerlink" title="常用词（common）"></a>常用词（<code>common</code>）</h4><p>常用词查询是在没有使用停用词（stopword，<a href="http://en.wikipedia.org/wiki/Stop_words）的情况下，Elasticsearch为了提高常用词的查询相关性和精确性而提供的一个现代解决方案。例如，“book" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Stop_words）的情况下，Elasticsearch为了提高常用词的查询相关性和精确性而提供的一个现代解决方案。例如，“book</a> and coffee”可以翻译成3个词查询，每一个都有性能上的成本（词越多，查询性能越低）。<strong>但『and』这个词非常常见，对文档得分的影响非常低。解决办法是常用词查询，将查询分为两组。第一组包含重要的词，出现的频率较低。第二组包含较高频率的、不那么重要的词。</strong>先执行第一个查询，Elasticsearch从第一组的所有词中计算分数。这样，通常都很重要的低频词总是被列入考虑范围。然后，Elasticsearch对第二组中的词执行二次查询，但只为与第一个查询中匹配的文档计算得分。这样只计算了相关文档的得分，实现了更高的性能。</p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-common-terms-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-common-terms-query.html</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"common"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"this is bonsai cool"</span>,</span><br><span class="line">                <span class="attr">"cutoff_frequency"</span>: <span class="number">0.001</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询可以使用下列的参数：</p><ul><li>query：定义实际查询内容</li><li>cutoff_frequency：这个参数定义一个百分比（0.001表示0.1%）或一个绝对值（当此属性值&gt;=1时）。<strong>这个值用来构建高、低频词组。此参数设置为0.001意味着频率&lt;=0.1%的词将出现在低频词组中。</strong></li><li>low_freq_operator：这个参数可以设为 or 或 and，默认是or。它用来<strong>指定为低频词组构建查询时用到的布尔运算符</strong>。如果希望所有的词都在文档中出现才认为是匹配，应该把它设置为and。</li><li>high_freq_operator：这个参数可以设为 or 或a nd，默认是or。它用来<strong>指定为高频词组构建查询时用到的布尔运算符</strong>。如果希望所有的词都在文档中出现才认为是匹配，那么应该把它设置为and。</li><li>minimum_should_match：不使用 low_freq_operator 和 high_freq_operator 参数的话，可以使用使用minimum_should_match 参数。和其他查询一样，它<strong>允许指定匹配的文档中应该出现的查询词的最小个数</strong>。</li><li>boost：这个参数定义了赋给文档得分的<strong>加权值</strong>。</li><li>analyzer：这个参数<strong>定义了分析查询文本时用到的分析器名称</strong>。默认值为 default analyzer。</li><li>disable_coord：此参数的值默认为 false，它<strong>允许启用或禁用分数因子的计算，该计算基于文档中包含的所有查询词的分数</strong>。把它设置为true，得分不那么精确，但查询将稍快。</li></ul><h4 id="match-查询（match）"><a href="#match-查询（match）" class="headerlink" title="match 查询（match）"></a>match 查询（<code>match</code>）</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html" target="_blank" rel="noopener">官方文档</a></p><p>match 查询把 query 参数中的值拿出来，加以分析，然后构建相应的查询<strong>。使用 match 查询时，Elasticsearch 将对一个字段选择合适的分析器，所以可以确定，传给 match 查询的词条将被建立索引时相同的分析器处理</strong>。请记住，<strong>match 查询（以及将在稍后解释的 multi_match 查询）不支持 Lucene 查询语法</strong>。但是，它是完全符合搜索需求的一个查询处理器。</p><p>最简单的查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"message"</span> : <span class="string">"this is a test"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看看它几种类型</p><h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"message"</span> : &#123;</span><br><span class="line">                <span class="attr">"query"</span>: <span class="string">"this is a test"</span>,</span><br><span class="line">              <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布尔匹配查询分析提供的文本，然后做出布尔查询。有几个参数允许控制布尔查询匹配行为：</p><ul><li>operator：此参数可以接受 or 和 and，<strong>控制用来连接创建的布尔条件的布尔运算符</strong>。默认值是or。如果希望查询中的所有条件都匹配，可以使用and运算符。</li><li>analyzer：这个参数定义了分析查询文本时用到的分析器的名字。默认值为 default analyzer。</li><li>fuzziness：<strong>可以通过提供此参数的值来构建模糊查询</strong>（fuzzy query）。它为字符串类型提供从0.0到1.0的值。构造模糊查询时，该参数将用来设置相似性。</li><li>prefix_length：<strong>此参数可以控制模糊查询的行为</strong>。</li><li>max_expansions：<strong>此参数可以控制模糊查询的行为</strong>。</li><li>zero_terms_query：该参数允许<strong>指定当所有的词条都被分析器移除时（例如，因为停止词），查询的行为。它可以被设置为none或all，默认值是none。</strong>在分析器移除所有查询词条时，该参数设置为none，将没有文档返回；设置为all，则将返回所有文档。</li><li>cutoff_frequency：<strong>该参数允许将查询分解成两组：一组低频词和一组高频词</strong>。</li></ul><h5 id="match-phrase"><a href="#match-phrase" class="headerlink" title="match_phrase"></a>match_phrase</h5><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="attr">"message"</span> : &#123;</span><br><span class="line">                <span class="attr">"query"</span> : <span class="string">"this is a test"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span> : <span class="string">"my_analyzer"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match_phrase 查询类似于布尔查询，不同的是，<strong>它从分析后的文本中构建短语查询，而不是布尔子句</strong>。该查询可以使用下面几种参数：</p><ul><li>slop：这是一个整数值，<strong>该值定义了文本查询中的词条和词条之间可以有多少个未知词</strong>条，以被视为跟一个短语匹配。此参数的默认值是0，这意味着，不允许有额外的词条1。</li><li>analyzer：这个参数定义定义了分析查询文本时用到的分析器的名字。默认值为 default analyzer。</li></ul><h5 id="match-phrase-prefix"><a href="#match-phrase-prefix" class="headerlink" title="match_phrase_prefix"></a>match_phrase_prefix</h5><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match_phrase_prefix"</span> : &#123;</span><br><span class="line">            <span class="string">"message"</span> : &#123;</span><br><span class="line">                <span class="string">"query"</span> : <span class="string">"quick brown f"</span>,</span><br><span class="line">                <span class="string">"max_expansions"</span> : <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match_query 查询的最后一种类型是 match_phrase_prefix 查询。此查询跟 match_phrase 查询几乎一样，但除此之外，<strong>它允许查询文本的最后一个词条只做前缀匹配</strong>。此外，除了 match_phrase 查询公开的参数，<strong>还公开了一个额外参数max_expansions。这个参数控制有多少前缀将被重写成最后的词条。</strong></p><h4 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html" target="_blank" rel="noopener">官方文档</a></p><p>可以通过 fields 指定多字段进行 match 查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span> : &#123;</span><br><span class="line">      <span class="attr">"query"</span>:    <span class="string">"this is a test"</span>, </span><br><span class="line">      <span class="attr">"fields"</span>: [ <span class="string">"subject"</span>, <span class="string">"message"</span> ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 match 提供的参数，它还可以通过以下参数来控制行为:</p><ul><li>use_dis_max：该参数定义一个布尔值，<strong>设置为 true 时，使用析取最大分查询，设置为false时，使用布尔查询</strong>。默认值为 true。</li><li>tie_breaker：只有在 use_dis_max 参数设为 true 时才会使用这个参数。<strong>它指定低分数项和最高分数项之间的平衡</strong>。</li></ul><h4 id="query-string-查询"><a href="#query-string-查询" class="headerlink" title="query_string 查询"></a>query_string 查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html" target="_blank" rel="noopener">官方文档</a></p><p>相比其他查询， query_string 支持全部 Apache Lucene 查询语法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"query_string"</span> : &#123;</span><br><span class="line">            <span class="attr">"query"</span> : <span class="string">"city.\\*:(this AND that OR thus)"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="针对多字段"><a href="#针对多字段" class="headerlink" title="针对多字段"></a>针对多字段</h5><p>将 <code>use_ids_max</code> 设置为 true</p><h4 id="simple-query-string-查询"><a href="#simple-query-string-查询" class="headerlink" title="simple_query_string 查询"></a>simple_query_string 查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html" target="_blank" rel="noopener">官方文档</a></p><p>使用 Lucene 最新查询解析器之一: <code>SimpleQueryParser</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"simple_query_string"</span> : &#123;</span><br><span class="line">        <span class="attr">"query"</span>: <span class="string">"\"fried eggs\" +(eggplant | potato) -frittata"</span>,</span><br><span class="line">        <span class="attr">"fields"</span>: [<span class="string">"title^5"</span>, <span class="string">"body"</span>],</span><br><span class="line">        <span class="attr">"default_operator"</span>: <span class="string">"and"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标识符查询"><a href="#标识符查询" class="headerlink" title="标识符查询"></a>标识符查询</h4><p>仅用于提供的标识符来过滤返回的文档，针对内部 _uid 字段运行</p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-ids-query.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"ids"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"my_type"</span>,</span><br><span class="line">            <span class="attr">"values"</span> : [<span class="string">"1"</span>, <span class="string">"4"</span>, <span class="string">"100"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前缀查询"><a href="#前缀查询" class="headerlink" title="前缀查询"></a>前缀查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-prefix-query.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"prefix"</span> : &#123; <span class="attr">"user"</span> : <span class="string">"ki"</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fuzzy-查询"><a href="#fuzzy-查询" class="headerlink" title="fuzzy 查询"></a>fuzzy 查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html" target="_blank" rel="noopener">官方文档</a></p><p>基于编辑距离算法来匹配文档。编辑距离的计算基于我们提供的查询词条和被搜索文档。此查询很占用 CPU 资源，但当<strong>需要模糊匹配时它很有用</strong>，例如，当用户拼写错误时。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"fuzzy"</span> : &#123;</span><br><span class="line">            <span class="attr">"user"</span> : &#123;</span><br><span class="line">                <span class="attr">"value"</span> :         <span class="string">"ki"</span>,</span><br><span class="line">                    <span class="attr">"boost"</span> :         <span class="number">1.0</span>,</span><br><span class="line">                    <span class="attr">"fuzziness"</span> :     <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"prefix_length"</span> : <span class="number">0</span>,</span><br><span class="line">                    <span class="attr">"max_expansions"</span>: <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用下面的参数来控制 fuzzy 查询的行为。</p><ul><li>value：此参数指定了实际的查询。</li><li>boost：此参数指定了查询的加权值，默认为1.0。</li><li>min_similarity：<strong>此参数指定了一个词条被算作匹配所必须拥有的最小相似度</strong>。对字符串字段来说，这个值应该在0到1之间，包含0和1。对于数值型字段，这个值可以大于1，比如查询值是20，min_similarity设为3，则可以得到17~23的值。对于日期字段，可以把min_similarity参数值设为1d、2d、1m等，分别表示1天、2天、1个月。</li><li>prefix_length：此参数<strong>指定差分词条的公共前缀长度</strong>，默认值为0。</li><li>max_expansions：此参数<strong>指定查询可被扩展到的最大词条数</strong>，默认值是无限制。</li></ul><h4 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-wildcard-query.html" target="_blank" rel="noopener">官方文档</a></p><p>通配符查询允许我们在查询值中使用 * 和 ? 等通配符。此外，通配符查询跟词条查询在内容方面非常类似。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"wildcard"</span> : &#123; <span class="attr">"user"</span> : &#123; <span class="attr">"value"</span> : <span class="string">"ki*y"</span>, <span class="attr">"boost"</span> : <span class="number">2.0</span> &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="more-like-this-查询"><a href="#more-like-this-查询" class="headerlink" title="more_like_this 查询"></a>more_like_this 查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-mlt-query.html" target="_blank" rel="noopener">官方文档</a></p><p>more_like_this 查询让我们能够得到与提供的文本类似的文档。Elasticsearch 支持几个参数来定义 more_like_this 查询如何工作，如下所示。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"more_like_this"</span> : &#123;</span><br><span class="line">            <span class="attr">"fields"</span> : [<span class="string">"title"</span>, <span class="string">"description"</span>],</span><br><span class="line">            <span class="attr">"like"</span> : <span class="string">"Once upon a time"</span>,</span><br><span class="line">            <span class="attr">"min_term_freq"</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"max_query_terms"</span> : <span class="number">12</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fields：此参数定义<strong>应该执行查询的字段数组</strong>，默认值是 _all 字段。</li><li>like_text：这是一个必需的参数，包含<strong>用来跟文档比较的文本</strong>。</li><li>percent_terms_to_match：此参数<strong>定义了文档需要有多少百分比的词条与查询匹配才能认为是类似</strong>的，默认值为0.3，意思是30%。</li><li>min_term_freq：此参数<strong>定义了文档中词条的最低词频</strong>，低于此频率的词条将被忽略，默认值为2。</li><li>max_query_terms：此参数<strong>指定生成的查询中能包括的最大查询词条数</strong>，默认值为25。值越大，精度越大，但性能也越低。</li><li>stop_words：此参数<strong>定义了一个单词的数组，当比较文档和查询时，这些单词将被忽略</strong>，默认值为空数组。</li><li>min_doc_freq：此参数<strong>定义了包含某词条的文档的最小数目</strong>，低于此数目时，该词条将被忽略，默认值为5，意味着一个词条至少应该出现在5个文档中，才不会被忽略。</li><li>max_doc_freq：此参数<strong>定义了包含某词条的文档的最大数目</strong>，高于此数目时，该词条将被忽略，默认值为无限制。</li><li>min_word_len：此参数<strong>定义了单词的最小长度</strong>，低于此长度的单词将被忽略，默认值为0。</li><li>max_word_len：此参数<strong>定义了单词的最大长度</strong>，高于此长度的单词将被忽略，默认值为无限制。</li><li>boost_terms：此参数定义了用于每个<strong>词条的加权值</strong>，默认值为1。</li><li>boost：此参数定义了用于<strong>查询的加权值</strong>，默认值为1。</li><li>analyzer：此参数指定了针对我们提供的<strong>文本的分析器名称</strong>。</li></ul><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-range-query.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"range"</span> : &#123;</span><br><span class="line">            <span class="attr">"age"</span> : &#123;</span><br><span class="line">                <span class="attr">"gte"</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="attr">"lte"</span> : <span class="number">20</span>,</span><br><span class="line">                <span class="attr">"boost"</span> : <span class="number">2.0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>gte：范围查询将匹配字段值大于或等于此参数值的文档。</li><li>gt：范围查询将匹配字段值大于此参数值的文档。</li><li>lte：范围查询将匹配字段值小于或等于此参数值的文档。</li><li>lt：范围查询将匹配字段值小于此参数值的文档。</li></ul><h4 id="正则表达式查询"><a href="#正则表达式查询" class="headerlink" title="正则表达式查询"></a>正则表达式查询</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl-regexp-query.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"regexp"</span>:&#123;</span><br><span class="line">            <span class="attr">"name.first"</span>: <span class="string">"s.*y"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>之前查询返回的结果中有一个 <code>&quot;_version&quot;: 1</code></p><p>仔细观察，你会发现在更新相同标识符的文档后，这个版本是递增的。默认情况下，Elasticsearch在添加、更改或删除文档时都会递增版本号。除了告诉我们对文档所做更改的次数，还能够实现<strong><a href="https://zh.wikipedia.org/wiki/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">乐观锁</a></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;增删查改范例&quot;&gt;&lt;a href=&quot;#增删查改范例&quot; class=&quot;headerlink&quot; title=&quot;增删查改范例&quot;&gt;&lt;/a&gt;增删查改范例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; Restful vs Java API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Java-API-说明&quot;&gt;&lt;a href=&quot;#Java-API-说明&quot; class=&quot;headerlink&quot; title=&quot;Java API 说明&quot;&gt;&lt;/a&gt;Java API 说明&lt;/h3&gt;&lt;p&gt;需要添加依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.elasticsearch.client&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;transport&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.6.4&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.logging.log4j&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j-core&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.9.1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.logging.log4j&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j-api&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.9.1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要获取 client 实例:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Settings settings = Settings.EMPTY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TransportClient client = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PreBuiltTransportClient(settings)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addTransportAddress(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InetSocketTransportAddress(InetAddress.getLocalHost(), &lt;span class=&quot;number&quot;&gt;9300&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;增&quot;&gt;&lt;a href=&quot;#增&quot; class=&quot;headerlink&quot; title=&quot;增&quot;&gt;&lt;/a&gt;增&lt;/h3&gt;&lt;h4 id=&quot;Restful&quot;&gt;&lt;a href=&quot;#Restful&quot; class=&quot;headerlink&quot; title=&quot;Restful&quot;&gt;&lt;/a&gt;Restful&lt;/h4&gt;&lt;p&gt;&lt;code&gt;curl -XPOST &amp;#39;localhost:9200/books/es/1&amp;#39; -d &amp;#39;{&amp;quot;title&amp;quot;: &amp;quot;Elasticsearch Server&amp;quot;, &amp;quot;published&amp;quot;: 2013}&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{&amp;quot;_index&amp;quot;:&amp;quot;books&amp;quot;,&amp;quot;_type&amp;quot;:&amp;quot;es&amp;quot;,&amp;quot;_id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;_version&amp;quot;:1,&amp;quot;result&amp;quot;:&amp;quot;created&amp;quot;,&amp;quot;_shards&amp;quot;:{&amp;quot;total&amp;quot;:2,&amp;quot;successful&amp;quot;:1,&amp;quot;failed&amp;quot;:0},&amp;quot;created&amp;quot;:true}&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ElasticSearch" scheme="http://yoursite.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码解析—创建 bean</title>
    <link href="http://yoursite.com/2017/11/20/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E5%88%9B%E5%BB%BA-bean/"/>
    <id>http://yoursite.com/2017/11/20/Spring-源码解析—创建-bean/</id>
    <published>2017-11-20T09:00:18.000Z</published>
    <updated>2017-11-22T16:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>在经历过 <code>AbstractAutowireCapableBeanFactory#createBean</code> 中的 <code>resolveBeforeInstantiation</code> 方法后，程序有两个选择，如果创建了代理或者说重写了 <code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessBeforeInstantiation</code> 方法并在方法 <code>postProcessBeforeInstantiation</code> 中改变了 <code>bean</code>，则直接返回就可以了，否则需要进行常规 <code>bean</code> 的创建。而这常规 <code>bean</code> 的创建就是在 <code>doCreateBean</code> 中完成的。</p><p><code>AbstractAutowireCapableBeanFactory#doCreateBean</code></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123; <span class="comment">// 1</span></span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">       <span class="comment">// 根据指定 bean 使用对应的策略创建新的实例，如：工厂方法、构造函数自动注入、简单初始化</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 应用 MergedBeanDefinitionPostProcessor</span></span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="comment">// 是否需要提前曝光：单例 &amp; 允许循环依赖 &amp; 当前 bean 正在创建中，检测循环依赖</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 为了避免后期循环依赖，可以在 bean 初始化完成前将创建实例的 ObjectFactory 加入工厂</span></span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">              <span class="comment">// 对 bean 再一次依赖引用，主要应用 SmartInstantiationAware BeanPostProcessor,</span></span><br><span class="line">              <span class="comment">// 其中我们熟知的 AOP 就是在这里将 advice 动态织入 bean 中，若没有直接返回 bean，不做任何处理</span></span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性，则会递归初始依赖 bean</span></span><br><span class="line">       <span class="comment">// 5</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 调用初始化方法，比如 init-method</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">// earlySingletonReference 只有在检测到有循环依赖的情况下才会不为空</span></span><br><span class="line">      <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果 esposedObject 没有在初始化方法中被改变，就是没有被增强</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="comment">// 检测依赖</span></span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">              <span class="comment">// 因为 bean 创建后其所依赖的 bean 一定是已经创建的，</span></span><br><span class="line">              <span class="comment">// actualDependentBeans 不为空则表示当前 bean 创建后其依赖的 bean 却没有</span></span><br><span class="line">              <span class="comment">// 全部创建完，也就是说存在循环依赖</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据 scopes 注册 bean</span></span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd); <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> exposedObject; <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果是单例则需要首先清除缓存</p></li><li><p>实例化 bean，将 <code>BeanDefinition</code> 转换为 <code>BeanWrapper</code></p><p>转换是一个复杂的过程，但是我们可以尝试概括大致的功能：</p><ul><li>如果存在工厂方法则使用工厂方法进行初始化</li><li>一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化</li><li>如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认的构造函数进行 bean 的实例化</li></ul></li><li><p>MergedBeanDefinitionPostProcessor的应用</p><p>bean合并后的处理，Autowired注解正是通过此方法实现诸如类型的预解析。</p></li><li><p>依赖处理</p><p>在Spring中会有循环依赖的情况，例如，当A中含有B的属性，而B中又含有A的属性时就会构成一个循环依赖，此时如果A和B都是单例，那么在Spring中的处理方式就是当创建B的时候，涉及自动注入A的步骤时，并不是直接去再次创建A，而是<strong>通过放入缓存中的ObjectFactory来创建实例</strong>，这样就解决了循环依赖的问题。</p></li><li><p>属性填充。将所有属性填充至bean的实例中</p></li><li><p>循环依赖检查</p><p>Sping 中解决循环依赖只对单例有效，而对于 prototype 的 bean，Spring 没有好的解决办法，唯一要做的就是抛出异常。在这个步骤里面会检测已经加载的 bean 是否已经出现了依赖循环，并判断是否需要抛出异常。</p></li><li><p>注册DisposableBean</p><p>如果配置了destroy-method，这里需要注册以便于在销毁时候调用。</p></li><li><p>完成创建并返回</p></li></ol><h2 id="创建-bean-的实例-createBeanInstance"><a href="#创建-bean-的实例-createBeanInstance" class="headerlink" title="创建 bean 的实例 (createBeanInstance)"></a>创建 bean 的实例 (createBeanInstance)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance for the specified bean, using an appropriate instantiation strategy:</span></span><br><span class="line"><span class="comment"> * factory method, constructor autowiring, or simple instantiation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">  <span class="comment">// 解析 class</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果工厂方法不为空则使用工厂方法初始化策略</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">          <span class="comment">// 一个类有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法</span></span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 如果已经解析过则使用解析好的构造函数方法不需要再次锁定</span></span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">          <span class="comment">// 构造函数自动注入</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 使用默认构造函数构造</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Need to determine the constructor...</span></span><br><span class="line">  <span class="comment">// 需要根据参数解析构造函数</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">       <span class="comment">// 构造函数自动注入</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">  <span class="comment">// 使用默认构造函数构造</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果在<code>RootBeanDefinition</code>中存在<code>factoryMethodName</code>属性，或者说在配置文件中配置了<code>factory-method</code>，那么 Spring 会尝试使用<code>instantiateUsingFactoryMethod(beanName, mbd, args)</code>方法根据<code>RootBeanDefinition</code>中的配置生成bean的实例。</li><li>解析构造函数并进行构造函数的实例化。因为一个 bean 对应的类中可能会有多个构造函数，而每个构造函数的参数不同，Spring 在根据参数及类型去判断最终会使用哪个构造函数进行实例化。但是，<strong>判断的过程是个比较消耗性能的步骤，所以采用缓存机制</strong>，如果已经解析过则不需要重复解析而是直接从<code>RootBeanDefinition</code>中的属性<code>resolvedConstructorOrFactoryMethod</code>缓存的值去取，否则需要再次解析，并将解析的结果添加至 <code>RootBeanDefinition</code> 中的属性<code>resolvedConstructorOrFactoryMethod</code>中。</li></ol><h3 id="autowireConstructor"><a href="#autowireConstructor" class="headerlink" title="autowireConstructor"></a><code>autowireConstructor</code></h3><p>对于实例的创建Spring中分成了两种情况，一种是通用的实例化，另一种是带有参数的实例化。带有参数的实例化过程相当复杂，因为存在着不确定性，所以在判断对应参数上做了大量工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * "autowire constructor" (with constructor arguments by type) behavior.</span></span><br><span class="line"><span class="comment"> * Also applied if explicit constructor argument values are specified,</span></span><br><span class="line"><span class="comment"> * matching all remaining arguments with beans from the bean factory.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This corresponds to constructor injection: In this mode, a Spring</span></span><br><span class="line"><span class="comment"> * bean factory is able to host components that expect constructor-based</span></span><br><span class="line"><span class="comment"> * dependency resolution.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctors the chosen candidate constructors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> explicitArgs argument values passed in programmatically via the getBean method,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if none (-&gt; use constructor argument values from bean definition)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt;[] ctors, Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边的代码量太大了，不太适合贴出来解析，各位最好还是去 idea 里面进行查看，书中作者也觉得这段不符合 Spring 那种『将复杂的逻辑分解，分成N个小函数的嵌套，每一层都是对下一层逻辑的总结及概要，这样使得每一层的逻辑会变得简单容易理解』的规律。我这里就说明一下整体流程，每段流程贴出对应的代码。</p><h4 id="构造函数参数的确定"><a href="#构造函数参数的确定" class="headerlink" title="构造函数参数的确定"></a>构造函数参数的确定</h4><ul><li><p>根据explicitArgs参数判断</p><p>如果传入的参数<code>explicitArgs</code>不为空，那边可以直接确定参数，因为 <code>explicitArgs</code> 参数是在调用 Bean 的时候用户指定的，在<code>BeanFactory</code>类中存在这样的方法：<br><code>Object getBean(String name, Object... args) throws BeansException;</code><br>在获取 bean 的时候，用户不但可以指定 bean 的名称还可以指定 bean 所对应类的构造函数或者工厂方法的方法参数，主要用于静态工厂方法的调用，而这里是需要给定完全匹配的参数的，所以，便可以判断，如果传入参数<code>explicitArgs</code>不为空，则可以确定构造函数参数就是它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// explicitArgs 通过 getBean 方法传入</span></span><br><span class="line"><span class="comment">// 如果 getBean 方法调用的时候指定方法参数那么直接使用</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">argsToUse = explicitArgs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缓存中获取</p><p>构造函数参数已经记录在缓存中，那么便可以直接拿来使用。而且，这里要提到的是，在缓存中缓存的可能是参数的最终类型也可能是参数的初始类型，例如：构造函数参数要求的是 int 类型，但是原始的参数值可能是String类型的“1”，那么即使在缓存中得到了参数，也需要经过类型转换器的过滤以确保参数类型与对应的构造函数参数类型完全对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果在 getBean 方法时候没有指定则尝试从配置文件中解析</span></span><br><span class="line">Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 尝试从缓存中获取</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line"><span class="comment">// Found a cached constructor...</span></span><br><span class="line">               <span class="comment">// 从缓存中取</span></span><br><span class="line">argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line"><span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 配置的构造函数参数 </span></span><br><span class="line">argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 如果缓存中存在</span></span><br><span class="line"><span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 解析参数类型，如给定方法的构造函数 A(int, int) 则通过此方法后就会把配置汇中的 ("1", "1") 转换为 (1, 1)</span></span><br><span class="line">          <span class="comment">// 缓存中的值可能是原始值也可能是最终值</span></span><br><span class="line">argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件获取</p><p>如果不能根据传入的参数 <code>explicitArgs</code> 确定构造函数的参数也无法在缓存中得到相关信息，那么只能开始新一轮的分析了。<br>分析从获取配置文件中配置的构造函数信息开始，经过之前的分析，我们知道，Spring中配置文件中的信息经过转换都会通过 <code>BeanDefinition</code> 实例承载，也就是参数<code>mbd</code>中包含，那么可以通过调用 <code>mbd.getConstructorArgumentValues()</code>来获取配置的构造函数信息。有了配置中的信息便可以获取对应的参数值信息了，获取参数值的信息包括直接指定值，如：直接指定构造函数中某个值为原始类型 String 类型，或者是一个对其他 bean 的引用，而这一处理委托给<code>resolveConstructorArguments</code>方法，并返回能解析到的参数的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Need to resolve the constructor.</span></span><br><span class="line"><span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minNrOfArgs;</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">minNrOfArgs = explicitArgs.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 提取配置文件中的配置的构造函数参数</span></span><br><span class="line">ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">      <span class="comment">// 用于承载解析后的构造函数参数的值</span></span><br><span class="line">resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">      <span class="comment">// 能解析到的参数个数</span></span><br><span class="line">minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="构造函数的确认"><a href="#构造函数的确认" class="headerlink" title="构造函数的确认"></a>构造函数的确认</h4><p>经过了第一步后已经确定了构造函数的参数，接下来的任务就是根据构造函数参数在所有构造函数中锁定对应的构造函数，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数按照public构造函数优先参数数量降序、非public构造函数参数数量降序。这样可以在遍历的情况下迅速判断排在后面的构造函数参数个数是否符合条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line"><span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Resolution of declared constructors on bean Class ["</span> + beanClass.getName() +</span><br><span class="line"><span class="string">"] from ClassLoader ["</span> + beanClass.getClassLoader() + <span class="string">"] failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序给定的构造函数，public 构造函数优先参数数量排序、非 public 构造函数参数数量降序</span></span><br><span class="line">AutowireUtils.sortConstructors(candidates);</span><br></pre></td></tr></table></figure><p>由于在配置文件中并不是唯一限制使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如<code>&lt;constructor-arg name=&quot;aa&quot;&gt;</code>，那么这种情况就需要首先确定构造函数中的参数名称。</p><p>获取参数名称可以有两种方式</p><ol><li><p>通过注解的方式直接获取，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span><br></pre></td></tr></table></figure></li><li><p>使用Spring中提供的工具类 <code>ParameterNameDiscoverer</code> 来获取。构造函数、参数名称、参数类型、参数值都确定后就可以锁定构造函数以及转换对应的参数类型了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line"><span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="根据确定的构造函数转换对应的参数类型"><a href="#根据确定的构造函数转换对应的参数类型" class="headerlink" title="根据确定的构造函数转换对应的参数类型"></a>根据确定的构造函数转换对应的参数类型</h4><p>主要是使用Spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">getUserDeclaredConstructor(candidate), autowiring);</span><br></pre></td></tr></table></figure><h4 id="构造参数不确定性的验证"><a href="#构造参数不确定性的验证" class="headerlink" title="构造参数不确定性的验证"></a>构造参数不确定性的验证</h4><p>当然，有时候即使构造函数、参数名称、参数类型、参数值都确定后也不一定会直接锁定构造函数，不同构造函数的参数为父子关系，所以Spring在最后又做了一次验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 探测是否有不确定性的构造函数存在，例如不同构造函数的参数为父子关系</span></span><br><span class="line"><span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"><span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line"><span class="comment">// 如果它代表着当前最接近的匹配则选择作为构造函数</span></span><br><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">constructorToUse = candidate;</span><br><span class="line">argsHolderToUse = argsHolder;</span><br><span class="line">argsToUse = argsHolder.arguments;</span><br><span class="line">minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line"><span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;Constructor&lt;?&gt;&gt;();</span><br><span class="line">ambiguousConstructors.add(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line">ambiguousConstructors.add(candidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据实例化策略以及得到的构造函数及构造函数参数实例化Bean"><a href="#根据实例化策略以及得到的构造函数及构造函数参数实例化Bean" class="headerlink" title="根据实例化策略以及得到的构造函数及构造函数参数实例化Bean"></a>根据实例化策略以及得到的构造函数及构造函数参数实例化Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; ctorToUse = constructorToUse;</span><br><span class="line"><span class="keyword">final</span> Object[] argumentsToUse = argsToUse;</span><br><span class="line">beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">mbd, beanName, beanFactory, ctorToUse, argumentsToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, beanFactory.getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanInstance = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面章节进行描述。</p><h3 id="instantiateBean-不带参数的构造函数实例化过程"><a href="#instantiateBean-不带参数的构造函数实例化过程" class="headerlink" title="instantiateBean 不带参数的构造函数实例化过程"></a><code>instantiateBean</code> 不带参数的构造函数实例化过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the given bean using its default constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance;</span><br><span class="line"><span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化策略"><a href="#实例化策略" class="headerlink" title="实例化策略"></a>实例化策略</h3><p>其实，经过前面的分析，我们已经得到了足以实例化的所有相关信息，完全可以使用最简单的反射方法直接反射来构造实例对象，但是Spring却并没有这么做。</p><p><code>SimpleInstantiationStrategy#instantiate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line">   <span class="comment">// 如果有需要覆盖或者动态替换的方法则当然需要使用 cglib 进行动态代理，因为可以在</span></span><br><span class="line">   <span class="comment">// 创建代理的同时将方法将动态方法织入类中，但是如果没有需要动态改变的方法，为了</span></span><br><span class="line">   <span class="comment">// 方便直接反射就可以了</span></span><br><span class="line"><span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">constructorToUse =clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CglibSubclassingInstantiationStrategy#instantiate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An inner class created for historical reasons to avoid external CGLIB dependency</span></span><br><span class="line"><span class="comment"> * in Spring versions earlier than 3.2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibSubclassCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] CALLBACK_TYPES = <span class="keyword">new</span> Class&lt;?&gt;[]</span><br><span class="line">&#123;NoOp.class, LookupOverrideMethodInterceptor.class, ReplaceOverrideMethodInterceptor.class&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RootBeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanFactory owner;</span><br><span class="line"></span><br><span class="line">CglibSubclassCreator(RootBeanDefinition beanDefinition, BeanFactory owner) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinition = beanDefinition;</span><br><span class="line"><span class="keyword">this</span>.owner = owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance of a dynamically generated subclass implementing the</span></span><br><span class="line"><span class="comment"> * required lookups.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctor constructor to use. If this is &#123;<span class="doctag">@code</span> null&#125;, use the</span></span><br><span class="line"><span class="comment"> * no-arg constructor (no parameterization, or Setter Injection)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use for the constructor.</span></span><br><span class="line"><span class="comment"> * Ignored if the &#123;<span class="doctag">@code</span> ctor&#125; parameter is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> new instance of the dynamically generated subclass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="keyword">this</span>.beanDefinition);</span><br><span class="line">Object instance;</span><br><span class="line"><span class="keyword">if</span> (ctor == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = BeanUtils.instantiateClass(subclass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());</span><br><span class="line">instance = enhancedSubclassConstructor.newInstance(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(<span class="keyword">this</span>.beanDefinition.getBeanClass(),</span><br><span class="line"><span class="string">"Failed to invoke constructor for CGLIB enhanced subclass ["</span> + subclass.getName() + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SPR-10785: set callbacks directly on the instance instead of in the</span></span><br><span class="line"><span class="comment">// enhanced class (via the Enhancer) in order to avoid memory leaks.</span></span><br><span class="line">Factory factory = (Factory) instance;</span><br><span class="line">factory.setCallbacks(<span class="keyword">new</span> Callback[] &#123;NoOp.INSTANCE,</span><br><span class="line"><span class="keyword">new</span> LookupOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner),</span><br><span class="line"><span class="keyword">new</span> ReplaceOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner)&#125;);</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an enhanced subclass of the bean class for the provided bean</span></span><br><span class="line"><span class="comment"> * definition, using CGLIB.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createEnhancedSubclass(RootBeanDefinition beanDefinition) &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(beanDefinition.getBeanClass());</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.owner <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">ClassLoader cl = ((ConfigurableBeanFactory) <span class="keyword">this</span>.owner).getBeanClassLoader();</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareGeneratorStrategy(cl));</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> MethodOverrideCallbackFilter(beanDefinition));</span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_TYPES);</span><br><span class="line"><span class="keyword">return</span> enhancer.createClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记录创建-bean-的-ObjectFactory"><a href="#记录创建-bean-的-ObjectFactory" class="headerlink" title="记录创建 bean 的 ObjectFactory"></a>记录创建 bean 的 ObjectFactory</h2><p>在 <code>doCreate</code> 函数中有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 是否需要提前曝光：单例 &amp; 允许循环依赖 &amp; 当前 bean 正在创建中，检测循环依赖</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 为了避免后期循环依赖，可以在 bean 初始化完成前将创建实例的 ObjectFactory 加入工厂</span></span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">          <span class="comment">// 对 bean 再一次依赖引用，主要应用 SmartInstantiationAware BeanPostProcessor,</span></span><br><span class="line">          <span class="comment">// 其中我们熟知的 AOP 就是在这里将 advice 动态织入 bean 中，若没有直接返回 bean，不做任何处理</span></span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mbd.isSingleton</code>: 是否是单例</li></ul><ul><li><p><code>this.allowCircularReferences</code>: 是否允许循环依赖，很抱歉，并没有找到在配置文件中如何配置，但是在 AbstractRefreshableApplicationContext 中提供了设置函数，可以通过硬编码的方式进行设置或者可以通过自定义命名空间进行配置，其中硬编码的方式代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext bf = <span class="keyword">new</span> ClassPathXmlApplicationContext (<span class="string">"aspectTest.xml"</span>);</span><br><span class="line">bf.setAllowBeanDefinitionOverriding(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>isSingletonCurrentlyInCreation(beanName)</code>: 该bean是否在创建中。在Spring中，会有个专门的属性默认为<code>DefaultSingletonBeanRegistry</code>的<code>singletonsCurrentlyInCreation</code>来记录bean的加载状态，在bean开始创建前会将beanName记录在属性中，在bean创建结束后会将 beanName 从属性中移除。</p><p>记录状态的点，不同 scope 的位置不一样，以  <code>singleton</code> 为例，在singleton下记录属性的函数是在<code>DefaultSingletonBeanRegistry</code>类的 <code>public Object getSingleton(String beanName, ObjectFactory singletonFacotry)</code> 函数的 <code>beforeSingletonCreation(beanName)</code> 和 <code>afterSingletonCreation(beanName)</code> 中，在这两段函数中分别是 <code>this.singletonsCurrentlyInCreation.add(beanName)</code> 与 <code>this.singletonsCurrentlyInCreation.remove(beanName)</code> 来进行状态的记录与移除。</p></li></ul><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Populate the bean instance in the given BeanWrapper with the property values</span></span><br><span class="line"><span class="comment"> * from the bean definition.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bw BeanWrapper with bean instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">           <span class="comment">// 没有可填充的属性</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line"><span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line"><span class="comment">// to support styles of field injection.</span></span><br><span class="line">     <span class="comment">// 给 InstantiationAwareBeanPostprocessors 最优一次机会在属性设置前来改变 bean</span></span><br><span class="line">     <span class="comment">// 如：可以用来支持属性注入的类型</span></span><br><span class="line"><span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123; <span class="comment">// 1</span></span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 返回值为是否继续填充 bean</span></span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果后处理器发出停止填充命令则终止后续的运行</span></span><br><span class="line"><span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">       <span class="comment">// 根据名称自动注入</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">       <span class="comment">// 根据类型自动注入</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 后处理器已经初始化</span></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="comment">// 需要依赖检查</span></span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123; <span class="comment">// 3</span></span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    <span class="comment">// 对所有需要依赖检查的属性进行后处理</span></span><br><span class="line">pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">           <span class="comment">// 依赖检查，对应 depends-on 属性， 3.0 已经弃用此属性</span></span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 将属性应用到 bean 中</span></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>InstantiationAwareBeanPostProcessor</code>处理器的<code>postProcessAfterInstantiation</code>函数的应用，此函数可以控制程序是否继续进行属性填充。</li><li>根据注入类型（byName/byType），提取依赖的 bean，并统一存入<code>PropertyValues</code>中。</li><li>应用<code>InstantiationAwareBeanPostProcessor</code>处理器的<code>postProcessPropertyValues</code>方法，对属性获取完毕填充前对属性的再次处理，典型应用是 <code>RequiredAnnotationBeanPostProcessor</code> 类中对属性的验证。</li><li>将所有<code>PropertyValues</code>中的属性填充至<code>BeanWrapper</code>中。</li></ol><p>在上面的步骤中有几个地方是我们比较感兴趣的，它们分别是依赖注入（ <code>autowireByName</code>/<code>autowireByType</code>）以及属性填充，那么，接下来进一步分析这几个功能的实现细节。</p><h3 id="autowireByName"><a href="#autowireByName" class="headerlink" title="autowireByName"></a><code>autowireByName</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 寻找 bw 中需要依赖注入的属性</span></span><br><span class="line">String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line"><span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">           <span class="comment">// 递归初始化相关的 bean </span></span><br><span class="line">Object bean = getBean(propertyName);</span><br><span class="line">pvs.add(propertyName, bean);</span><br><span class="line">             <span class="comment">// 注册依赖</span></span><br><span class="line">registerDependentBean(propertyName, beanName);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Added autowiring by name from bean name '"</span> + beanName +</span><br><span class="line"><span class="string">"' via property '"</span> + propertyName + <span class="string">"' to bean named '"</span> + propertyName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Not autowiring property '"</span> + propertyName + <span class="string">"' of bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' by name: no matching bean found"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autowireByType"><a href="#autowireByType" class="headerlink" title="autowireByType"></a><code>autowireByType</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">TypeConverter converter = getCustomTypeConverter();</span><br><span class="line"><span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">converter = bw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">4</span>);</span><br><span class="line">     <span class="comment">// 寻找 bw 中需要依赖注入的属性</span></span><br><span class="line">String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line"><span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line"><span class="comment">// Don't try autowiring by type for type Object: never makes sense,</span></span><br><span class="line"><span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line"><span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line">                <span class="comment">// 探测指定属性的 set 方法</span></span><br><span class="line">MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line"><span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line"><span class="keyword">boolean</span> eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());</span><br><span class="line">DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">                <span class="comment">// 解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 </span></span><br><span class="line">                <span class="comment">// autowireBeanNames 中，当属性存在多个封装 bean 时，如:</span></span><br><span class="line">                  <span class="comment">// @Autowired private List&lt;A&gt; aList; 将会找到所有匹配 A 类型</span></span><br><span class="line">                  <span class="comment">// 的 bean 并将其注入</span></span><br><span class="line"><span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs.add(propertyName, autowiredArgument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">                    <span class="comment">// 注册依赖</span></span><br><span class="line">registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Autowiring by type from bean name '"</span> + beanName + <span class="string">"' via property '"</span> +</span><br><span class="line">propertyName + <span class="string">"' to bean named '"</span> + autowiredBeanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">autowiredBeanNames.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现根据名称自动匹配的第一步就是寻找 <code>bw</code> 中需要依赖注入的属性，同样对于根据类型自动匹配的实现来讲第一步也是寻找<code>bw</code>中需要依赖注入的属性，然后遍历这些属性并寻找类型匹配的 bean，其中最复杂的就是寻找类型匹配的 bean。</p><h4 id="DefaultListableBeanFactory-resolveDependency"><a href="#DefaultListableBeanFactory-resolveDependency" class="headerlink" title="DefaultListableBeanFactory#resolveDependency"></a><code>DefaultListableBeanFactory#resolveDependency</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, String requestingBeanName,</span></span></span><br><span class="line"><span class="function"><span class="params">Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line"><span class="keyword">if</span> (javaUtilOptionalClass == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> OptionalDependencyFactory().createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">         <span class="comment">// ObjectFactory 类注入的特殊处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">         <span class="comment">// javaxInjectProviderClass 类注入的特殊处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">descriptor, requestingBeanName);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 通用逻辑处理</span></span><br><span class="line">result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> shortcut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">         <span class="comment">// 用于支持 Spring 中的注解 @Value</span></span><br><span class="line">Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">&#125;</span><br><span class="line">TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line"><span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line"><span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> multipleBeans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 根据属性类型找到 beanFactory 中所有类型的匹配 bean，</span></span><br><span class="line">         <span class="comment">// 返回值的构成为： key: 匹配的 beanName, value: beanName 对应的实例化后的 bean(通过 getBean(beanName) 返回)</span></span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line"><span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 如果 autowire 的 require 属性为 true 而找到的匹配项却为空则只能抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (descriptor.isRequired()) &#123;</span><br><span class="line">raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String autowiredBeanName;</span><br><span class="line">Object instanceCandidate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line"><span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (descriptor.isRequired() || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line"><span class="keyword">return</span> descriptor.resolveNotUnique(type, matchingBeans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line"><span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line"><span class="comment">// (before 4.3 in particular when we didn't even look for collection beans).</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We have exactly one match.</span></span><br><span class="line">Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">autowiredBeanName = entry.getKey();</span><br><span class="line">instanceCandidate = entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (instanceCandidate <span class="keyword">instanceof</span> Class ?</span><br><span class="line">descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>) : instanceCandidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="applyPropertyValues"><a href="#applyPropertyValues" class="headerlink" title="applyPropertyValues"></a><code>applyPropertyValues</code></h3><p>程序运行到这里，已经完成了对所有注入属性的获取，但是获取的属性是以<code>PropertyValues</code>形式存在的，还并没有应用到已经实例化的bean中，这一工作是在<code>applyPropertyValues</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply the given property values, resolving any runtime references</span></span><br><span class="line"><span class="comment"> * to other beans in this bean factory. Must use deep copy, so we</span></span><br><span class="line"><span class="comment"> * don't permanently modify this property.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the bean name passed for better exception information</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bw the BeanWrapper wrapping the target object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pvs the new property values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">         <span class="comment">// 如果 mpvs 中的值已经被转换为对应的类型那么可以直接设置到 beanWapper 中</span></span><br><span class="line"><span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line"><span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bw.setPropertyValues(mpvs);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">original = mpvs.getPropertyValueList();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果 pvs 并不是使用 MutablePropertyValues 封装的类型，那么直接使用原始的属性获取方法</span></span><br><span class="line">original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TypeConverter converter = getCustomTypeConverter();</span><br><span class="line"><span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">converter = bw;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 获取对应的解析器</span></span><br><span class="line">BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());</span><br><span class="line"><span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 遍历属性，将属性转换为对应类的对应属性的类型</span></span><br><span class="line"><span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line"><span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String propertyName = pv.getName();</span><br><span class="line">Object originalValue = pv.getValue();</span><br><span class="line">Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">Object convertedValue = resolvedValue;</span><br><span class="line"><span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line"><span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line"><span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line"><span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">pv.setConvertedValue(convertedValue);</span><br><span class="line">&#125;</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">!((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">pv.setConvertedValue(convertedValue);</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">mpvs.setConverted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化-bean"><a href="#初始化-bean" class="headerlink" title="初始化 bean"></a>初始化 bean</h2><p>大家应该记得在 bean 配置时 bean 中有一个<code>init-method</code>的属性，这个属性的作用是在 bean 实例化前调用<code>init-method</code>指定的方法来根据用户业务进行相应的实例化。我们现在就已经进入这个方法了，首先看一下这个方法的执行位置，Spring中程序已经执行过bean的实例化，并且进行了属性的填充，而就在这时将会调用用户设定的初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">       <span class="comment">// 应用后处理器</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 激活用户自定义的 init 方法</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">         <span class="comment">// 后处理器应用</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="激活-Aware-方法"><a href="#激活-Aware-方法" class="headerlink" title="激活 Aware 方法"></a>激活 Aware 方法</h3><p>Spring 中提供一些 Aware 相关接口，比如 <code>BeanFactoryAware</code>、<code>ApplicationContextAware</code>、<code>ResourceLoaderAware</code>、<code>ServletContextAware</code> 等，实现这些 Aware 接口的 bean 在被初始之后，可以取得一些相对应的资源，例如实现<code>BeanFactoryAware</code> 的 bean 在初始后， Spring 容器将会注入 <code>BeanFactory</code> 的实例，而实现<code>ApplicationContextAware</code>的bean，在bean被初始后，将会被注入<code>ApplicationContext</code>的实例等。</p><h4 id="Aware-的使用"><a href="#Aware-的使用" class="headerlink" title="Aware 的使用"></a>Aware 的使用</h4><ol><li><p>定义 bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义 <code>BeanFactoryAware</code> 类型的 bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAware</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 bean 的时候 Spring 会自动注入 BeanFactory</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 hello 这个 bean id 从 beanFactory 获取实例</span></span><br><span class="line">        Hello hello = (Hello) beanFactory.getBean(<span class="string">"hello"</span>);</span><br><span class="line">        hello.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"testAware.xml"</span>);</span><br><span class="line">    TestAware testAware = (TestAware) ctx.getBean(<span class="string">"testAware"</span>);</span><br><span class="line">    testAware.testAware();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="invokeAwareMethods"><a href="#invokeAwareMethods" class="headerlink" title="invokeAwareMethods"></a><code>invokeAwareMethods</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理器的应用"><a href="#处理器的应用" class="headerlink" title="处理器的应用"></a>处理器的应用</h3><p><code>BeanPostProcessor</code>相信大家都不陌生，这是 Spring 中开放式架构中一个必不可少的亮点，给用户充足的权限去更改或者扩展 Spring ，而除了 <code>BeanPostProcessor</code> 外还有很多其他的 <code>PostProcessor</code>，当然大部分都是以此为基础，继承自 <code>BeanPostProcessor</code>。<code>BeanPostProcessor</code> 的使用位置就是这里，在调用客户自定义初始化方法前以及调用自定义初始化方法后分别会调用 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 和<code>postProcessAfterInitialization</code>方法，使用户可以根据自己的业务需求进行响应的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="激活自定义的-init-方法"><a href="#激活自定义的-init-方法" class="headerlink" title="激活自定义的 init 方法"></a>激活自定义的 init 方法</h3><p>客户定制的初始化方法除了我们熟知的使用配置<code>init-method</code>外，还有使自定义的 bean 实现<code>InitializingBean</code>接口，并在<code>afterPropertiesSet</code>中实现自己的初始化业务逻辑。</p><p><code>init-method</code>与<code>afterPropertiesSet</code>都是在初始化 bean 时执行，执行顺序是<code>afterPropertiesSet</code>先执行，而<code>init-method</code>后执行。</p><p>在<code>invokeInitMethods</code>方法中就实现了这两个步骤的初始化方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// 首先会检查是否是 InitializingBean，如果是的话需要调用 afterPropertiesSet 方法</span></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 属性初始化后的处理</span></span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">if</span> (initMethodName != <span class="keyword">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">              <span class="comment">// 调用自定义初始化方法</span></span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册-DisposableBean"><a href="#注册-DisposableBean" class="headerlink" title="注册 DisposableBean"></a>注册 <code>DisposableBean</code></h2><p>Spring 中不但提供了对于初始化方法的扩展入口，同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，除了我们熟知的配置属性<code>destroy-method</code>方法外，用户还可以注册后处理器<code>DestructionAwareBeanPostProcessor</code>来统一处理bean的销毁方法，代码如下(<code>doCreateBean</code>中)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">AccessControlContext acc = (System.getSecurityManager() != <span class="keyword">null</span> ? getAccessControlContext() : <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// Register a DisposableBean implementation that performs all destruction</span></span><br><span class="line"><span class="comment">// work for the given bean: DestructionAwareBeanPostProcessors,</span></span><br><span class="line"><span class="comment">// DisposableBean interface, custom destroy method.</span></span><br><span class="line">              <span class="comment">// 单例模式下注册需要销毁的 bean，此方法中会处理实现 DisposableBean 的 bean，</span></span><br><span class="line">              <span class="comment">// 并且堆所有的 bean 使用 DestructionAwareBeanPostProcessors 处理</span></span><br><span class="line">              <span class="comment">// DisposableBean DestructionAwareBeanPostProcessors</span></span><br><span class="line">registerDisposableBean(beanName,</span><br><span class="line"><span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// A bean with a custom scope...</span></span><br><span class="line">              <span class="comment">// 自定义 scope 的处理</span></span><br><span class="line">Scope scope = <span class="keyword">this</span>.scopes.get(mbd.getScope());</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + mbd.getScope() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">scope.registerDestructionCallback(beanName,</span><br><span class="line"><span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在经历过 &lt;code&gt;AbstractAutowireCapableBeanFactory#createBean&lt;/code&gt; 中的 &lt;code&gt;resolveBeforeInstantiation&lt;/code&gt; 方法后，程序有两个选择，如果创建了代理或者说重写了 &lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt; 的 &lt;code&gt;postProcessBeforeInstantiation&lt;/code&gt; 方法并在方法 &lt;code&gt;postProcessBeforeInstantiation&lt;/code&gt; 中改变了 &lt;code&gt;bean&lt;/code&gt;，则直接返回就可以了，否则需要进行常规 &lt;code&gt;bean&lt;/code&gt; 的创建。而这常规 &lt;code&gt;bean&lt;/code&gt; 的创建就是在 &lt;code&gt;doCreateBean&lt;/code&gt; 中完成的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractAutowireCapableBeanFactory#doCreateBean&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列—虚拟机类加载机制</title>
    <link href="http://yoursite.com/2017/11/17/JVM%E7%B3%BB%E5%88%97%E2%80%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/11/17/JVM系列—虚拟机类加载机制/</id>
    <published>2017-11-17T08:59:07.000Z</published>
    <updated>2017-11-22T16:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h3><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><a id="more"></a><h3 id="为什么有类加载"><a href="#为什么有类加载" class="headerlink" title="为什么有类加载"></a>为什么有类加载</h3><p>Class 文件中所描述的信息，是使用字节码进行描述的，而这种描述必然是机器无法读取的，需要 JVM 在中间作用来将其转换成机器可以运行的信息。而且对于 Java 语言来说，类型的加载，连接和初始化过程都在程序运行期间完成，这虽然会令类加载时稍微增加一些性能上的开销，但是所带来的是 Java 高于 C 这类语言的灵活度，Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><h3 id="类加载发生在什么时候"><a href="#类加载发生在什么时候" class="headerlink" title="类加载发生在什么时候"></a>类加载发生在什么时候</h3><h4 id="类加载的生命周期"><a href="#类加载的生命周期" class="headerlink" title="类加载的生命周期"></a>类加载的生命周期</h4><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下图所示：</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_33/1.png?raw=true" alt="类的生命周期"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，<strong>类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）</strong>。注意，这里<strong>笔者写的是按部就班地『开始』</strong>，而不是按部就班地“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。</p><h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>什么情况下需要开始类加载过程的第一个阶段加载？Java虚拟机规范中并没有进行强制约束，也就是说不同虚拟机上面实现可能是不一样的，这个由虚拟机的具体实现来自由把握。</p><h4 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h4><p>对于初始化阶段，虚拟机规范则是严格规定了<strong>有且只有</strong>5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）。</p><h5 id="特定字节码指令"><a href="#特定字节码指令" class="headerlink" title="特定字节码指令"></a>特定字节码指令</h5><p>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这 4 条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</p><ul><li>new: 创建一个对象，并将其引入值压入栈顶</li><li>getstatic: 获取指定类的静态域，并将其值压入栈顶</li><li>putstatic: 为指定的类的静态域赋值</li><li>invokestatic: 调用静态方法</li></ul><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p><h5 id="初始化子类其父类未被初始化"><a href="#初始化子类其父类未被初始化" class="headerlink" title="初始化子类其父类未被初始化"></a>初始化子类其父类未被初始化</h5><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p><h5 id="用户指定的主类"><a href="#用户指定的主类" class="headerlink" title="用户指定的主类"></a>用户指定的主类</h5><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类。</p><h5 id="JDK1-7-动态语言支持"><a href="#JDK1-7-动态语言支持" class="headerlink" title="JDK1.7 动态语言支持"></a>JDK1.7 动态语言支持</h5><p>当使用 JDK 1.7 的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果是 <code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p><h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><p>上述 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，接下来举三个被动引用的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.jvm.passive_reference;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line">      <span class="comment">// 只会输出 SuperClass init! 而不会输出 SubClass init!</span></span><br><span class="line">        System.out.println(SubClass.value); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 通过数组定义来引用类，不会触发此类的初始化</span></span><br><span class="line">      <span class="comment">// 没有输出</span></span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>]; <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，</span></span><br><span class="line">        <span class="comment">// 因此不会触发定义常量的类的初始化</span></span><br><span class="line">      <span class="comment">// 因为在编译阶段通过常量传播优化，已经将此常量值 "hello world" 存储到 </span></span><br><span class="line">      <span class="comment">// NotInitialization 类的常量池中，以后 NotInitialization 对常量</span></span><br><span class="line">        <span class="comment">// ConstClass.HELLOWORLD 的引用都被转化为 NotInitialization 类对自身常量池的引用</span></span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment"># 1 输出结果</span></span><br><span class="line"><span class="comment">SuperClass init!</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment"># 3 输出结果</span></span><br><span class="line"><span class="comment">hello world</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><blockquote><p> 扩展：至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。使用Sun HotSpot虚拟机通过-XX:+TraceClassLoading参数可观察到此操作会导致子类的加载（但未初始化）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;  ....</span><br><span class="line">&gt;  [Loaded NotInitialization from file:/Users/binglau/code/cradle/Java-demo/basic/src/main/java/io/github/binglau/jvm/passive_reference/]</span><br><span class="line">&gt;  [Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk8/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">&gt;  [Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk8/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">&gt;  [Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk8/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">&gt;  [Loaded SuperClass from file:/Users/binglau/code/cradle/Java-demo/basic/src/main/java/io/github/binglau/jvm/passive_reference/]</span><br><span class="line">&gt;  [Loaded SubClass from file:/Users/binglau/code/cradle/Java-demo/basic/src/main/java/io/github/binglau/jvm/passive_reference/]</span><br><span class="line">&gt;  SuperClass init</span><br><span class="line">&gt;  123</span><br><span class="line">&gt;  hello world</span><br><span class="line">&gt;  [Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk8/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">&gt;  [Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk8/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p> 上述输入皆没有加载相应的类</p></blockquote><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>需要做的事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>其规定并非具体，而是根据各个虚拟机实现来定义的，比如『通过一个类的全限定名来获取定义此类的二进制字节流』这条，并没有指定非要从一个 class 文件中获取二进制字节流，有很多别样的玩法，比如：</p><ul><li>从ZIP包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li><li>从网络中获取，这种场景最典型的应用就是Applet。</li><li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li><li>由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。</li><li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li><li>….</li></ul><h4 id="加载类与数组"><a href="#加载类与数组" class="headerlink" title="加载类与数组"></a>加载类与数组</h4><p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的<code>loadClass()</code>方法）。</p><p>对于数组类而言，情况就有所不同，<strong>数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的</strong>。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为C）创建过程就遵循以下规则：</p><ul><li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，后面会介，一个类必须与类加载器一起确定唯一性）。</li><li>如果数组的组件类型不是引用类型（例如int［］数组），Java虚拟机将会把数组 C 标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>验证阶段大致上会完成下面 4 个阶段的验证工作：</p><h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>本阶段要验证字节流是否符合 Class 文件格式的规范，是否能被当前版本的虚拟机处理。主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。本阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的 3 个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p><p>包括但不限于：</p><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前虚拟机处理范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li><code>CONSTANT_Utf8_info</code> 型的常量中是否有不符合UTF8编码的数据。</li><li>Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li></ul><h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p> 本阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p><p>可能包括但不限于：</p><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li></ul><h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>本阶段是整个验证过程中最复杂的一个阶段，<strong>主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</strong>。在元数据验证阶段对元数据信息中的数据类型做完校验后，本阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。例如：</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换是有效的。可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li></ul><p>别相信机器给你纠错，不然他就先给自己纠错了。</p><h4 id="符合引用验证"><a href="#符合引用验证" class="headerlink" title="符合引用验证"></a>符合引用验证</h4><p>本阶段发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li></ul><p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>异常的子类，如<code>java.lang.IllegalAccessError</code>、<code>java.lang.NoSuchFieldError</code>、<code>java.lang.NoSuchMethodError</code>等。</p><p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p><p> 本阶段中有两个容易产生混淆的概念需要强调一下：</p><ul><li>此时进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li><li>这里所说的初始值“通常情况”下是数据类型的零值。</li></ul><h4 id="通常情况"><a href="#通常情况" class="headerlink" title="通常情况"></a>通常情况</h4><p><code>public static int value = 123;</code> 这里的 value 在准备之后的值是 0 而不是 123</p><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p><code>public static final int value = 123;</code> </p><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在前一章讲解Class文件格式的时候已经出现过多次，在 Class 文件中它以 <code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code> 等类型的常量出现。那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p><ul><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中</strong>。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li><li>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。<strong>直接引用是和虚拟机实现的内存布局相关的</strong>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行<code>anewarray</code>、<code>checkcast</code>、<code>getfield</code>、<code>getstatic</code>、<code>instanceof</code>、<code>invokedynamic</code>、<code>invokeinterface</code>、<code>invokespecial</code>、<code>invokestatic</code>、<code>invokevirtual</code>、<code>ldc</code>、<code>ldc_w</code>、<code>multianewarray</code>、<code>new</code>、<code>putfield</code>和 <code>putstatic</code> 这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><h4 id="符号解析中的差异"><a href="#符号解析中的差异" class="headerlink" title="符号解析中的差异"></a>符号解析中的差异</h4><p>对同一个符号引用进行多次解析请求是很常见的事情，<strong>除<code>invokedynamic</code>指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。</strong>无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p><p>对于<code>invokedynamic</code>指令，上面规则则不成立。当碰到某个前面已经由<code>invokedynamic</code>指令触发过解析的符号引用时，并不意味着这个解析结果对于其他<code>invokedynamic</code>指令也同样生效。因为<code>invokedynamic</code>指令的目的本来就是用于动态语言支持（目前仅使用Java语言不会生成这条字节码指令），它所对应的引用称为『动态调用点限定符』（Dynamic Call Site Specifier），这里『动态』的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。</p><h4 id="解析对象"><a href="#解析对象" class="headerlink" title="解析对象"></a>解析对象</h4><p>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>7类符号引用进行，分别对应于常量池的 <code>CONSTANT_Class_info</code>、<code>CONSTANT_Field-ref_info</code>、<code>CONSTANT_Methodref_info</code>、<code>CONSTANT_InterfaceMethodref_info</code>、<code>CONSTANT_MethodType_info</code>、<code>CONSTANT_MethodHandle_info</code>和 <code>CONSTANT_InvokeDynamic_info</code> 7种常量类型</p><h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：</p><ol><li><strong>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。</strong>在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li><li><strong>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型</strong>。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li><li><strong>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。</strong>如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li></ol><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内 <code>class_index</code> 项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。<strong>如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索</strong>。</p><ol><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束（<strong>类本身字段描述</strong>）</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。（<strong>接口及接口继承</strong>）</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。（<strong>类继承</strong>）</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li><li>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</li></ol><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。</p><ol><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。（<strong>类本身方法</strong>）</li><li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。（<strong>类继承父类的方法</strong>）</li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出<code>java.lang.AbstractMethodError</code>异常。(<strong>抽象类查找抽象方法</strong>)</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。</li><li>如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出<code>java.lang.IllegalAccessErro</code>r异常。</li></ol><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>接口方法也需要先解析出接口方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p><ol><li>与类方法解析不同，如果在接口方法表中发现<code>class_index</code>中的索引C是个类而不是接口，那就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。(<strong>接口确认</strong>)</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。（<strong>查找接口本身方法</strong>）</li><li>否则，在接口C的父接口中递归查找，直到<code>java.lang.Object</code>类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。（<strong>查找继承接口方法</strong>）</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li></ol><p>由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出<code>java.lang.IllegalAccessError</code>异常。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化之前除了用户可以自定义类加载器参与之前都是由 JVM 主导和控制，到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）</p><p>在准备阶段，类变量已经赋过一次系统要求的初始值。在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：<strong>初始化阶段是执行类构造器＜clinit＞()方法的过程。</strong></p><h4 id="lt-client-gt-方法"><a href="#lt-client-gt-方法" class="headerlink" title="&lt;client&gt;() 方法"></a><code>&lt;client&gt;()</code> 方法</h4><p><code>＜clinit＞()</code>方法是由编译器自动收集<strong>类中的所有类变量的赋值动作和静态语句块</strong>（<code>static{}</code>块）中的语句合并产生。<strong>编译器收集的顺序由语句在源文件中出现的顺序所决定</strong>。<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>，示例代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.jvm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassinitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;<span class="comment">//给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);<span class="comment">//这句编译器会提示"非法向前引用"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lt-clinit-gt-执行特定和细节"><a href="#lt-clinit-gt-执行特定和细节" class="headerlink" title="&lt;clinit&gt;()执行特定和细节"></a><code>&lt;clinit&gt;()</code>执行特定和细节</h4><p>这里只限于 Java 语言编译产生的 Class 文件，并不包括其他 JVM 语言。</p><ul><li><p><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，<strong>虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕</strong>。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是java.lang.Object。</p></li><li><p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并<strong>不是必需的</strong>，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此<strong>接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。</strong>另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p></li><li><p><strong>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞（被唤醒之后不会再次进入<code>&lt;clinit&gt;()</code>方法，同一个类加载器下一个类型只会初始化一次），在实际应用中这种阻塞往往是很隐蔽的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.jvm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassinitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">/*如果不加上这个if语句，编译器将提示"Initializer does not complete normally"并拒绝编译*/</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"init DeadLoopClass"</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"start"</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"run over"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">运行结果如下，即一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待</span></span><br><span class="line"><span class="comment">Thread[Thread-1,5,main]start</span></span><br><span class="line"><span class="comment">Thread[Thread-0,5,main]start</span></span><br><span class="line"><span class="comment">Thread[Thread-1,5,main]init DeadLoopClass</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>《深入理解 Java 虚拟机》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;什么是类加载&quot;&gt;&lt;a href=&quot;#什么是类加载&quot; class=&quot;headerlink&quot; title=&quot;什么是类加载&quot;&gt;&lt;/a&gt;什么是类加载&lt;/h3&gt;&lt;p&gt;虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。&lt;/p&gt;
    
    </summary>
    
      <category term="基础原理" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码解析—Bean的加载前奏</title>
    <link href="http://yoursite.com/2017/11/14/Spring-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94Bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%89%8D%E5%A5%8F/"/>
    <id>http://yoursite.com/2017/11/14/Spring-源码解析—Bean的加载前奏/</id>
    <published>2017-11-14T08:59:44.000Z</published>
    <updated>2017-11-22T16:08:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>User user = (User)context.getBean(&quot;testbean&quot;);</code></p><p>由这句入手</p><a id="more"></a><p><code>AbstractBeanFactory#getBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// 提取对应的 beanName</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  检查缓存中或者实例工厂中是否有对应的实例</span></span><br><span class="line"><span class="comment">  为什么首先会使用这段代码呢，因为在创建单例 bean 的时候会存在依赖注入的情况，</span></span><br><span class="line"><span class="comment">  而在创建依赖的时候为了避免循环依赖，Spring 创建 bean 的原则是不等 bean 创建</span></span><br><span class="line"><span class="comment">  完成就会将创建的 bean 的 ObjectFactory 提前曝光，也就是将 ObjectFactory 加入</span></span><br><span class="line"><span class="comment">  缓存中，一旦下个 bean 创建时候需要依赖上个 bean 则直接使用 ObjectFactory</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 返回对应的实例，有时候存在诸如 BeanFactory 的情况并不是直接返回实例本身而是返回指定方法返回的实例</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      只有在单例情况才会尝试解决依赖循环，原型模型情况，如果存在</span></span><br><span class="line"><span class="comment">      A 中有 B 的熟悉，B 中有 A 的属性，那么当依赖注入的时候，就会产生当 A 还未创建完的时候</span></span><br><span class="line"><span class="comment">      因为对于 B 的创建再次返回创建 ，造成依赖循环，也就是下面的情况</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="comment">// 如果 beanDefinitionMap 中也就是在所有已经加载的类中不包括 beanName 则</span></span><br><span class="line">      <span class="comment">// 尝试从 parentBeanFactory 中检测</span></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line">          <span class="comment">// 递归到 BeanFactory 中寻找</span></span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果不是仅仅做类型检查则是创建 bean，这里要进行记录</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 将存储 XML 配置文件的 GernericBeanDefinition 转换为 RootBeanDefinition，</span></span><br><span class="line">          <span class="comment">// 如果指定 BeanName 是子 Bean 的话同时会合并父类的相关属性</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">          <span class="comment">// 若存在依赖则需要递归实例化依赖的 bean</span></span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">// 缓存依赖调用</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line">          <span class="comment">// 实例化依赖的 bean 后便可以实例化 mbd 本身了</span></span><br><span class="line">          <span class="comment">// singleton 模式的创建</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">              <span class="comment">// prototype 模式的创建 (new)</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 指定的 scope 上实例化 bean</span></span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line"><span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  <span class="comment">// 检查需要的类型是否符合 bean 的实际类型</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致过程：</p><ol><li><p>转换对应 beanName。这里的 beanName 可能是别名，可能是 FactoryBean，所以需要一系列的解析：</p><ol><li>去除 FactoryBean 的修饰符，也就是如果 <code>name=&quot;&amp;aa&quot;</code>，那么会首先去除 <code>&amp;</code> 使得 <code>name=aa</code></li><li>取指定 alias 所表示的最终 beanName，例如别名 A 指向名称为 B 的 bean 则返回 B；若别名 A 指向别名 B，别名 B 又指向名称为 C 的 bean 则返回 C</li></ol></li><li><p>尝试从缓存中加载单例</p><p>单例在 Spring 的同一个容器内只会被创建一次，后续在获取 bean，就直接从单例缓存中获取了。当然这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从 singletonFactories 中加载。</p><p>由于存在依赖注入的问题，所以在 Spring 中创建 bean 的原则是不等 bean 创建完成就会将创建的 ObjectFactory 提早曝光加入到缓存中，一旦下一个 bean 创建需要依赖上一个 bean 则直接使用 ObjectFactory。</p></li><li><p>bean 的实例化</p></li><li><p>原型模式的依赖检查</p><p>只有单例会尝试解决循环依赖。</p></li><li><p>在非 singleton 下检测 parentBeanFactory，看是否需要进入 parentBeanFactory 中加载（当前 BeanFactory 中无该 bean 且 parentBeanFactory 存在且存在该 bean）</p></li><li><p>将存储 XML 配置文件的 GernericBeanDefinition 转换为 RootBeanDefinition。方便 Bean 的后续处理。</p></li><li><p>寻找依赖</p></li><li><p>针对不同的  scope 进行 bean 的创建</p></li><li><p>类型转换（requiredType = true）</p></li></ol><h2 id="FactoryBean-的使用"><a href="#FactoryBean-的使用" class="headerlink" title="FactoryBean 的使用"></a>FactoryBean 的使用</h2><p>一般来说，Spring 是通过反射机制利用 bean 的 class 属性指定实现类来实例化 bean 的。FactoryBean 是为了对付配置 bean 的复杂性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line">  <span class="comment">// 如果返回 true 则 getObject() 时候会将实例放入 Spring 容器中单实例缓存池中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 <code>XxxFactoryBean</code>之后，解析<code>&lt;bean id=&quot;xxx&quot; class=&quot;xx.xx.XxxFactoryBean&quot; /&gt;</code>时候会调用该其实现的 <code>getObject()</code> 方法</p><h2 id="缓存中获取单例-bean"><a href="#缓存中获取单例-bean" class="headerlink" title="缓存中获取单例 bean"></a>缓存中获取单例 bean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置 true 表示允许早期依赖</span></span><br><span class="line"><span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查缓存中是否存在实例</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="comment">// 如果为空，则锁定全局变量并进行处理</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">          <span class="comment">// 如果此 bean 正在加载则不处理</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">              <span class="comment">// 当某些方法需要提前初始化时候会调用 addSingletonFactory 方法</span></span><br><span class="line">              <span class="comment">// 将对应的 ObjectFactory 初始化策略存储在 singletonFactories</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 调用预先设定的 getObject 方法</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">                  <span class="comment">// 记录在缓存中，earlySingletonObjects 和 singletonFactories 互斥</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先尝试从 <code>singletonObjects</code> 中获取实例，如果获取不到，则从 <code>earlySingletonObjects</code> 里面获取，如果还取不到，则尝试从 <code>singletonFactories</code> 里面获取 <code>beanName</code> 对应的 <code>ObjectFactory</code>，然后调用这个 <code>ObjectFactory</code> 的 getObject 来创建 bean，并放到 <code>earlySingletonObjects</code> 中，然后从 singletonFactories 中 remove 掉这个 ObjectFactory。</p><ul><li>singletonObjects: 用于保存 BeanName 和创建 bean 实例之间的关系，beanName -&gt; beanInstance</li><li>singletonFactories：用于保存 BeanName 和创建  bean 的工厂之间的关系，beanName -&gt; ObjectFactory</li><li>earlySingletonObjects：也是保存 BeanName 和创建 bean 实例之间的关系，与singletonObjects的不同之处在于，当一个单例bean被放到这里面后，那么当bean还在创建过程中，就可以通过getBean方法获取到了，其目的是用来检测循环引用。</li><li>registeredSingletons：用来保存当前所有已注册的bean。</li></ul><h2 id="从-bean-的实例中获取对象"><a href="#从-bean-的实例中获取对象" class="headerlink" title="从 bean 的实例中获取对象"></a>从 bean 的实例中获取对象</h2><p>无论是从缓存中获取到的 bean 还是通过不同的 scope 策略加载的 bean 都只是最原始的 bean 状态，并不一定是我们最终想要的 bean。举个例子，假如我们需要对工厂 bean 进行处理，那么这里得到的其实是工厂 bean 的初始状态，但是我们真正需要的是工厂 bean 中定义的 factory-method 方法中返回的 bean ，而<code>getObjectForBeanInstance</code> 方法就是完成这个工作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span></span><br><span class="line">     <span class="comment">// 如果指定的 name 是工厂相关(以 &amp; 为前缀)且 beanInstance 又不是 FactoryBean 类型则验证不通过</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line"><span class="comment">// If it's a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line"><span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">  <span class="comment">// 现在我们有了个 bean 的实例，这个实例可能会是正常的 bean 或者 FactoryBean</span></span><br><span class="line">  <span class="comment">// 如果是 FactoryBean 我们使用它创建实例，但如果用户想要直接获取工厂实例而不是工程对应的</span></span><br><span class="line">  <span class="comment">// getObject 方法对应的实例那么传入的 name 应该包含前缀 &amp;</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载 FactoryBean</span></span><br><span class="line">Object object = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 尝试从缓存中加载 bean</span></span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Return bean instance from factory.</span></span><br><span class="line">      <span class="comment">// 到这里已经明确指定 beanInstance 一定是 FactoryBean 类型</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">      <span class="comment">// containsBeanDefinition 检测 beanDefinitionMap 中也就是在所有已经加载的类中</span></span><br><span class="line">      <span class="comment">// 检测是否定义 beanName</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">          <span class="comment">// 将存储 XML 配置文件的 GernericBeanDefinition 转换为 RootBeanDefinition，</span></span><br><span class="line">          <span class="comment">// 如果指定 BeanName 是子 Bean 的话同时会合并父类的相关属性</span></span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 是否是用户定义而不是应用程序本身定义的</span></span><br><span class="line"><span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对 FactoryBean 正确性的验证</li><li>对非 FactoryBean 不做任何处理</li><li>对 bean 进行转换</li><li>将从 Factory 中解析 bean 的工作委托给 <code>getObjectFromFactoryBean</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line"><span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">object = alreadyThere;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, (object != <span class="keyword">null</span> ? object : NULL_OBJECT));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (object != NULL_OBJECT ? object : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 调用 ObjectFactory 的后处理器</span></span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's object failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码只是做了一件事：返回的 bean 如果是单例，那就必须要<strong>保证全局唯一</strong>，同时，也因为是单例的，所以不被重复创建，可以使用缓存来提高性能，也就是说已经加载过就要记录下来以便于下次复用，否则的话就直接获取了。</p><p>所以我们最后是在 <code>doGetObjectFromFactoryBean</code>中看到了自己想要的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object object;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessControlContext acc = getAccessControlContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 需要权限验证</span></span><br><span class="line">object = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 直接调用 getObject 方法</span></span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"FactoryBean threw exception on object creation"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not accept a null value for a FactoryBean that's not fully</span></span><br><span class="line"><span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(</span><br><span class="line">beanName, <span class="string">"FactoryBean which is currently in creation returned null from getObject"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来看 <code>doGetObjectFromFactoryBean</code> 获取对象之后，最后返回对象的过程中操作 <code>postProcessObjectFromFactoryBean</code> 做了哪些工作？</p><p><code>AbstractAutowireCapableBeanFactory#postProcessObjectFromFactoryBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">postProcessObjectFromFactoryBean</span><span class="params">(Object object, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> applyBeanPostProcessorsAfterInitialization(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于后处理器，后面来进行介绍。这里我们只需要了解在 Spring 获取 bean 的规则中有这样一条：<strong>尽可能保证所有 bean 初始化后都会调用注册的 BeanPostProcesser 的 postProcessAfterInitialization 方法进行处理</strong>，在世纪开发过程中可以根据此特性设计自己的逻辑业务。</p><h2 id="获取单例"><a href="#获取单例" class="headerlink" title="获取单例"></a>获取单例</h2><p>之前我们讲解了从缓存中获取单例的过程，那么，如果缓存中不存在已经加载的单例bean就需要从头开始bean的加载过程了，而Spring中使用getSingleton的重载方法实现bean的加载过程。</p><p><code>AbstractBeanFactory#getBean</code> 片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化依赖的 bean 后便可以实例化 mbd 本身了</span></span><br><span class="line"> <span class="comment">// singleton 模式的创建</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultSingletonBeanRegistry#getSingleton</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">  <span class="comment">// 全局变量需要同步</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 首先检查对应的 bean 是否已经加载过了，因为 singleton 模式其实就是复用以创建的 bean，</span></span><br><span class="line">      <span class="comment">// 所以这步是必须的</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// 1</span></span><br><span class="line">      <span class="comment">// 如果为空才可以进行 singleton 的 bean 的初始化</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 初始化 bean</span></span><br><span class="line">singletonObject = singletonFactory.getObject(); <span class="comment">// 4</span></span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line"><span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">ex.addRelatedCause(suppressedException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">afterSingletonCreation(beanName); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">              <span class="comment">// 加入缓存</span></span><br><span class="line">addSingleton(beanName, singletonObject); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>); <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>检查缓存是否已经加载过了</p></li><li><p>若没有加载，则记录 beanName 的正在加载状态</p></li><li><p>加载单例前记录加载状态，通过 <code>this.singletonsCurrentlyInCreation.add(beanName)</code>，以便于对循环依赖进行检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过调用参数传入的 <code>ObjectFactory</code> 的个体 <code>Object</code> 方法实例化 <code>bean</code></p></li><li><p>加载单例后的处理方法调用。当 <code>bean</code> 加载结束后需要移除缓存中对该 <code>bean</code> 的正在加载状态的记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="keyword">this</span>.singletonsCurrentlyInCreation.remove(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Singleton '"</span> + beanName + <span class="string">"' isn't currently in creation"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将结果记录至缓存并删除加载 <code>bean</code> 过程中所记录的各种辅助状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回处理结果</p></li></ol><p>虽然我们已经从外部了解了加载bean的逻辑架构，但现在我们还并没有开始对bean加载功能的探索，之前提到过， bean 的加载逻辑其实是在传入的 ObjectFactory 类型的参数singletonFactory中定义的，我们反推参数的获取，得到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>ObjectFactory</code> 的核心部分其实只是调用了 <code>createBean</code> 的方法，所以，继续~</p><h2 id="准备创建-bean"><a href="#准备创建-bean" class="headerlink" title="准备创建 bean"></a>准备创建 bean</h2><p><code>AbstractAutowireCapableBeanFactory#createBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">  <span class="comment">// 锁定 class，根据设置的 class 属性或者根据 className 来解析 Class</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); <span class="comment">// 1</span></span><br><span class="line">  <span class="comment">// 如果解析成功则 clone RootBeanDefinition 并且设置其 bean 类为解析之后的 class</span></span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line">  <span class="comment">// 验证及准备覆盖的方法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">      <span class="comment">// 给 BeanPostProcessors 一个机会来返回代理来替代真正的实例</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据设置的 class 属性或者根据 className 来解析 Class</li><li>对 override 属性进行标记及验证（<code>lookup-method</code> and <code>replace-method</code>）</li><li>应用初始化前的后处理器，解析指定 bean 是否存在初始化前的短路操作</li><li>创建 bean</li></ol><h3 id="处理-override-属性"><a href="#处理-override-属性" class="headerlink" title="处理 override 属性"></a>处理 <code>override</code> 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line"><span class="comment">// Check that lookup methods exists.</span></span><br><span class="line">MethodOverrides methodOverrides = getMethodOverrides();</span><br><span class="line"><span class="keyword">if</span> (!methodOverrides.isEmpty()) &#123;</span><br><span class="line">Set&lt;MethodOverride&gt; overrides = methodOverrides.getOverrides();</span><br><span class="line"><span class="keyword">synchronized</span> (overrides) &#123;</span><br><span class="line"><span class="keyword">for</span> (MethodOverride mo : overrides) &#123;</span><br><span class="line">prepareMethodOverride(mo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareMethodOverride</span><span class="params">(MethodOverride mo)</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取对应类中对应方法名的个数</span></span><br><span class="line"><span class="keyword">int</span> count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(</span><br><span class="line"><span class="string">"Invalid method override: no method with name '"</span> + mo.getMethodName() +</span><br><span class="line"><span class="string">"' on class ["</span> + getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// Mark override as not overloaded, to avoid the overhead of arg type checking.</span></span><br><span class="line">      <span class="comment">// 标记 MethoOverride 暂未被覆盖，避免参数类型检查的开销</span></span><br><span class="line">mo.setOverloaded(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于方法的匹配来讲，如果一个类中存在若干个重载方法，那么，在函数调用及增强的时候还需要根据参数类型进行匹配，来最终确认当前调用的到底是哪个函数。但是，Spring将一部分匹配工作在这里完成了，如果当前类中的方法只有一个，那么就设置重载该方法没有被重载，这样在后续调用的时候便可以直接使用找到的方法，而不需要进行方法的参数匹配验证了，而且还可以提前对方法存在性进行验证，正可谓一箭双雕。</p><h3 id="实例化的前置处理"><a href="#实例化的前置处理" class="headerlink" title="实例化的前置处理"></a>实例化的前置处理</h3><p><strong>AOP基于前置处理后的短路判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">  <span class="comment">// 给 BeanPostProcessors 一个机会来返回代理来替代真正的实例</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">  <span class="comment">// 提供一个短路判断，当经过处理之后的 bean 若不为空，则直接返回结果。</span></span><br><span class="line">  <span class="comment">// 我们所熟知的 AOP 功能就是基于这里的判断</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">Object bean = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 如果尚未被解析</span></span><br><span class="line"><span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line"><span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>applyBeanPostProcessorsBeforeInstantiation</code> 与 <code>applyBeanPostProcessorsAfterInitialization</code> 分别对应实例化前后的处理器，实现也挺简单的，无非是对后处理器中的所有 <code>InstantiationAwareBeanPostProcessor</code> 类型的后处理器进行 <code>postProcessBeforeInstantiation</code> 方法和 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法的调用</p><h4 id="实例化前的后处理器应用"><a href="#实例化前的后处理器应用" class="headerlink" title="实例化前的后处理器应用"></a>实例化前的后处理器应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例化后的后处理器应用"><a href="#实例化后的后处理器应用" class="headerlink" title="实例化后的后处理器应用"></a>实例化后的后处理器应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲解从缓存中获取单例bean的时候就提到过，Spring中的规则是在bean的初始化后尽可能保证将注册的后处理器的postProcessAfterInitialization方法应用到该bean中，因为如果返回的bean不为空，那么便不会再次经历普通bean的创建过程，所以只能在这里应用后处理器的postProcessAfterInitialization方法。</p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><h3 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h3><p>循环依赖就是循环引用，就是两个或多个 bean 相互之间持有对方。循环依赖不是循环调用，循环调用是指方法之间的环调用的，循环调用除非有终止条件，否则无法解决。</p><h3 id="Spring-如何解决循环依赖"><a href="#Spring-如何解决循环依赖" class="headerlink" title="Spring 如何解决循环依赖"></a>Spring 如何解决循环依赖</h3><p>我们先来定义一个循环引用类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.circle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testB.b();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestB <span class="title">getTestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.github.binglau.circle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestC testC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testC.c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestC <span class="title">getTestC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestC</span><span class="params">(TestC testC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testC = testC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.github.binglau.circle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testA.a();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestA <span class="title">getTestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring 中将循环依赖的处理分成了 3 中情况</p><h4 id="构造器循环依赖"><a href="#构造器循环依赖" class="headerlink" title="构造器循环依赖"></a>构造器循环依赖</h4><p>无法解决，抛出 <code>BeanCurrentlyInCreationException</code> 异常</p><p>Spring容器将每一个正在创建的bean标识符放在一个“当前创建bean池”中，bean标识符在创建过程中将一直保持在这个池中，因此如果在创建 bean 过程中发现自己已经在“当前创建bean池”里时，将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的bean将从“当前创建bean池”中清除掉。</p><p>直观的测试</p><ol><li><p>创建配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testA"</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.circle.TestA"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"testB"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testB"</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.circle.TestB"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"testC"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testC"</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.circle.TestC"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"testA"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = BeanCurrentlyInCreationException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCircleByConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test.xml"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Throwable el = e.getCause().getCause().getCause();</span><br><span class="line">        <span class="keyword">throw</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="setter-循环依赖"><a href="#setter-循环依赖" class="headerlink" title="setter 循环依赖"></a>setter 循环依赖</h4><p>表示通过 setter 注入方式构成的循环依赖。对于 setter 注入造成的依赖是通过 Spring 容器提前暴露刚完成构造器注入但未完成其他步骤（如 setter 注入）的 bean 来完成的，而且只能解决单例作用域的 bean 循环依赖。通过提前暴露一个单例工厂方法，从而使其他 bean 能引用到该 bean ，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory() &#123;</span><br><span class="line">　 <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">　　 <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>具体步骤如下：</p><ol><li>Spring 容器创建单例 <code>testA</code> bean，首先根据无参构造器创建 bean，并暴露一个 <code>ObjectFactory</code> 用于返回一个提前暴露一个创建中的 bean，并将<code>testA</code>标识符放到 『当前创建 bean 池』，然后进行 setter 注入 <code>testB</code>。</li><li>Spring 容器创建单例<code>testB</code>bean，首先根据无参构造器创建 bean，并暴露一个<code>ObjectFactory</code>用于返回一个提前暴露一个创建中的 bean，并将“testB”标识符放到『当前创建bean池』，然后进行 setter 注入 <code>circle</code>。</li><li>Spring 容器创建单例<code>testC</code> bean，首先根据无参构造器创建 bean，并暴露一个<code>ObjectFactory</code>用于返回一个提前暴露一个创建中的 bean，并将<code>testC</code>标识符放到『当前创建bean池』，然后进行setter注入<code>testA</code>。进行注入<code>testA</code>时由于提前暴露了<code>ObjectFactory</code>工厂，从而使用它返回提前暴露一个创建中的 bean。</li><li>最后在依赖注入<code>testB</code>和<code>testA</code>，完成 setter 注入。</li></ol><h4 id="prototype-范围的依赖处理"><a href="#prototype-范围的依赖处理" class="headerlink" title="prototype 范围的依赖处理"></a>prototype 范围的依赖处理</h4><p>对于 <code>prototype</code> 作用域 bean，Spring 容器无法完成依赖注入，因为 Spring 容器不进行缓存 <code>prototype</code> 作用域的 bean，因此无法提前暴露一个创建中的 bean。</p><blockquote><p> 关于创建 bean 详见下篇文章</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;User user = (User)context.getBean(&amp;quot;testbean&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由这句入手&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring-源码分析-bean的解析(3)</title>
    <link href="http://yoursite.com/2017/11/12/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-bean%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2017/11/12/Spring源码分析-bean的解析（3）/</id>
    <published>2017-11-12T08:58:42.000Z</published>
    <updated>2017-11-22T16:09:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 当前版本 Spring 4.3.8</p></blockquote><h2 id="自定义标签的解析"><a href="#自定义标签的解析" class="headerlink" title="自定义标签的解析"></a>自定义标签的解析</h2><h3 id="自定义标签使用"><a href="#自定义标签使用" class="headerlink" title="自定义标签使用"></a>自定义标签使用</h3><p>在很多情况下，当使用默认配置过于繁琐时候，解析工作或许是一个不得不考虑的负担。Spring 提供了可扩展 Scheme 的支持。大概需要以下几个步骤：</p><a id="more"></a><ol><li><p>创建一个需要扩展的组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个 XSD 文件描述组件内容</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;xsd:schema xmlns=<span class="string">"http://www.binglau.com/schema/user"</span></span><br><span class="line">            xmlns:xsd=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span><br><span class="line">            targetNamespace=<span class="string">"http://www.binglau.com/schema/user"</span></span><br><span class="line">            elementFormDefault=<span class="string">"qualified"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;xsd:element name=<span class="string">"user"</span>&gt;</span><br><span class="line">        &lt;xsd:complexType&gt;</span><br><span class="line">            &lt;xsd:attribute name=<span class="string">"id"</span> type=<span class="string">"xsd:string"</span>/&gt;</span><br><span class="line">            &lt;xsd:attribute name=<span class="string">"userName"</span> type=<span class="string">"xsd:string"</span>/&gt;</span><br><span class="line">            &lt;xsd:attribute name=<span class="string">"email"</span> type=<span class="string">"xsd:string"</span>/&gt;</span><br><span class="line">        &lt;/xsd:complexType&gt;</span><br><span class="line">    &lt;/xsd:element&gt;</span><br><span class="line">&lt;/xsd:schema&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建一个文件，实现 <code>BeanDefinitionParser</code> 接口，用来解析 XSD 文件中的定义和组件定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.binglau.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Element 对应的类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 element 中解析并提取对应的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">        String userName = element.getAttribute(<span class="string">"userName"</span>);</span><br><span class="line">        String email = element.getAttribute(<span class="string">"email"</span>);</span><br><span class="line">        <span class="comment">// 将提取的数据放入 BeanDefinitionBuilder 中，待到完成所有 bean 的解析后统一注册到 beanFactory 中</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(userName)) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">"userName"</span>, userName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(email)) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">"email"</span>, email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个 Handler 文件，扩展自 NamespaceHandlerSupport，目的是将组件注册到 Spring 容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"user"</span>, <span class="keyword">new</span> UserBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写 Spring.handlers 和 Spring.schemas 文件（resources/MATE-INF）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Spring.handlers</span><br><span class="line">http\://www.binglau.com/schema/user=io.github.binglau.MyNamespaceHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Spring.schemas</span><br><span class="line">http\://www.binglau.com/schema/user.xsd=user-xsd.xsd</span><br></pre></td></tr></table></figure></li></ol><p>测试：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:myname</span>=<span class="string">"http://www.binglau.com/schema/user"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.binglau.com/schema/user http://www.binglau.com/schema/user.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">myname:user</span> <span class="attr">id</span>=<span class="string">"testbean"</span> <span class="attr">userName</span>=<span class="string">"aaa"</span> <span class="attr">email</span>=<span class="string">"bbb"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.bean.TestBean"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.binglau.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactory context = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"beanFactory.xml"</span>));</span><br><span class="line">        User user = (User)context.getBean(<span class="string">"testbean"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">User(userName=aaa, email=bbb)</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h3 id="自定义标签解析"><a href="#自定义标签解析" class="headerlink" title="自定义标签解析"></a>自定义标签解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * "import", "alias", "bean".</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>delegate.parseCustomElement(ele)</code> 既是对自定义标签的解析</p><p><code>BeanDefinitionParserDelegate.parseCustomElement</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// containingBd 为父类 bean，对顶层元素的解析应设置为 null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取对应的命名空间</span></span><br><span class="line">String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">     <span class="comment">// 根据命名空间找到对应的 NamespaceHandler</span></span><br><span class="line">NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 调用自定义的 NamespaceHandler 进行解析</span></span><br><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取标签的命名空间"><a href="#获取标签的命名空间" class="headerlink" title="获取标签的命名空间"></a>获取标签的命名空间</h4><p>直接调用 <code>org.w3c.dom.Node</code> 中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNamespaceURI</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node.getNamespaceURI();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提取自定义标签处理器"><a href="#提取自定义标签处理器" class="headerlink" title="提取自定义标签处理器"></a>提取自定义标签处理器</h4><p><code>private final XmlReaderContext readerContext</code> 即 <code>new ClassPathResource(&quot;beanFactory.xml&quot;)</code></p><p>在 <code>readerContext</code> 初始化的时候其属性 <code>namespaceHandlerResolver</code> 已经被初始化为 <code>DefaultNamespaceHandlerResolver</code> 实例，所以，这里实际调用了 <code>DefaultNamespaceHandlerResolver</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Locate the &#123;<span class="doctag">@link</span> NamespaceHandler&#125; for the supplied namespace URI</span></span><br><span class="line"><span class="comment"> * from the configured mappings.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> namespaceUri the relevant namespace URI</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the located &#123;<span class="doctag">@link</span> NamespaceHandler&#125;, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取所有已有配置的 handler 映射</span></span><br><span class="line">Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">     <span class="comment">// 根据命名空间找到对应的信息</span></span><br><span class="line">Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">         <span class="comment">// 已经做过解析的情况，直接从缓存读取</span></span><br><span class="line"><span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 没有做过解析，则返回的是类路径</span></span><br><span class="line">String className = (String) handlerOrClassName;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 使用反射 将类路径转换为类</span></span><br><span class="line">Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line"><span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Class ["</span> + className + <span class="string">"] for namespace ["</span> + namespaceUri +</span><br><span class="line"><span class="string">"] does not implement the ["</span> + NamespaceHandler.class.getName() + <span class="string">"] interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line">             <span class="comment">// 初始化类</span></span><br><span class="line">NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">             <span class="comment">// 调用自定义的 NamespaceHandler 的初始化方法</span></span><br><span class="line">namespaceHandler.init();</span><br><span class="line">             <span class="comment">// 记录在缓存</span></span><br><span class="line">handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line"><span class="keyword">return</span> namespaceHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line">namespaceUri + <span class="string">"] not found"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Invalid NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line">namespaceUri + <span class="string">"]: problem with handler class file or dependent class"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的调用<code>namespaceHandler.init();</code>中参考之前的自定义标签使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"user"</span>, <span class="keyword">new</span> UserBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当得到自定义命名空间处理后回马上进行 <code>BeanDefinitionParser</code> 的注册以支持自定义标签</p><p>注册后，命名空间处理器就可以根据标签的不同来调用不同的解析器进行解析。<code>getHandlerMappings</code> 主要功能就是读取 <code>Spring.handlers</code> 配置文件并将配置文件缓存在 map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the specified NamespaceHandler mappings lazily.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getHandlerMappings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果没有被缓存则开始进行缓存</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// this.handlerMappingsLocation 在构造函数中被初始化为 META-INF/Spring.handlers</span></span><br><span class="line">Properties mappings =</span><br><span class="line">PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.handlerMappingsLocation, <span class="keyword">this</span>.classLoader);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Loaded NamespaceHandler mappings: "</span> + mappings);</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Object&gt; handlerMappings = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(mappings.size());</span><br><span class="line">                     <span class="comment">// 将 Properties 格式文件合并到 Map 格式的 handlerMappings 中</span></span><br><span class="line">CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = handlerMappings;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Unable to load NamespaceHandler mappings from location ["</span> + <span class="keyword">this</span>.handlerMappingsLocation + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h4><p><code>NamespaceHandlerSupport#parse</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@link</span> Element&#125; by delegating to the &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; that is</span></span><br><span class="line"><span class="comment"> * registered for that &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 寻找解析器并进行解析操作</span></span><br><span class="line"><span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Locates the &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; from the register implementations using</span></span><br><span class="line"><span class="comment"> * the local name of the supplied &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取元素名称，也就是 &lt;myname:user&gt; 中的 user，若在上面的示例中，则此时 localName 为 user</span></span><br><span class="line">String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">     <span class="comment">// 根据 user 找到对应的解析器，也就是在 </span></span><br><span class="line">     <span class="comment">// registerBeanDefinitionParser("user", new UserBeanDefinitionParser()) 注册的解析器</span></span><br><span class="line">BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line"><span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">parserContext.getReaderContext().fatal(</span><br><span class="line"><span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 parse 方法的处理</p><p><code>AbstractBeanDefinitionParser#parse</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 真正的解析工作</span></span><br><span class="line">AbstractBeanDefinition definition = parseInternal(element, parserContext);</span><br><span class="line"><span class="keyword">if</span> (definition != <span class="keyword">null</span> &amp;&amp; !parserContext.isNested()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String id = resolveId(element, definition, parserContext);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(id)) &#123;</span><br><span class="line">parserContext.getReaderContext().error(</span><br><span class="line"><span class="string">"Id is required for element '"</span> + parserContext.getDelegate().getLocalName(element)</span><br><span class="line">+ <span class="string">"' when used as a top-level tag"</span>, element);</span><br><span class="line">&#125;</span><br><span class="line">String[] aliases = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (shouldParseNameAsAliases()) &#123;</span><br><span class="line">String name = element.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(name)) &#123;</span><br><span class="line">aliases = StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">             <span class="comment">// 将 AbstractBeanDefinition 转换为 BeanDefinitionHolder 并注册</span></span><br><span class="line">BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(definition, id, aliases);</span><br><span class="line">registerBeanDefinition(holder, parserContext.getRegistry());</span><br><span class="line"><span class="keyword">if</span> (shouldFireEvents()) &#123;</span><br><span class="line">                 <span class="comment">// 需要通知监听器则进行处理</span></span><br><span class="line">BeanComponentDefinition componentDefinition = <span class="keyword">new</span> BeanComponentDefinition(holder);</span><br><span class="line">postProcessComponentDefinition(componentDefinition);</span><br><span class="line">parserContext.registerComponent(componentDefinition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">parserContext.getReaderContext().error(ex.getMessage(), element);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractSingleBeanDefinitionParser#parseInternal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@link</span> BeanDefinitionBuilder&#125; instance for the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getBeanClass bean Class&#125; and passes it to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #doParse&#125; strategy method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element the element that is to be parsed into a single BeanDefinition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parserContext the object encapsulating the current state of the parsing process</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the BeanDefinition resulting from the parsing of the supplied &#123;<span class="doctag">@link</span> Element&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the bean &#123;<span class="doctag">@link</span> Class&#125; returned from</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getBeanClass(org.w3c.dom.Element)&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doParse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> AbstractBeanDefinition <span class="title">parseInternal</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line">String parentName = getParentName(element);</span><br><span class="line"><span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.getRawBeanDefinition().setParentName(parentName);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 获取自定义标签中的 class，此时会调用自定义解析器如 UserBeanDefinitionParser 中的 getBeanClass 方法</span></span><br><span class="line">Class&lt;?&gt; beanClass = getBeanClass(element);</span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.getRawBeanDefinition().setBeanClass(beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 若子类没有重写 getBeanClass 方法则尝试检查子类是否重写 getBeanClassName 方法</span></span><br><span class="line">String beanClassName = getBeanClassName(element);</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.getRawBeanDefinition().setBeanClassName(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));</span><br><span class="line"><span class="keyword">if</span> (parserContext.isNested()) &#123;</span><br><span class="line">         <span class="comment">// 若存在父类则使用父类的 scope 属性</span></span><br><span class="line"><span class="comment">// Inner bean definition must receive same scope as containing bean.</span></span><br><span class="line">builder.setScope(parserContext.getContainingBeanDefinition().getScope());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (parserContext.isDefaultLazyInit()) &#123;</span><br><span class="line"><span class="comment">// Default-lazy-init applies to custom bean definitions as well.</span></span><br><span class="line">         <span class="comment">// 配置延迟加载</span></span><br><span class="line">builder.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 调用子类重写的 doParse 方法进行解析</span></span><br><span class="line">doParse(element, parserContext, builder);</span><br><span class="line"><span class="keyword">return</span> builder.getBeanDefinition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">doParse(element, builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>《Spring源码深度解析》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 当前版本 Spring 4.3.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;自定义标签的解析&quot;&gt;&lt;a href=&quot;#自定义标签的解析&quot; class=&quot;headerlink&quot; title=&quot;自定义标签的解析&quot;&gt;&lt;/a&gt;自定义标签的解析&lt;/h2&gt;&lt;h3 id=&quot;自定义标签使用&quot;&gt;&lt;a href=&quot;#自定义标签使用&quot; class=&quot;headerlink&quot; title=&quot;自定义标签使用&quot;&gt;&lt;/a&gt;自定义标签使用&lt;/h3&gt;&lt;p&gt;在很多情况下，当使用默认配置过于繁琐时候，解析工作或许是一个不得不考虑的负担。Spring 提供了可扩展 Scheme 的支持。大概需要以下几个步骤：&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring-源码分析-bean的解析(2)</title>
    <link href="http://yoursite.com/2017/11/03/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-bean%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2017/11/03/Spring源码分析-bean的解析（2）/</id>
    <published>2017-11-03T08:58:14.000Z</published>
    <updated>2017-11-22T16:09:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 当前版本 Spring 4.3.8</p></blockquote><h2 id="默认标签的解析"><a href="#默认标签的解析" class="headerlink" title="默认标签的解析"></a>默认标签的解析</h2><p>接上 <code>parseDefaultElement(ele, delegate);</code></p><a id="more"></a><p><code>DefaultBeanDefinitionDocumentReader#parseDefaultElement</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// import 标签解析</span></span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 解析 alias 标签 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// bean 的解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// beans 的解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean-标签的解析及注册"><a href="#Bean-标签的解析及注册" class="headerlink" title="Bean 标签的解析及注册"></a>Bean 标签的解析及注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);  <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder)); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先委托 <code>BeanDefinitionDelegate</code> 类的 <code>parseBeanDefinitionElement</code> 方法进行元素解析，返回 <code>BeanDefinitionHolder</code> 类型的实例 <code>bdHolder</code>，经过这个方法后， <code>bdHolder</code> 实例已经包含我们的配置文件中配置的各个属性了，例如 <code>class、name、id、alias</code> 之类的属性。</li><li>当返回的 <code>bdHolder</code> 不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析。</li><li>解析完成之后，需要对解析后的 <code>bdHolder</code> 进行注册，同样，注册操作委托给了 <code>BeanDefinitionReaderUtils</code> 的 <code>registerBeanDefinition</code> 方法。</li><li>最后发出响应事件，通知想关的监听器，这个 <code>bean</code> 已经加载完成了</li></ol><h4 id="解析-BeanDefinition"><a href="#解析-BeanDefinition" class="headerlink" title="解析 BeanDefinition"></a>解析 BeanDefinition</h4><p><code>BeanDefinitionDelegate#parseBeanDefinitionElement</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@code</span> &lt;bean&gt;&#125; element. May return &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * if there were errors during parse. Errors are reported to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ProblemReporter&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@code</span> &lt;bean&gt;&#125; element. May return &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * if there were errors during parse. Errors are reported to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ProblemReporter&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 解析 id 属性</span></span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">        <span class="comment">// 解析 name 属性</span></span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 分割 name 属性</span></span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line"><span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123; <span class="comment">// 3</span></span><br><span class="line">                 <span class="comment">// 如果不存在 beanName 那么根据 Spring 中提供的命名规则为当前 bean 生成对应的 beanName</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line"><span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line"><span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line"><span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>提取元素中的 id 以及 name 属性</li><li>进一步解析其他所有属性并统一封装至 <code>GenericBeanDefinition</code> 类型的实例中（下面的函数）</li><li>如果检测到 bean 没有指定 beanName ，那么使用默认规则为此 Bean 生成 beanName</li><li>将获取到的信息封装到 BeanDefinitionHolder 的实例中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*parseBeanDefinitionElement*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the bean definition itself, without regard to name or aliases. May return</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; if problems occurred during the parsing of the bean definition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String parent = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 解析parent 属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line">          <span class="comment">// 创建用于承载属性的 AbstractBeanDefinition 类型的 GenericBeanDefinition</span></span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 硬编码解析默认 bean 的各种属性</span></span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">          <span class="comment">// 提取description</span></span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 解析元数据</span></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">          <span class="comment">// 解析 lookup-override 属性</span></span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">          <span class="comment">// 解析 replaced-method 属性</span></span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 解析构造函数参数</span></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">          <span class="comment">// 解析 property 子元素</span></span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">          <span class="comment">// 解析 qualifier 子元素</span></span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来来看看一些复杂标签的解析:</p><h5 id="创建用于属性承载的-BeanDefinition"><a href="#创建用于属性承载的-BeanDefinition" class="headerlink" title="创建用于属性承载的 BeanDefinition"></a>创建用于属性承载的 BeanDefinition</h5><p><code>BeanDefinition</code> 是一个接口，在 Spring 中存在三种实现，三种实现均继承了 <code>AbstactBeanDefinition</code>，其中 <code>BeanDefinition</code> 是配置文件中的 <code>&lt;bean&gt;</code> 元素标签在容器中的内部表示形式。<code>&lt;bean&gt;</code>元素标签拥有 <code>class、scope、lazy-init</code> 等配置属性。<code>BeanDefinition</code>则提供了相应的 <code>beanClass、scope、lazyInit</code>属性，<code>BeanDefinition</code> 和 <code>&lt;bean&gt;</code> 中的属性是一一对应的。</p><ul><li><p><code>RootBeanDefinition</code> 最常用的实现类，它对应一般性的 <code>&lt;bean&gt;</code> 元素标签</p><p>当前版本中， <code>ConfigurationClassBeanDefinition</code> 继承与此类</p></li><li><p><code>ChildBeanDefinition</code> 配置文件中的子 <code>&lt;bean&gt;</code></p></li><li><p><code>GenericBeanDefinition</code> 2.5 新加入的 <code>bean</code> 文件配置属性定义类，是一站式服务类。</p><p>在当前版本中，有<code>ScannedGenericBeanDefinition</code>，<code>AnnotatedGenericBeanDefinition</code> 继承与此类</p></li></ul><p>Spring 通过 <code>BeanDefinition</code> 将配置文件中的 <code>&lt;bean&gt;</code> 配置信息转换为容器的内部表示，并将这些 <code>BeanDefinition</code> 注册到 <code>BeanDefinitionRegistry</code> 中。Spring 容器的 <code>BeanDefinitionRegistry</code> 就像是 Spring 配置信息的内存数据库，主要是以 map 的形式保存的，后续操作直接从 <code>BeanDefinitionRegistry</code> 中读取配置信息。</p><p><code>BeanDefinitionParserDelegate#createBeanDefinition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a bean definition for the given class name and parent name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className the name of the bean class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentName the name of the bean's parent bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException if bean class resolution was attempted but failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(String className, String parentName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">parentName, className, <span class="keyword">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new GenericBeanDefinition for the given parent name and class name,</span></span><br><span class="line"><span class="comment"> * eagerly loading the bean class if a ClassLoader has been specified.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentName the name of the parent bean, if any</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className the name of the bean class, if any</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading bean classes</span></span><br><span class="line"><span class="comment"> * (can be &#123;<span class="doctag">@code</span> null&#125; to just register bean classes by name)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException if the bean class could not be loaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String parentName, String className, ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">       <span class="comment">// parentName 可能为空</span></span><br><span class="line">bd.setParentName(parentName);</span><br><span class="line"><span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果 classLoader 不为空，则使用已传入的 classLoader 同一虚拟机加载类对象，否则只是记录 className</span></span><br><span class="line">bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">bd.setBeanClassName(className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析各种属性"><a href="#解析各种属性" class="headerlink" title="解析各种属性"></a>解析各种属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply the attributes of the given bean element to the given bean * definition.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ele bean declaration element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName bean name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containingBean containing bean definition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a bean definition initialized according to the bean element attributes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionAttributes</span><span class="params">(Element ele, String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinition containingBean, AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 singleton 属性。已废弃，使用 scope 设置</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">error(<span class="string">"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 解析 scope 属性</span></span><br><span class="line">     <span class="comment">// https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/core.html#beans-factory-scopes</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Take default from containing bean in case of an inner bean definition.</span></span><br><span class="line">         <span class="comment">// 在嵌入 beanDefinition 情况下且没有单独指定 scope 属性则使用父类默认的属性</span></span><br><span class="line">bd.setScope(containingBean.getScope());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 absract 属性</span></span><br><span class="line">     <span class="comment">// (抽象bean不能被实例化，只能被子类继承)。</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 lazy-init 属性</span></span><br><span class="line">       <span class="comment">// 懒初始化，默认false ，即：非懒惰初始化。这是高效的，可以提前暴露错误（如果存在），如果是懒初始化，只有在call 时才初始化。</span></span><br><span class="line">String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (DEFAULT_VALUE.equals(lazyInit)) &#123;</span><br><span class="line">lazyInit = <span class="keyword">this</span>.defaults.getLazyInit();</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 若没有设置或设置成其他字符都会被设置为 false</span></span><br><span class="line">bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 autowire 属性</span></span><br><span class="line">String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 dependency-check 属性</span></span><br><span class="line">String dependencyCheck = ele.getAttribute(DEPENDENCY_CHECK_ATTRIBUTE);</span><br><span class="line">bd.setDependencyCheck(getDependencyCheck(dependencyCheck));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 depends-on 属性</span></span><br><span class="line">     <span class="comment">// 初始化该bean之前必须先初始化谁（name or id 指定）</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 autowire-candidate 属性</span></span><br><span class="line">String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">""</span>.equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) &#123;</span><br><span class="line">String candidatePattern = <span class="keyword">this</span>.defaults.getAutowireCandidates();</span><br><span class="line"><span class="keyword">if</span> (candidatePattern != <span class="keyword">null</span>) &#123;</span><br><span class="line">String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 primary 属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 init-method 属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">""</span>.equals(initMethodName)) &#123;</span><br><span class="line">bd.setInitMethodName(initMethodName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaults.getInitMethod() != <span class="keyword">null</span>) &#123;</span><br><span class="line">bd.setInitMethodName(<span class="keyword">this</span>.defaults.getInitMethod());</span><br><span class="line">bd.setEnforceInitMethod(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 destory-method 属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaults.getDestroyMethod() != <span class="keyword">null</span>) &#123;</span><br><span class="line">bd.setDestroyMethodName(<span class="keyword">this</span>.defaults.getDestroyMethod());</span><br><span class="line">bd.setEnforceDestroyMethod(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 factory-method 属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 解析 factory-bean 属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 简单复习一下 bean 的自动装配 @Autowired （如果设置参数 require = false 则会尝试匹配，无匹配这让 bean 处于未装配状态）</p><ol><li>primary（如果配置了的）</li><li>@Qualifier 做限定<ol><li>配合 @Autowired 使用指定需要装配哪个 bean</li><li>配合 @Component / @Bean 指定限定符，不然在 @Autowired 使用的时候就是默认 beanId</li></ol></li><li>符合的类型</li></ol></blockquote><h5 id="解析子元素-meta"><a href="#解析子元素-meta" class="headerlink" title="解析子元素 meta"></a>解析子元素 meta</h5><p>meta: 元数据，当需要使用里面的信息时可以通过key获取</p><blockquote><p> Finally, the bean definitions should contain matching qualifier values. This example also demonstrates that bean <em>meta</em> attributes may be used instead of the <code>&lt;qualifier/&gt;</code> sub-elements.If available, the <code>&lt;qualifier/&gt;</code> and its attributes would take precedence, but the autowiring mechanism will fallback on the values provided within the <code>&lt;meta/&gt;</code> tags if no such qualifier is present</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTestBean"</span> <span class="attr">class</span>=<span class="string">"bean.MyTestBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"testStr"</span> <span class="attr">value</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMetaElements</span><span class="params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取当前节点的所有子元素</span></span><br><span class="line">NodeList nl = ele.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line">         <span class="comment">// 提取 meta</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">Element metaElement = (Element) node;</span><br><span class="line">String key = metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">String value = metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(key, value);</span><br><span class="line">attribute.setSource(extractSource(metaElement));</span><br><span class="line">attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析子元素-lookup-method"><a href="#解析子元素-lookup-method" class="headerlink" title="解析子元素 lookup-method"></a>解析子元素 lookup-method</h5><p>获取器注入，特殊方法注入，它是把一个方法声明为返回某种类型的 <code>bean</code>， 但实际要返回的 <code>bean</code> 是在配置文件里面配置的，此方法可用在设计有些可插拔的功能上，解除程序依赖。</p><p>简单来说就是，可以动态配置某个方法的返回值返回的 <code>bean</code></p><p><code>... &lt;lookup-method name=&quot;方法名&quot; bean=&quot;需要方法返回的 beanId&quot;&gt; ...</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse lookup-override sub-elements of the given bean element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseLookupOverrideSubElements</span><span class="params">(Element beanEle, MethodOverrides overrides)</span> </span>&#123;</span><br><span class="line">NodeList nl = beanEle.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line">         <span class="comment">// 仅当在 Spring 默认 bean 的子元素且为 &lt;lookup-method 时有效</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line">             <span class="comment">// 获取要修饰的方法</span></span><br><span class="line">String methodName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">             <span class="comment">// 获取配置返回的 bean</span></span><br><span class="line">String beanRef = ele.getAttribute(BEAN_ELEMENT);</span><br><span class="line">LookupOverride override = <span class="keyword">new</span> LookupOverride(methodName, beanRef);</span><br><span class="line">override.setSource(extractSource(ele));</span><br><span class="line">overrides.addOverride(override);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析子元素-replaced-method"><a href="#解析子元素-replaced-method" class="headerlink" title="解析子元素 replaced-method"></a>解析子元素 replaced-method</h5><p>方法替换：可以在运行时用新的方法替换现有的方法。与之前的 <code>look-up</code> 不同的是，<code>replaced-method</code> 不但可以动态地替换返回实体 <code>bean</code>，而且还能动态地更改原有方法的逻辑。</p><p>需要实现 <code>MethodReplacer</code> 的 <code>reimplement</code> 方法，该方法替换其指定方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse replaced-method sub-elements of the given bean element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseReplacedMethodSubElements</span><span class="params">(Element beanEle, MethodOverrides overrides)</span> </span>&#123;</span><br><span class="line">NodeList nl = beanEle.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line">         <span class="comment">// 识别标签</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) &#123;</span><br><span class="line">Element replacedMethodEle = (Element) node;</span><br><span class="line">             <span class="comment">// 提取需要替换方法</span></span><br><span class="line">String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">             <span class="comment">// 提权对应的新的替换方法</span></span><br><span class="line">String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);</span><br><span class="line">ReplaceOverride replaceOverride = <span class="keyword">new</span> ReplaceOverride(name, callback);</span><br><span class="line"><span class="comment">// Look for arg-type match elements.</span></span><br><span class="line">List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);</span><br><span class="line"><span class="keyword">for</span> (Element argTypeEle : argTypeEles) &#123;</span><br><span class="line">                 <span class="comment">// 记录参数</span></span><br><span class="line">String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);</span><br><span class="line">match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(match)) &#123;</span><br><span class="line">replaceOverride.addTypeIdentifier(match);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">replaceOverride.setSource(extractSource(replacedMethodEle));</span><br><span class="line">overrides.addOverride(replaceOverride);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析子元素-constructor-arg"><a href="#解析子元素-constructor-arg" class="headerlink" title="解析子元素 constructor-arg"></a>解析子元素 constructor-arg</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a constructor-arg element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 提取对应元素</span></span><br><span class="line">String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> index = Integer.parseInt(indexAttr);</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">error(<span class="string">"'index' cannot be lower than 0"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry(index));</span><br><span class="line">                     <span class="comment">// 解析 ele 对应的属性元素</span></span><br><span class="line">Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 使用 ConstructorArgumentValues.ValueHolder 类型封装解析出来的元素</span></span><br><span class="line">ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">valueHolder.setType(typeAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">valueHolder.setName(nameAttr);</span><br><span class="line">&#125;</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line">                     <span class="comment">// 不允许重复指定相同的参数</span></span><br><span class="line"><span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">error(<span class="string">"Ambiguous constructor-arg entries for index "</span> + index, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="comment">// 将封装的信息添加到当前 BeanDefinition 的 constructorArgumentValues 中的 indexedArgumentValue 属性中</span></span><br><span class="line">bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">error(<span class="string">"Attribute 'index' of tag 'constructor-arg' must be an integer"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 没有 index 属性则忽略去属性，自动寻找</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry());</span><br><span class="line">             <span class="comment">// 解析 constructor-arg 元素</span></span><br><span class="line">Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">valueHolder.setType(typeAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">valueHolder.setName(nameAttr);</span><br><span class="line">&#125;</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line">bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析构造函数配置中子元素的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the value of a property element. May be a list etc.</span></span><br><span class="line"><span class="comment"> * Also used for constructor arguments, "propertyName" being null in this case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, String propertyName)</span> </span>&#123;</span><br><span class="line">String elementName = (propertyName != <span class="keyword">null</span>) ?</span><br><span class="line"><span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"'"</span> :</span><br><span class="line"><span class="string">"&lt;constructor-arg&gt; element"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Should only have one child element: ref, value, list, etc.</span></span><br><span class="line">     <span class="comment">// 一个属性只能对应一种类型：ref、value、list等</span></span><br><span class="line">NodeList nl = ele.getChildNodes();</span><br><span class="line">Element subElement = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line">         <span class="comment">// 对应 description 或者 meta 不处理</span></span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">!nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// Child element is what we're looking for.</span></span><br><span class="line"><span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">error(elementName + <span class="string">" must not contain more than one sub-element"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">subElement = (Element) node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析 constructor-arg 上的 ref 属性</span></span><br><span class="line"><span class="keyword">boolean</span> hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">     <span class="comment">// 解析 constructor-arg 上的 value 属性</span></span><br><span class="line"><span class="keyword">boolean</span> hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="keyword">null</span>)) &#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         在 constructor-arg 上不存在：</span></span><br><span class="line"><span class="comment">         1. 同时既有 ref 属性又有 value 属性</span></span><br><span class="line"><span class="comment">         2. 存在 ref 属性或者 value 属性且又有子元素</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">error(elementName +</span><br><span class="line"><span class="string">" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">         <span class="comment">// ref 属性的处理，使用 RuntimeBeanRefence 封装对应的 ref 名称</span></span><br><span class="line">String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">error(elementName + <span class="string">" contains empty 'ref' attribute"</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line">RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">ref.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line">         <span class="comment">// value 属性的处理，使用 TypedStringValue 封装</span></span><br><span class="line">TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> valueHolder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 解析子元素</span></span><br><span class="line"><span class="keyword">return</span> parsePropertySubElement(subElement, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Neither child element nor "ref" or "value" attribute found.</span></span><br><span class="line">         <span class="comment">// 即没有 ref 也没有 value 也没有子元素，报错</span></span><br><span class="line">error(elementName + <span class="string">" must specify a ref or value"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓子元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"value"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parsePropertySubElement(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a value, ref or collection sub-element of a property or</span></span><br><span class="line"><span class="comment"> * constructor-arg element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ele subelement of property element; we don't know which yet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValueType the default type (class name) for any</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> &lt;value&gt;&#125; tag that might be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, BeanDefinition bd, String defaultValueType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseNestedCustomElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</span><br><span class="line"><span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) &#123;</span><br><span class="line">nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nestedBd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// A generic reference to any name of any bean.</span></span><br><span class="line">String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line"><span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">              <span class="comment">// 解析 local</span></span><br><span class="line"><span class="comment">// A reference to the id of another bean in the same XML file.</span></span><br><span class="line">refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">                 <span class="comment">// 解析 parent</span></span><br><span class="line"><span class="comment">// A reference to the id of another bean in a parent context.</span></span><br><span class="line">refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">toParent = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">error(<span class="string">"'bean', 'local' or 'parent' is required for &lt;ref&gt; element"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">error(<span class="string">"&lt;ref&gt; element contains empty target attribute"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);</span><br><span class="line">ref.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 对 idref 元素的解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseIdRefElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 对 value 子元素的解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseValueElement(ele, defaultValueType);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 对 null 子元素的解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// It's a distinguished null value. Let's wrap it in a TypedStringValue</span></span><br><span class="line"><span class="comment">// object in order to preserve the source location.</span></span><br><span class="line">TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);</span><br><span class="line">nullHolder.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> nullHolder;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 解析 array 子元素</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseArrayElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 解析 list 子元素 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseListElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 解析 set 子元素</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseSetElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 解析 map 子元素</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseMapElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 解析 parse 子元素</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line"><span class="keyword">return</span> parsePropsElement(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">error(<span class="string">"Unknown property sub-element: ["</span> + ele.getNodeName() + <span class="string">"]"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析子元素-property"><a href="#解析子元素-property" class="headerlink" title="解析子元素 property"></a>解析子元素 property</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse property sub-elements of the given bean element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">NodeList nl = beanEle.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">parsePropertyElement((Element) node, bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a property element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取配置元素中 name 的值</span></span><br><span class="line">String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">error(<span class="string">"Tag 'property' must have a 'name' attribute"</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PropertyEntry(propertyName));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 不允许多次对同一属性配置</span></span><br><span class="line"><span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">error(<span class="string">"Multiple 'property' definitions for property '"</span> + propertyName + <span class="string">"'"</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object val = parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">PropertyValue pv = <span class="keyword">new</span> PropertyValue(propertyName, val);</span><br><span class="line">parseMetaElements(ele, pv);</span><br><span class="line">pv.setSource(extractSource(ele));</span><br><span class="line">bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析子元素-qualifier"><a href="#解析子元素-qualifier" class="headerlink" title="解析子元素 qualifier"></a>解析子元素 qualifier</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse qualifier sub-elements of the given bean element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseQualifierElements</span><span class="params">(Element beanEle, AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class="line">NodeList nl = beanEle.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) &#123;</span><br><span class="line">parseQualifierElement((Element) node, bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a qualifier element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseQualifierElement</span><span class="params">(Element ele, AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class="line">String typeName = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(typeName)) &#123;</span><br><span class="line">error(<span class="string">"Tag 'qualifier' must have a 'type' attribute"</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> QualifierEntry(typeName));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AutowireCandidateQualifier qualifier = <span class="keyword">new</span> AutowireCandidateQualifier(typeName);</span><br><span class="line">qualifier.setSource(extractSource(ele));</span><br><span class="line">String value = ele.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(value)) &#123;</span><br><span class="line">qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);</span><br><span class="line">&#125;</span><br><span class="line">NodeList nl = ele.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) &#123;</span><br><span class="line">Element attributeEle = (Element) node;</span><br><span class="line">String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) &#123;</span><br><span class="line">BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(attributeName, attributeValue);</span><br><span class="line">attribute.setSource(extractSource(attributeEle));</span><br><span class="line">qualifier.addMetadataAttribute(attribute);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">error(<span class="string">"Qualifier 'attribute' tag must have a 'name' and 'value'"</span>, attributeEle);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bd.addQualifier(qualifier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractBeanDefinition-属性"><a href="#AbstractBeanDefinition-属性" class="headerlink" title="AbstractBeanDefinition 属性"></a>AbstractBeanDefinition 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanDefinition</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object beanClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean 的作用范围，对应 bean 属性 scope</span></span><br><span class="line"><span class="keyword">private</span> String scope = SCOPE_DEFAULT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是抽象，对应 abstract</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> abstractFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否延迟加载，对应 lazy-init</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> lazyInit = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动注入模式，对应 autowire</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> autowireMode = AUTOWIRE_NO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖检查， 3.0 弃用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> dependencyCheck = DEPENDENCY_CHECK_NONE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来表示一个 bean 的实例化依靠另一个 bean 先实例化，对应 depend-on</span></span><br><span class="line"><span class="keyword">private</span> String[] dependsOn;</span><br><span class="line"></span><br><span class="line"><span class="comment">// autowire-candidate 属性设置为 false，这样容器在查找自动装配对象时，</span></span><br><span class="line"><span class="comment">// 将不考虑该 bean，即它不会被考虑作为其他 bean 自动装配的候选者，但是该 bean 本身还是可以</span></span><br><span class="line"><span class="comment">// 使用自动装配来注入其他 bean 的。</span></span><br><span class="line"><span class="comment">// 对应 bean 属性 autowire-candidate</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> autowireCandidate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动装配时当出现多个 bean 候选者时，将作为首选者，对应 primary</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> primary = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于记录 Qualifier，对应子元素 qualifier</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, AutowireCandidateQualifier&gt; qualifiers =</span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;String, AutowireCandidateQualifier&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许访问非公开的构造器和方法，程序设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> nonPublicAccessAllowed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">是否以一种宽松模式解析构造函数，默认为 true</span></span><br><span class="line"><span class="comment">如果为 false，则在如下情况</span></span><br><span class="line"><span class="comment">interface ITest&#123;&#125;</span></span><br><span class="line"><span class="comment">class ITestImpl implements ITest&#123;&#125;;</span></span><br><span class="line"><span class="comment">class Main&#123;</span></span><br><span class="line"><span class="comment">      Main(ITest i) &#123;&#125;</span></span><br><span class="line"><span class="comment">      Main(ITestImpl i) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">抛出异常，因为 Spring 无法准确定位哪个构造函数</span></span><br><span class="line"><span class="comment">程序设置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> lenientConstructorResolution = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">对应 bean 属性 factory-bean</span></span><br><span class="line"><span class="comment">&lt;bean id="instanceFactoryBean" class="xxx"/&gt;</span></span><br><span class="line"><span class="comment">&lt;bean id="currentTime" factory-bean="instanceFactoryBean" factory-method="createTime"/&gt;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> String factoryBeanName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 factory-method</span></span><br><span class="line"><span class="keyword">private</span> String factoryMethodName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录构造函数注入属性，对于 constructor-arg</span></span><br><span class="line"><span class="keyword">private</span> ConstructorArgumentValues constructorArgumentValues;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通属性集合</span></span><br><span class="line"><span class="keyword">private</span> MutablePropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法重写的持有者，记录 lookup-method、replaced-method 元素</span></span><br><span class="line"><span class="keyword">private</span> MethodOverrides methodOverrides = <span class="keyword">new</span> MethodOverrides();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方法，对应 init-method</span></span><br><span class="line"><span class="keyword">private</span> String initMethodName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁方法，对应 destory-method</span></span><br><span class="line"><span class="keyword">private</span> String destroyMethodName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否执行 init-method，程序设定</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enforceInitMethod = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否执行 destory-method，程序设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enforceDestroyMethod = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是用户定义的而不是应用程序本身定义的，创建 AOP 时候为 true，程序设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> synthetic = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">定义这个 bean 的应用</span></span><br><span class="line"><span class="comment">APPLICATION: 用户</span></span><br><span class="line"><span class="comment">INFRASTRUCTURE：完全内部使用，与用户无光</span></span><br><span class="line"><span class="comment">SUPPORT: 某些复杂配置的一部分</span></span><br><span class="line"><span class="comment">程序设置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> role = BeanDefinition.ROLE_APPLICATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean 的描述信息</span></span><br><span class="line"><span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 bean 定义的资源</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br><span class="line"><span class="comment">// ...各种 set/get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析默认表情中的自定义标签元素"><a href="#解析默认表情中的自定义标签元素" class="headerlink" title="解析默认表情中的自定义标签元素"></a>解析默认表情中的自定义标签元素</h4><p>之前的解析标签起始函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);  <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder)); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来介绍 2 <code>bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</code></p><p>适用场景：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"test.MyClass"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mybean:user</span> <span class="attr">username</span>=<span class="string">"aaa"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(Element ele, BeanDefinitionHolder definitionHolder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> decorateBeanDefinitionIfRequired(ele, definitionHolder, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// containingBd 为父类的 bean，为了使用父类的 scope 属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Element ele, BeanDefinitionHolder definitionHolder, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder finalDefinition = definitionHolder;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorate based on custom attributes first.</span></span><br><span class="line">NamedNodeMap attributes = ele.getAttributes();</span><br><span class="line">     <span class="comment">// 遍历所有的属性，看看是否有适用于修饰的属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">Node node = attributes.item(i);</span><br><span class="line">finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorate based on custom nested elements.</span></span><br><span class="line">NodeList children = ele.getChildNodes();</span><br><span class="line">     <span class="comment">// 遍历所有的子节点，看看是否有使用于修饰的子元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">Node node = children.item(i);</span><br><span class="line"><span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> finalDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateIfRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取自定义标签的命名空间</span></span><br><span class="line">String namespaceUri = getNamespaceURI(node);</span><br><span class="line">     <span class="comment">// 对于非默认标签进行修饰</span></span><br><span class="line"><span class="keyword">if</span> (!isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">         <span class="comment">// 根据命名空间找到对应的处理器</span></span><br><span class="line">NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 进行修饰</span></span><br><span class="line"><span class="keyword">return</span> handler.decorate(node, originalDef, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (namespaceUri != <span class="keyword">null</span> &amp;&amp; namespaceUri.startsWith(<span class="string">"http://www.springframework.org/"</span>)) &#123;</span><br><span class="line">error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// A custom namespace, not to be handled by Spring - maybe "xml:...".</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No Spring NamespaceHandler found for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> originalDef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册解析的-BeanDefinition"><a href="#注册解析的-BeanDefinition" class="headerlink" title="注册解析的 BeanDefinition"></a>注册解析的 BeanDefinition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given bean definition with the given bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definitionHolder the bean definition including name and aliases</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the bean factory to register with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException if registration failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">     <span class="comment">// 使用 beanName 做唯一标识注册</span></span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">     <span class="comment">// 注册所有的别名</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过-beanName-注册-BeanDefinition"><a href="#通过-beanName-注册-BeanDefinition" class="headerlink" title="通过 beanName 注册 BeanDefinition"></a>通过 beanName 注册 BeanDefinition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">             注册前的最后一次校验，这里的校验不同于之前的 XML 文件校验，</span></span><br><span class="line"><span class="comment">             主要是对于 AbstractBeanDefinition 属性中的 methodOverrides 校验，</span></span><br><span class="line"><span class="comment">             校验 methodOverrides 是否与工厂方法并存或者 methodOverrides 对应的方法根本不存在</span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"><span class="comment">// 这个 beanDefinitionMap 是 ConcurrentHashMap，考虑并发</span></span><br><span class="line">oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果对应的 BeanName 已经注册且在配置中配置了 bean 不允许被覆盖，则抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a different definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with an equivalent definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">// 注册 beanDefinition</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 不属于 AbstractBeanDefinition 了</span></span><br><span class="line">     <span class="comment">// 疑问，什么不属于 AbstactBeanDefinition 的 BeanDefinition 的实现？</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">             <span class="comment">// 这里为什么还需要锁？</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line">                 <span class="comment">// 这里需要锁！</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">             <span class="comment">// 记录 beanName</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 清楚解析之前留下的对应 beanName 的缓存</span></span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对 <code>AbstractBeanDefinition</code> 的校验。在解析 XML 文件的时候我们提过校验，但是此校验非彼校验，之前的校验时针对于 XML 格式的校验，而此时的校验时针是对于 <code>AbstractBeanDefinition</code> 的 <code>methodOverrides</code> 属性的。</li><li>对 <code>beanName</code> 已经注册的情况的处理。如果设置了不允许 <code>bean</code> 的覆盖，则需要抛出异常，否则直接覆盖</li><li>加入 map 缓存</li><li>清除解析之前留下的对应 <code>beanName</code> 的缓存</li></ol><h5 id="通过别名注册-BeanDefinition"><a href="#通过别名注册-BeanDefinition" class="headerlink" title="通过别名注册 BeanDefinition"></a>通过别名注册 BeanDefinition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">     <span class="comment">// 如果 beanName 与 alias 相同的话不记录 alias，并删除对应的 alias</span></span><br><span class="line"><span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line"><span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line"><span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line"><span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">             <span class="comment">// 如果 alias 不允许被覆盖则抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot register alias '"</span> + alias + <span class="string">"' for name '"</span> +</span><br><span class="line">name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">// 当 A-&gt;B 存在时，若再次出现 A-&gt;C-&gt;B 时候则会抛出异常</span></span><br><span class="line">checkForAliasCircle(name, alias);</span><br><span class="line"><span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>alias</code> 与 <code>beanName</code> 相同情况处理。若 <code>alias</code> 与 <code>beanName</code> 并名称相同则不需要处理并删除掉原有 <code>alias</code>。</li><li><code>alias</code> 覆盖处理。若 <code>aliasName</code> 已经使用并已经指向了另一 <code>beanName</code> 则需要用户的设置进行处理。</li><li><code>alias</code> 循环检查。当 A-&gt;B 存在时，若再次出现 A-&gt;C-&gt;B 时候则会抛出异常。</li><li>注册 <code>alias</code>。</li></ol><h4 id="通知监听器解析及注册完成"><a href="#通知监听器解析及注册完成" class="headerlink" title="通知监听器解析及注册完成"></a>通知监听器解析及注册完成</h4><p><code>// 扩展</code></p><h3 id="alias-标签的解析"><a href="#alias-标签的解析" class="headerlink" title="alias 标签的解析"></a>alias 标签的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given alias element, registering the alias with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取 beanName</span></span><br><span class="line">String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">     <span class="comment">// 获取 alias</span></span><br><span class="line">String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line"><span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Name must not be empty"</span>, ele);</span><br><span class="line">valid = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Alias must not be empty"</span>, ele);</span><br><span class="line">valid = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (valid) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 注册 alias</span></span><br><span class="line">getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to register alias '"</span> + alias +</span><br><span class="line"><span class="string">"' for bean with name '"</span> + name + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">// 别名注册后通知监听器做相应处理</span></span><br><span class="line">getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="import-标签的解析"><a href="#import-标签的解析" class="headerlink" title="import 标签的解析"></a>import 标签的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse an "import" element and load the bean definitions</span></span><br><span class="line"><span class="comment"> * from the given resource into the bean factory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取 resource 属性</span></span><br><span class="line">String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">     <span class="comment">// 如果不存在 resource 属性则不做任何处理</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Resource location must not be empty"</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resolve system properties: e.g. "$&#123;user.dir&#125;"</span></span><br><span class="line">     <span class="comment">// 解析系统属性，格式如："$&#123;user.dir&#125;"</span></span><br><span class="line">location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Discover whether the location is an absolute or relative URI</span></span><br><span class="line">     <span class="comment">// 判定 location 是决定 URI 还是相对 RUI</span></span><br><span class="line"><span class="keyword">boolean</span> absoluteLocation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line"><span class="comment">// cannot convert to an URI, considering the location relative</span></span><br><span class="line"><span class="comment">// unless it is the well-known Spring prefix "classpath*:"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Absolute or relative?</span></span><br><span class="line"><span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from URL location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(</span><br><span class="line"><span class="string">"Failed to import bean definitions from URL location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; considering resource location as relative to the current file.</span></span><br><span class="line">         <span class="comment">// 如果是相对地址则根据相对地址计算出绝对地址</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> importCount;</span><br><span class="line">             <span class="comment">// Resource 存在多个子实现类，如 VfsResource，FileSystemResource 等,</span></span><br><span class="line">             <span class="comment">// 而每个 resource 的 createRelative 方式实现都不一样，所以这里先使用子类的方法尝试解析</span></span><br><span class="line">Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line"><span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">actualResources.add(relativeResource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 如果解析不成功，则使用默认的解析器 ResourcePatternResolver 进行解析</span></span><br><span class="line">String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from relative location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to resolve current resource location"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to import bean definitions from relative location ["</span> + location + <span class="string">"]"</span>,</span><br><span class="line">ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment">// 解析后进行监听器激活处理</span></span><br><span class="line">Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[actualResources.size()]);</span><br><span class="line">getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取 resource 属性所表示的路径</li><li>解析路径中的系统属性，格式如 “${user.dir}”</li><li>判定 location 是绝对路径还是相对路径</li><li>如果是绝对路径则递归调用 bean 的解析过程，进行另一次的解析</li><li>如果是相对路径则计算出绝对路径并进行解析</li><li>通知监听器，解析完成</li></ol><h3 id="嵌入式-beans-标签的解析"><a href="#嵌入式-beans-标签的解析" class="headerlink" title="嵌入式 beans 标签的解析"></a>嵌入式 beans 标签的解析</h3><p>递归调用解析 <code>bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line"><span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>《Spring源码深度解析》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 当前版本 Spring 4.3.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;默认标签的解析&quot;&gt;&lt;a href=&quot;#默认标签的解析&quot; class=&quot;headerlink&quot; title=&quot;默认标签的解析&quot;&gt;&lt;/a&gt;默认标签的解析&lt;/h2&gt;&lt;p&gt;接上 &lt;code&gt;parseDefaultElement(ele, delegate);&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 技巧—懒加载</title>
    <link href="http://yoursite.com/2017/10/28/Java-%E6%8A%80%E5%B7%A7%E2%80%94%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2017/10/28/Java-技巧—懒加载/</id>
    <published>2017-10-28T08:56:33.000Z</published>
    <updated>2018-01-29T16:24:20.523Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述: 懒加载大对象 Heavy</span></span><br><span class="line"><span class="comment"> * 利用类加载机制达到 LazyLoad 为单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyLoad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyLoad INSTANCE = <span class="keyword">new</span> LazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyLoad <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;Heavy&gt; heavy = <span class="keyword">this</span>::createAndCacheHeavy;</span><br><span class="line">    <span class="keyword">private</span> Normal normal = <span class="keyword">new</span> Normal();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Heavy <span class="title">getHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heavy.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Normal <span class="title">getNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Heavy <span class="title">createAndCacheHeavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">HeavyFactory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Heavy</span>&gt; </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Heavy heavyInstance = <span class="keyword">new</span> Heavy();</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Heavy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> heavyInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!HeavyFactory.class.isInstance(heavy)) &#123;</span><br><span class="line">            heavy = <span class="keyword">new</span> HeavyFactory();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heavy.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LazyLoad.getInstance().getNormal();</span><br><span class="line">        LazyLoad.getInstance().getHeavy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heavy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heavy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating Heavy ..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"... Heavy created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Normal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating Normal ..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"... Normal created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring-源码分析-bean的解析(1)</title>
    <link href="http://yoursite.com/2017/10/25/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-bean%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2017/10/25/Spring源码分析-bean的解析（1）/</id>
    <published>2017-10-25T08:57:19.000Z</published>
    <updated>2017-11-22T16:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 当前版本 Spring 4.3.8</p></blockquote><p>我们一开始需要先定义一个 <code>Bean</code> 和一个 <code>xml</code></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bean</span></span><br><span class="line"><span class="keyword">package</span> io.github.binglau.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">// 简化 setter/getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String testStr = <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- beanFactory.xml --&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"io.github.binglau.bean.TestBean"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候我们大多数是这么来启动 IoC 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.binglau.bean.TestBean;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:beanFactory.xml"</span>);</span><br><span class="line">        TestBean testBean = (TestBean) context.getBean(<span class="string">"testBean"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"test bean: %s"</span>, testBean.getTestStr());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们来看看 <code>ApplicationContext</code> 代表了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.HierarchicalBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.EnvironmentCapable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class"><span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实所谓的 <code>getBean</code> 方法是定义在 <code>ListableBeanFactory</code> 接口所继承的 <code>BeanFactory</code> 接口中的。这样说来，我们应该是可以直接通过 <code>BeanFactory</code> 来调用 <code>Bean</code> 的，其实有一个根据 <code>xml</code> 来实现的 <code>BeanFactory</code> ，是这样调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.binglau.bean.TestBean;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactory context = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"beanFactory.xml"</span>));</span><br><span class="line"><span class="comment">//        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:beanFactory.xml");</span></span><br><span class="line">        TestBean testBean = (TestBean) context.getBean(<span class="string">"testBean"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"test bean: %s"</span>, testBean.getTestStr());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在让我们开始进入 <code>XmlBeanFactory</code> 中来分析一下吧</p><h2 id="XmlBeanFactory"><a href="#XmlBeanFactory" class="headerlink" title="XmlBeanFactory"></a>XmlBeanFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"serial"</span>, <span class="string">"all"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看出，他是继承了 <code>DefaultListableBeanFactory</code>，而  <code>DefaultListableBeanFactory</code> 也是整个 bean 加载的核心部分，是 Spring 注册及加载 bean 的默认实现。我们先从全局角度来了解一下它</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_29/%E5%AE%B9%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9B%BE.png?raw=true" alt="容器加载相关类图"></p><h3 id="DefaultListableBeanFactory-的各个类功能："><a href="#DefaultListableBeanFactory-的各个类功能：" class="headerlink" title="DefaultListableBeanFactory 的各个类功能："></a><code>DefaultListableBeanFactory</code> 的各个类功能：</h3><ul><li>AliasRegistry: 定义对 alias 的简单增删改等操作</li><li>SimpleAliasRegistry: 主要使用 map 作为 alias 的缓存，并对接口 AliasRegistry 进行实现</li><li>SingletonBeanRegistry: 定义对单例的注册及获取</li><li>BeanFactory: 定义获取 bean 及 bean 的各种属性</li><li>DefaultSingletonBeanRegistry: 对接口 SingletonBeanRegistry 各函数的实现</li><li>HierarchicalBeanFactory: 继承 BeanFactory，也就是在 BeanFactory 定义的功能的基础上增加了对 parentFactory 的支持</li><li>BeanDefinitionRegistry: 定义对 BeanDefinition 的各种增删改操作</li><li>FactoryBeanRegistrySupport: 在 DefaultSingletonBeanRegistry 基础上增加了对 FactoryBean 的特殊处理功能</li><li>ConfigurableBeanFactory: 提供配置 Factory 的各种方法</li><li>ListableBeanFactory: 根据各种条件获取 bean 的配置清单</li><li>AbstractBeanFactory: 综合 FactoryBeanRegistrySupport 和 ConfigurableBeanFactory 的功能</li><li>AutowireCapableBeanFactory: 提供创建 bean、自动注入、初始化以及应用 bean 的后处理器</li><li>AbstractAutowireCapableBeanFactory: 综合 AbstractBeanFactory 并对接口 AutowireCapableBeanFactory 进行实现</li><li>ConfigurableListableBeanFactory: BeanFactory 配置清单，指定忽略类型及接口等</li><li>DefaultListableBeanFactory: 综合上面的所有功能，主要是对 Bean 注册后的处理</li></ul><p><code>XmlFactoryBean</code>  主要是针对 XML 文档对 <code>DefaultListableBeanFactory</code> 的个性化实现，唯一不同的也就是 <code>XmlBeanDefinitionReader</code> 类型的 <code>reader</code>。</p><h3 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a><code>XmlBeanDefinitionReader</code></h3><p>其中我们看到 <code>XmlFactoryBean</code> 构造器中第二句 <code>this.reader.loadBeanDefinitions(resource);</code>，但从名字来看它应该是加载 Bean 的主要执行者，而 reader 的定义在顶上 <code>private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);</code> 。所谓 <code>XmlBeanDefinitionReader</code> 主要是负责读取 Spring 配置文件信息。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9B%BE.png?raw=true" alt="配置文件读取相关类图"></p><p>这张图 Idea 生成有些许差别，于是就自己画了一下。</p><ul><li>ResourceLoader：定义资源加载器，主要应用于根据给定的资源文件地址返回对应的 Resource</li><li>BeanDefinitionReader: 主要定义资源文件读取并转换为 BeanDefinition 的各个功能</li><li>EnvironmentCapable：定义获取 Environment 方法</li><li>DocumentLoader：定义从资源文件加载到转换为 Document 的功能</li><li>AbstractBeanDefinitionReader：对 EnvironmentCapable、BeanDefinitionReader 类定义的功能进行实现</li><li>BeanDefinitionDocumentReader：定义读取 Document 并注册 BeanDefinition 功能</li><li>BeanDefinitionParserDelegate: 定义解析 Element 的各种方法</li></ul><p>经过上面的分析，我们大概能得出 XML 配置文件读取的大致流程：</p><ol><li>通过继承自 AbstractBeanDefinitionReader 中的方法，来使用 ResourceLoader 将资源文件路径转换为对应的 Resource 文件</li><li>通过 DocumentLoader 对 Resource 文件进行转换，将 Resource 文件转换为 Document 文件</li><li>通过实现接口 BeanDefinitionDocumentReader 的 DefaultBeanDefinitionDocumentReader 类对 Document 进行解析，并使用 BeanDefinitionParserDelegate 对 Element 进行解析</li></ol><h3 id="分析-XmlBeanFactoy"><a href="#分析-XmlBeanFactoy" class="headerlink" title="分析 XmlBeanFactoy"></a>分析 XmlBeanFactoy</h3><p>这时候，让我们在回头看 <code>BeanFactory context = new XmlBeanFactory(new ClassPathResource(&quot;beanFactory.xml&quot;));</code></p><p>先从现有信息可以整理出下面这张时序图</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_29/XmlFactoryBean%E6%97%B6%E5%BA%8F%E5%9B%BE.png?raw=true" alt="XmlFactoryBean时序图"></p><h4 id="配置文件封装"><a href="#配置文件封装" class="headerlink" title="配置文件封装"></a>配置文件封装</h4><p>首先看看 <code>Resource</code> 配置文件的加载，也就是 <code>new ClassPathResource(&quot;beanFactory.xml&quot;)</code></p><p>在 Java 中，将不同来源的资源抽象成 URL，通过注册不同的 <code>handler(URLStreamHandler)</code>来处理不同来源的资源的读取逻辑，一般 handler 的类型使用不同前缀（协议，Protocol）来识别，如 “file:”、“http:”、“jar:” 等，然而 URL 没有默认定义相对 Classpath 或 ServletContext 等资源的 handler，虽然可以注册自己的 URLStreamHandler 来解析特定的URL前缀（协议），比如 “classpath:” ，然而这需要了解 URL 的实现机制，而且URL也没有提供一些基本的方法，如检查当前资源是否存在、检查当前资源是否可读等方法。 因而 Spring 对其内部使用到的资源实现了自己的抽象结构：Resource接口来封装底层资源。</p><p>其内部资源的抽象结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an &#123;<span class="doctag">@link</span> InputStream&#125; for the content of an underlying resource.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It is expected that each call creates a &lt;i&gt;fresh&lt;/i&gt; stream.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This requirement is particularly important when you consider an API such</span></span><br><span class="line"><span class="comment"> * as JavaMail, which needs to be able to read the stream multiple times when</span></span><br><span class="line"><span class="comment"> * creating mail attachments. For such a use case, it is &lt;i&gt;required&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * that each &#123;<span class="doctag">@code</span> getInputStream()&#125; call returns a fresh stream.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the input stream for the underlying resource (must not be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.io.FileNotFoundException if the underlying resource doesn't exist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the content stream could not be opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">InputSteramSource 抽象了所有 Spring 内部使用到的底层资源：File、URL、Classpath 下的资源和 ByteArray 等、它只有一个方法定义：getInputStream()，该方法返回一个新的 InputStream 对象。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存在性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可读性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否处于打开状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于当前资源创建一个相对资源的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于错误处理中的打印信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同来源的资源都有其对应的实现：</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_29/%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9B%BE.png?raw=true" alt="资源文件处理相关类图"></p><p>其中 <code>ClassPathResouce</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation opens an InputStream for the given class path resource.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.ClassLoader#getResourceAsStream(String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Class#getResourceAsStream(String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">InputStream is;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">is = <span class="keyword">this</span>.clazz.getResourceAsStream(<span class="keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">is = <span class="keyword">this</span>.classLoader.getResourceAsStream(<span class="keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">is = ClassLoader.getSystemResourceAsStream(<span class="keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(getDescription() + <span class="string">" cannot be opened because it does not exist"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>XmlFactoryBean</code> 中，我们先调用了 <code>super</code>，现在看看 <code>super</code> 干了什么事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AbstractAutowireCapableBeanFactory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有必要提及一下 <code>ignoreDependencyInterface</code> 方法。<code>ignoreDependencyInterface</code> 的主要功能是忽略给定接口的自动装配功能，那么，这样做的目的是什么呢？会产生什么样的效果呢？</p><p>举例来说，当 A 中有属性 B，那么当 Spring 在获取 A 的 Bean 的时候如果其属性 B 还没有初始化，那么 Spring 会自动初始化 B，这也是 Spring 中提供的一个重要特性。但是，某些情况下，B 不会被初始化，其中的一种情况就是 B 实现了 BeanNameAware 接口。Spring 中是这样介绍的：自动装配时忽略给定的依赖接口，典型应用是通过其他方式解析 Application 上下文注册依赖，类似于 BeanFactory 通过 BeanFactoryAware 进行注入或者 ApplicationContext 通过 ApplicationContextAware 进行注入。</p><h4 id="加载-Bean"><a href="#加载-Bean" class="headerlink" title="加载 Bean"></a>加载 Bean</h4><p><code>this.reader.loadBeanDefinitions(resource)</code> 的讲解，其时序图</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_29/loadBeanDefinitions%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.png?raw=true" alt="loadBeanDefinitions函数执行时序图"></p><ol><li>封装资源文件。当进入 <code>XmlBeanDefinitionReader</code> 后首先对参数 <code>Resource</code> 使用 <code>EncodedResource</code> 类进行封装。</li><li>获取输入流。从 <code>Resource</code> 中获取对应的 <code>InputStream</code> 并构造 <code>InputSource</code></li><li>通过构造的 <code>InputSource</code> 实例和 <code>Resource</code> 实例继续调用函数 <code>doLoadBeanDefinitions</code></li></ol><h5 id="时序图中的逻辑实现"><a href="#时序图中的逻辑实现" class="headerlink" title="时序图中的逻辑实现"></a>时序图中的逻辑实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encodedResource the resource descriptor for the XML file,</span></span><br><span class="line"><span class="comment"> * allowing to specify an encoding to use for parsing the file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过属性来记录已经加载的资源</span></span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"><span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从 encodedResource 中获取已经封装的 Resource 对象并再次从 Resource 中获取其中的 inputStream</span></span><br><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// InputSource 这个类并不来自于 Spring，它的全路径是 org.xml.sax.InputSource</span></span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">// 真正进入逻辑核心部分</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doLoadDocument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually load the specified document using the configured DocumentLoader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the DOM Document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception when thrown from the DocumentLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setDocumentLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DocumentLoader#loadDocument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doLoadBeanDefinitions</code> 中做了三件事：</p><ol><li>获取对 XML 文件的验证模型</li><li>加载 XML 文件，并得到对应的 Document</li><li>根据返回的 Document 注册 Bean 信息</li></ol><h3 id="获取-XML-的验证模式"><a href="#获取-XML-的验证模式" class="headerlink" title="获取 XML 的验证模式"></a>获取 XML 的验证模式</h3><h4 id="DTD-与-XSD-区别"><a href="#DTD-与-XSD-区别" class="headerlink" title="DTD 与 XSD 区别"></a>DTD 与 XSD 区别</h4><p>DTD （文档类型定义），保证 XML 文档格式正确的有效方法，可以通过比较 XML 文档和 DTD 文件来看文档是否符合规范，元素和标签使用是否正确。一个 DTD 文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或符号规则。</p><p>XSD （XML Schemas Definition）。XML Scheme 描述了 XML 文档的结构。可以用一个指定的 XML Schema 来验证某个 XML 文档，以检查该 XML 文档是否符合其要求。文档设计者可以通过 XML  Schema 指定一个 XML 文档所允许的结构和内容，并可据此检查一个 XML 文档是否是有效的。XML Schema 本身是一个 XML 文档，它符合 XML 语法结构。可以用通用的 XML 解析器解析它。</p><p>在使用 XML Schema 文档中 XML 实例文档进行检验，除了要声明名称空间外（xmlns = <a href="http://www.SpringFramework.org/schema/beans），还必须制定该名称空间所对应的" target="_blank" rel="noopener">http://www.SpringFramework.org/schema/beans），还必须制定该名称空间所对应的</a> XML Schema 文档的存储位置。通过 schemaLocation 熟悉来指定名称空间所对应的 XML Schema 文档的存储位置，它包含两个部分，一部分是名称空的 URI，另一部分就是该名称空间所标识的 XML Shema 文件位置或 URL 地址(xsi:schemaLocation=”<a href="http://www.Springframework.org/schema/beans" target="_blank" rel="noopener">http://www.Springframework.org/schema/beans</a> <a href="http://www.Springframework.org/schema/beans/Spring-beans.xsd" target="_blank" rel="noopener">http://www.Springframework.org/schema/beans/Spring-beans.xsd</a>“)</p><h4 id="验证模式的获取"><a href="#验证模式的获取" class="headerlink" title="验证模式的获取"></a>验证模式的获取</h4><p>进入 <code>Document doc = doLoadDocument(inputSource, resource);</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>getValidationModeForResource(resource)</code>就是获取验证模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the validation mode for the specified &#123;<span class="doctag">@link</span> Resource&#125;. If no explicit</span></span><br><span class="line"><span class="comment"> * validation mode has been configured then the validation mode is</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #detectValidationMode detected&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Override this method if you would like full control over the validation</span></span><br><span class="line"><span class="comment"> * mode, even when something other than &#123;<span class="doctag">@link</span> #VALIDATION_AUTO&#125; was set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValidationModeForResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> validationModeToUse = getValidationMode();</span><br><span class="line">        <span class="comment">// 如果手动指定了验证模式则使用指定的验证模式</span></span><br><span class="line"><span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line"><span class="keyword">return</span> validationModeToUse;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果未指定则使用自动检测</span></span><br><span class="line"><span class="keyword">int</span> detectedMode = detectValidationMode(resource);</span><br><span class="line"><span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line"><span class="keyword">return</span> detectedMode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hmm, we didn't get a clear indication... Let's assume XSD,</span></span><br><span class="line"><span class="comment">// since apparently no DTD declaration has been found up until</span></span><br><span class="line"><span class="comment">// detection stopped (before finding the document's root tag).</span></span><br><span class="line"><span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>detectValidationMode</code> 将自动检测验证模式工作委派给专门处理类 <code>XmlValidationModeDetecotor</code>，调用了 <code>XmlValidationModeDetecotor</code> 的 <code>vaildationModeDetector</code> 方法，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detects which kind of validation to perform on the XML file identified</span></span><br><span class="line"><span class="comment"> * by the supplied &#123;<span class="doctag">@link</span> Resource&#125;. If the file has a &#123;<span class="doctag">@code</span> DOCTYPE&#125;</span></span><br><span class="line"><span class="comment"> * definition then DTD validation is used otherwise XSD validation is assumed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Override this method if you would like to customize resolution</span></span><br><span class="line"><span class="comment"> * of the &#123;<span class="doctag">@link</span> #VALIDATION_AUTO&#125; mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (resource.isOpen()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Passed-in Resource ["</span> + resource + <span class="string">"] contains an open stream: "</span> +</span><br><span class="line"><span class="string">"cannot determine validation mode automatically. Either pass in a Resource "</span> +</span><br><span class="line"><span class="string">"that is able to create fresh streams, or explicitly specify the validationMode "</span> +</span><br><span class="line"><span class="string">"on your XmlBeanDefinitionReader instance."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputStream inputStream;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">inputStream = resource.getInputStream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Unable to determine validation mode for ["</span> + resource + <span class="string">"]: cannot open InputStream. "</span> +</span><br><span class="line"><span class="string">"Did you attempt to load directly from a SAX InputSource without specifying the "</span> +</span><br><span class="line"><span class="string">"validationMode on your XmlBeanDefinitionReader instance?"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Unable to determine validation mode for ["</span> +</span><br><span class="line">resource + <span class="string">"]: an error occurred whilst reading from the InputStream."</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detect the validation mode for the XML document in the supplied &#123;<span class="doctag">@link</span> InputStream&#125;.</span></span><br><span class="line"><span class="comment"> * Note that the supplied &#123;<span class="doctag">@link</span> InputStream&#125; is closed by this method before returning.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputStream the InputStream to parse</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #VALIDATION_DTD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #VALIDATION_XSD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// Peek into the file to look for DOCTYPE.</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> isDtdValidated = <span class="keyword">false</span>;</span><br><span class="line">String content;</span><br><span class="line"><span class="keyword">while</span> ((content = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">content = consumeCommentTokens(content);</span><br><span class="line">                 <span class="comment">// 如果读取的行是空或者是注释则略过</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.inComment || !StringUtils.hasText(content)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hasDoctype(content)) &#123;</span><br><span class="line">isDtdValidated = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">                 <span class="comment">// 读取到 &lt; 开始符号，验证模式一定会在开始符号之前</span></span><br><span class="line"><span class="keyword">if</span> (hasOpeningTag(content)) &#123;</span><br><span class="line"><span class="comment">// End of meaningful data...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (CharConversionException ex) &#123;</span><br><span class="line"><span class="comment">// Choked on some character encoding...</span></span><br><span class="line"><span class="comment">// Leave the decision up to the caller.</span></span><br><span class="line"><span class="keyword">return</span> VALIDATION_AUTO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Does the content contain the DTD DOCTYPE declaration?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasDoctype</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> content.contains(DOCTYPE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-Document"><a href="#获取-Document" class="headerlink" title="获取 Document"></a>获取 Document</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the &#123;<span class="doctag">@link</span> Document&#125; at the supplied &#123;<span class="doctag">@link</span> InputSource&#125; using the standard JAXP-configured</span></span><br><span class="line"><span class="comment"> * XML parser.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line"><span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EntityResolver</code> 解释： 如果 SAX 应用程序需要实现自定义处理外部实体，则必须实现此接口并使用  <code>setEntityResolver</code> 方法向 SAX 驱动器注册一个实例。即防止下载 DTD 时候网络错误，提供一个寻找 DTD 声明的方法。</p><h3 id="解析及注册-BeanDefinitions"><a href="#解析及注册-BeanDefinitions" class="headerlink" title="解析及注册 BeanDefinitions"></a>解析及注册 BeanDefinitions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the bean definitions contained in the given DOM document.</span></span><br><span class="line"><span class="comment"> * Called by &#123;<span class="doctag">@code</span> loadBeanDefinitions&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Creates a new instance of the parser class and invokes</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> registerBeanDefinitions&#125; on it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> doc the DOM document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor (for context information)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setDocumentReaderClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanDefinitionDocumentReader#registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 DefaultBeanDefinitionDocumentReader 实例化 BeanDefinitionDocumentReader</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">        <span class="comment">// 在实例化 BeanDefinitionReader 时候会将 BeanDefinitionRegistry 传入，默认使用继承 DefaultListableBeanFactory 的子类</span></span><br><span class="line">        <span class="comment">// 记录统计前 BeanDefinition 的加载个数</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">// 加载及注册 bean</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">        <span class="comment">// 记录本次加载的 BeanDefinition 个数</span></span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation parses bean definitions according to the "spring-beans" XSD</span></span><br><span class="line"><span class="comment"> * (or DTD, historically).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Opens a DOM Document; then initializes the default settings</span></span><br><span class="line"><span class="comment"> * specified at the &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; level; then parses the contained bean definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line">        <span class="comment">// 重点：提取 root</span></span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">        <span class="comment">// 专门处理解析</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            <span class="comment">// 处理 profile 属性</span></span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line"><span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 解析前处理，留给子类实现</span></span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        <span class="comment">// 解析后处理，留给子类实现</span></span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * "import", "alias", "bean".</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对 beans 的处理</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                         <span class="comment">// 默认标签解析</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="comment">// 自定义标签解析</span></span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>《Spring源码深度解析》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 当前版本 Spring 4.3.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们一开始需要先定义一个 &lt;code&gt;Bean&lt;/code&gt; 和一个 &lt;code&gt;xml&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收与内存分配策略</title>
    <link href="http://yoursite.com/2017/10/23/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2017/10/23/垃圾回收与内存分配策略/</id>
    <published>2017-10-23T08:56:05.000Z</published>
    <updated>2018-07-18T15:59:49.081Z</updated>
    
    <content type="html"><![CDATA[<p>谈及 GC 自然是需要先谈及如何触发 GC，GC 作为垃圾回收器，自然是需要定义内存中『垃圾』的，那么怎么定义自然就成了关键。总体来说有以下的思路。</p><a id="more"></a><h2 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h2><h3 id="计数引用"><a href="#计数引用" class="headerlink" title="计数引用"></a>计数引用</h3><p>简单思路，引用 +1，失效 -1。对于循环引用无效。比较简单且 JVM 不是使用这种方法的，所以不进行深入介绍了。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" target="_blank" rel="noopener">维基百科</a></p><p>采用这类 GC 的主流语言有：Python/PHP/Perl/TCL/Objective-C。</p><h4 id="与追踪类算法相比优势"><a href="#与追踪类算法相比优势" class="headerlink" title="与追踪类算法相比优势"></a>与追踪类算法相比优势</h4><ol><li>可以保证对象引用为0时立马得到清理，无不确定行</li><li>大多数操作具有增量特性（incremental），GC 可与应用交替运行，不需要暂停应用即可完成回收功能</li><li>可以用来优化运行时性能。比如函数式编程中所推崇的「<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可变数据结构</a>」的更新就能收益：运行时知道某个对象的引用为1，这时对这个对象进行修改，类似 <code>str &lt;- str+&quot;a&quot;</code>，那么这个修改就可以在本地进行，而不必进行额外的 copy</li></ol><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol><li>无法解决循环引用。CPython 使用独特的<a href="https://docs.python.org/release/2.5.2/ext/refcounts.html" target="_blank" rel="noopener">环检测算法规避</a>；此外也可以用弱引用的方式解决，弱引用不会保护该对象被 GC 回收。如果该对象被回收了，那么这个弱引用会被赋予一个安全值（一般为NULL）。</li><li>实现一个高效率的引用计数 GC 比较困难。主要包括下面两方面<ul><li>space overhead，每个对象需要额外的空间来存储其引用次数，在追踪类 GC 中，用以标注对象是否在使用中的flag 位一般放在引用变量里面</li><li>speed overhead，在增加/减少对象的引用时，需要修改引用次数。这对于栈上的赋值（on-stack assignment，比如函数调用是的参数、函数内部变量等）影响是非常大的，因为之前只需要简单修改寄存器里面的值，现在需要一个原子操作（这涉及到加锁，会浪费几百个 CPU cycles）</li></ul></li><li>减少一个对象的引用计数时，会级联减少其引用对象的计数，这就可能造成同时删除过多的对象。在实现中一般会把要回收的对象放入一队列，当程序申请大小为 N 的内存时，从这个队列取出总体积不小于 N 的一个或多个对象将其回收。</li></ol><h3 id="可达性分析（追踪）"><a href="#可达性分析（追踪）" class="headerlink" title="可达性分析（追踪）"></a>可达性分析（追踪）</h3><p>基本思路：它将整个内存中的对象看做一个树的形状，只要抓住根节点（<code>GC Roots</code>）并从根节点向下会形成无数子树（引用链（Reference Chain）），当一个对象没有与根节点相关联的子树的时候（这个对象从 <code>GC Roots</code> 不可达）则说明此对象不可用。</p><p>在 Java 中，可作为 <code>GC Roots</code> 的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中 JNI （即一般说的 Native 对象）引用的对象。</li></ul><p>值得一说的是，Java 中对于引用也是有分级的，当内存空间不足够的时候，我们会从最弱的引用开始释放空间。</p><ul><li>强引用，类似于 <code>Object obj = new Object()</code> 这类在代码里面常见的。永远不会回收。</li><li>软引用，有用但并非必需的对象。在系统将要发生内存溢出异常前，会将这些对象列入回收范围之中进行二次回收。提供了 <code>SoftReference</code> 类来实现软引用。</li><li>弱引用，只能生存到下一次垃圾收集发生之前。<code>WeakReference</code> 类实现。</li><li>虚引用，将一个对象设置为虚引用唯一目的就是能在这个对象呗收集器回收时受到一个系统通知。<code>PhantomReference</code>类实现。</li></ul><p>要知道一点，就算被判定为不可达对象了，也并非非死不可，这时候处于准备去死的状态吧。</p><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ul><li>是否有必要执行（只能执行一次）<code>finalize()</code> 方法，如果有则会放入一个 <code>F-Queue</code> 队列，由一个低优先级的 <code>Finalize</code> 线程来执行它，但不会保证执行完成（防止阻塞了 <code>F-Queue</code> 队列导致内存回收崩溃）。</li><li>GC 将在 <code>F-Queue</code> 中的对象进行第二次标记，如果对象想拯救自己，则需要在 <code>finalize</code> 方法给自己与 <code>GC Roots</code> 再建立上关联。</li></ul><p>该算法的缺点有：</p><ol><li>在进行 GC 期间，整个系统会被挂起（暂停，Stop-the-world），所以在一些实现中，会采用各种措施来减少这个暂停时间</li><li>heap 容易出现碎片。实现中一般会进行 move 或 compact。（需要说明一点，所有 heap 回收机制都会这个问题）</li><li>在 GC 工作一段时间后，heap 中连续地址上存在 age 不同的对象，这非常不利于引用的本地化（locality of reference）</li><li>回收时间与 heap 大小成正比</li></ol><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/标记清除.png?raw=true" alt="标记清除"></p><p><strong>标记：</strong>之前介绍的可达性算法标记。完成之后进行<strong>清除</strong>。</p><p>缺点：</p><ul><li>标记和清除两个过程的效率都不高</li><li>产生空间碎片</li></ul><h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h4><h5 id="Bitmap-marking"><a href="#Bitmap-marking" class="headerlink" title="Bitmap marking"></a>Bitmap marking</h5><p>将其可达性使用一个 <code>Bitmap</code> 来存储，其映射到各个 <code>Object</code> 的内存地址。这就要求 object 进行对齐，比如：heap 大小为 65536 字节，所有的对象以 16 字节对齐，那么堆内就有 4096 个地址可以作为对象的起始地址，与之对应需要 4096 个 bit 即 512 个字节。</p><p>bitmap 还有下面两个优势：</p><ol><li>sweep 操作更高效，这是由于 bitmap 结构紧凑，可以一次性加载到内存中；通过整型的 ALU 操作与<a href="https://en.wikipedia.org/wiki/Branch_%28computer_science%29" target="_blank" rel="noopener">条件分支（conditional branch）</a> 一次性可进行 32 位的检测</li><li>在类 Unix 系统中，bitmap 有利于 fork() 出来的进程与主进程进行 copy-on-write 数据共享，<a href="http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0#" target="_blank" rel="noopener">Ruby 2.0 就因此获得较大性能提升</a>。</li></ol><h5 id="Lazy-sweeping"><a href="#Lazy-sweeping" class="headerlink" title="Lazy sweeping"></a>Lazy sweeping</h5><p>MS 算法有以下几个特点：</p><ol><li>某对象一旦被标为garbage，它永远都会是 garbage，不会被 mutator 再访问</li><li>mutator 不能修改 mark-bit</li></ol><p>基于以上几点，sweep 操作完全可以与 mutator 同时运行（parallel）的。<br>Lazy sweep 指的是把较为耗时（相对 mark 来说）的 sweep 操作放在 allocate 过程中，并且只在有足够的空间时才去真正进行回收。<a href="https://www.infoq.com/news/2011/08/ruby193-gc" target="_blank" rel="noopener">Ruby 1.9.3 引入 lazy sweep 获得较大性能提升</a>。</p><p>Lazy Sweep 除了降低 sweep 阶段 mutator 的暂停时间外，还有以下优点：</p><ul><li>更好的 locality。这是因为被回收的 block 会尽快地重新使用</li><li>GC 复杂度只于<strong>可到达对象</strong>成正比</li><li>在大部分 heap 空间为空时效率最好</li></ul><p><strong>除此之外还有一些优化算法如：</strong></p><ul><li>FIFO prefetch buffer [Cher et al, 2004]</li><li>Edge marking [Garner et al, 2007]</li></ul><p>就不累述了。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制</strong>算法</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/复制算法.png?raw=true" alt="复制算法"></p><p>将可用内存按容量<strong>划分为大小相等的两块(不一定会大小相等)</strong>，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象<strong>复制</strong>到另外一块上面，然后再<strong>把已使用过的内存空间一次清理掉</strong>。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><p>缺点：内存占用太多。</p><h4 id="新生代的垃圾收集"><a href="#新生代的垃圾收集" class="headerlink" title="新生代的垃圾收集"></a>新生代的垃圾收集</h4><p>将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，<strong>将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</strong></p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/标记整理.png?raw=true" alt="标记整理"></p><p>标记过程仍然与『标记-清除』算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</strong>。</p><p>缺点：效率不高。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在 HotSpot 中有一组叫做 <code>OopMap</code> 的数据结构用于当 『Stop World』时候获取哪些地方存放对象引用及对象类型（用于释放内存大小）。在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p><p>为了减少使用 <code>OopMap</code> 指令的生成（占用大量空间），只需要在『特殊位置』记录了这些信息，这些位置就被称为<strong>安全点</strong>。</p><p>即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，<strong>安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的</strong>——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><h3 id="HotSpot-垃圾收集器"><a href="#HotSpot-垃圾收集器" class="headerlink" title="HotSpot 垃圾收集器"></a>HotSpot 垃圾收集器</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/hotspotGCs.png?raw=true" alt="HotSpot 垃圾收集器"></p><p>在这里<strong>只会详细介绍 G1</strong>，如果有其他垃圾收集器需求可以自行查询解决（网上充斥了大量的资料）。</p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/serial.png?raw=true" alt="serial"></p><p>重点提要：</p><ol><li>新生代</li><li>单线程</li><li>简单高效，适合 Client</li></ol><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/ParNew.png?raw=true" alt="parNew"></p><p>重点提要:</p><ol><li>新生代</li><li>Serial 多线程版本</li><li>CMS(老年代) 无法配合 Paraller Scavenge（新生代），所以只能选择 Serial / ParNew (<a href="http://hllvm.group.iteye.com/group/topic/37095#post-242695" target="_blank" rel="noopener">为什么</a>)</li></ol><h3 id="Paraller-Scavenge"><a href="#Paraller-Scavenge" class="headerlink" title="Paraller Scavenge"></a>Paraller Scavenge</h3><p>重点提要：</p><ol><li>新生代</li><li>可控吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））</li><li>自适应调节策略（虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量）</li></ol><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/serialOld.png?raw=true" alt="serial old"></p><p>重点提要：</p><ol><li>serial 老年代版本</li><li>使用“标记-整理”算法</li></ol><h3 id="Paraller-Old"><a href="#Paraller-Old" class="headerlink" title="Paraller Old"></a>Paraller Old</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/ParallerOld.png?raw=true" alt="paraller old"></p><p>重点提要：</p><ol><li>Paraller Scavenge 老年代版本</li><li>这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”</li><li>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器</li></ol><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/cms.png?raw=true" alt="cms"></p><p>重点提要：</p><ol><li>老年代</li><li>并发收集、低停顿</li><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次FullGC的产生</li><li>CMS是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</li></ol><h3 id="G1（Garbage-First-Garbage-Collector）-垃圾收集器"><a href="#G1（Garbage-First-Garbage-Collector）-垃圾收集器" class="headerlink" title="G1（Garbage-First Garbage Collector） 垃圾收集器"></a>G1（Garbage-First Garbage Collector） 垃圾收集器</h3><p>之所以重点说 G1 是因为在 Java 9 中 G1 已经被作为默认的垃圾收集器了，且其理念与之前的收集器有很大的区别。</p><h4 id="G1-的特点"><a href="#G1-的特点" class="headerlink" title="G1 的特点"></a>G1 的特点</h4><p>G1 是一个“服务器风格（server-style）”的垃圾回收器，它主要有下面的这些属性：</p><ul><li><strong>并行和并发。</strong> G1 可以从今天最新的硬件中获得并行的能力。它能够使用所有可用的CPU（CPU多核，硬件多线程等）来<strong>加速它的 “stop-the-world” 机制</strong>（这个机制简称STW，即，在执行垃圾收集算法时，Java应用程序的其他所有除了垃圾收集帮助器线程之外的线程都被挂起）。</li><li><strong>分代处理。</strong> 就像其它的HotSpot 垃圾回收器，G1 是分代的，也就是说，它在处理新分配的对象（年轻代）和已经生存了一段时间的对象（年老代）时会不同，它会更多地考虑一些新创建的对象实例，因为越新创建的就越有最大的可能性被回收，老对象只是偶尔访问一下。对于大多数的Java应用来说，这个机制可以极大地提高回收效率。</li><li><strong>紧凑内存（碎片整理）。</strong> 不像CMS，<strong>G1 会对堆进行内存整理</strong>。压缩可以消除潜在的内存碎片的问题，这样程序就可以更长时间的平滑运行。</li><li><strong>预见性的。</strong> G1 比起 CMS 来有更多的预见性。G1 能建立可预测的<strong>停顿时间模型</strong>，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。</li></ul><h4 id="G1-基本思路"><a href="#G1-基本思路" class="headerlink" title="G1 基本思路"></a>G1 基本思路</h4><p>G1 将整个 Java 堆划分为多个大小相等的<strong>独立区域（Region）</strong>，虽然还保留有新生代和老年代的概念，但是<strong>新生代和老年代不再是物理隔离</strong>的了，它们都是一部分 Region（不需要连续）的集合。</p><p>G1 之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。<strong>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据运行的收集时间，优先回收价值最大的 Region（也就是 Garbage-First 名称由来）。</strong>这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p><h5 id="对象引用不确定在哪个-Region"><a href="#对象引用不确定在哪个-Region" class="headerlink" title="对象引用不确定在哪个 Region"></a>对象引用不确定在哪个 Region</h5><p>Region 不是孤立的。一个对象分配在某个 Region 中，它并非只能被本 Region 中的其他对象引用，而是可以与整个 Java 堆任意的对象发生引用关系。那么做可达性分析的时候岂不是还得扫描整个 Java 堆才能保证准确性？这个问题在其他收集器中也存在，但是 G1 中尤其突出。</p><p>在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 <code>Remembered Set</code> 来避免全堆扫描的。<strong>G1 中每个 Region 都有一个与之对应的 <code>Remembered Set</code>，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 <code>Remembered Set</code> 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 <code>Remembered Set</code> 即可保证不对全堆扫描也不会有遗漏。</strong></p><h4 id="G1-具体流程（不考虑维护-Remembered-Set）"><a href="#G1-具体流程（不考虑维护-Remembered-Set）" class="headerlink" title="G1 具体流程（不考虑维护 Remembered Set）"></a>G1 具体流程（不考虑维护 Remembered Set）</h4><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/g1.png?raw=true" alt="g1"></p><ol><li>初始标记：仅仅标记 GC Roots 能关联到的对象，并且修改 TAMS(Next Top at Mark Start) 的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建对象。此处需要 STW。</li><li>并发标记：从 GC Roots 开始对堆中的对象进行可达性分析，找出存活对象。并行执行。</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那部分标记记录。虚拟机会将这段时间的改变记录在线程 <code>Remembered Set Logs</code> 中，需要将它的数据合并到 <code>Remembered Set</code> 中。需要 STW。</li><li>筛选回收：首先对各个 Region 的回收价值和成本进行排序，然后根据用户所期望的 GC 停顿时间来制定回收计划。并发执行。</li></ol><h4 id="G1-diff-CMS"><a href="#G1-diff-CMS" class="headerlink" title="G1 diff CMS"></a>G1 diff CMS</h4><ul><li>G1在压缩空间方面有优势</li><li>G1通过将内存空间分成区域（Region）的方式避免内存碎片问题</li><li>Eden, Survivor, Old区不再固定、在内存使用效率上来说更灵活</li><li>G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象</li><li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做</li><li>G1会在Young GC中使用、而CMS只能在OLD区使用</li></ul><h4 id="G1-适用场景"><a href="#G1-适用场景" class="headerlink" title="G1 适用场景"></a>G1 适用场景</h4><ul><li>服务端多核CPU、JVM内存占用较大的应用（至少大于6G）</li><li>应用在运行过程中会产生大量内存碎片、需要经常压缩空间</li><li>想要更可控、可预期的GC停顿周期；防止高并发下应用雪崩现象</li></ul><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p><strong>注明：此处由于是书上（JDK7版本）描述，所以有些 JVM 参数可能过时了，大家可以参照 JDK 9 常用参数（TODO）来使用</strong></p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/jvmArg_1.png?raw=true" alt="JVM参数"></p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_28/jvmArg_2.png?raw=true" alt="JVM参数"></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，往大方向讲，就是在<strong>堆上分配</strong>（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，<strong>如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配</strong>。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><h3 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h3><p>重点提要：</p><ol><li>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</li><li>虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</li><li>Minor GC 是指新生代发生的 GC，非常频繁；Full GC/Major GC 是指老年代发生的 GC，速度很慢。</li></ol><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>重点提要：</p><ol><li>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。</li><li>避免『短命』大对象</li><li>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</li></ol><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>重点提要：</p><ol><li>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</li><li>对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</li></ol><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>重点提要：</p><ol><li>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，<strong>无须等到MaxTenuringThreshold中要求的年龄</strong>。</li></ol><h3 id="分配空间担保"><a href="#分配空间担保" class="headerlink" title="分配空间担保"></a>分配空间担保</h3><p>重点提要：</p><ol><li>在发生Minor GC之前，虚拟机会先<strong>检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<strong>HandlePromotionFailure设置值是否允许担保失败</strong>。如果允许，那么会继续<strong>检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</strong>，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；<strong>如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC</strong>。</li></ol><h2 id="GC-日志阅读实例（G1）"><a href="#GC-日志阅读实例（G1）" class="headerlink" title="GC 日志阅读实例（G1）"></a>GC 日志阅读实例（G1）</h2><h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=12 (full 1):</span><br><span class="line"><span class="meta"> #</span> 这行表示使用了G1垃圾收集器，total heap 3145728K，使用了336645K。</span><br><span class="line"> garbage-first heap   total 3145728K, used 336645K [0x0000000700000000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"><span class="meta"> #</span> Region大小为1M，青年代占用了172个（共176128K），幸存区占用了13个（共13312K）。</span><br><span class="line">  region size 1024K, 172 young (176128K), 13 survivors (13312K)</span><br><span class="line"><span class="meta"> #</span> java 8的新特性，去掉永久区，添加了元数据区，这块不是本文重点，不再赘述。需要注意的是，之所以有committed和reserved，是因为没有设置MetaspaceSize=MaxMetaspaceSize。</span><br><span class="line"> Metaspace       used 29944K, capacity 30196K, committed 30464K, reserved 1077248K</span><br><span class="line">  class space    used 3391K, capacity 3480K, committed 3584K, reserved 1048576K</span><br><span class="line"><span class="meta"> #</span> GC原因，新生代minor GC。</span><br><span class="line">2014-11-14T17:57:23.654+0800: 27.884: [GC pause (G1 Evacuation Pause) (young)</span><br><span class="line">Desired survivor size 11534336 bytes, new threshold 15 (max 15)</span><br><span class="line">- age   1:    5011600 bytes,    5011600 total</span><br><span class="line"><span class="meta"> #</span> 发生minor GC和full GC时，所有相关region都是要回收的。而发生并发GC时，会根据目标停顿时间动态选择部分垃圾对并多的Region回收，这一步就是选择Region。_pending_cards是关于RSet的Card Table。predicted base time是预测的扫描card table时间。</span><br><span class="line"> 27.884: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 1461, predicted base time: 35.25 ms, remaining time: 64.75 ms, target pause time: 100.00 ms]</span><br><span class="line"><span class="meta"> #</span> 这一步是添加Region到collection set，新生代一共159个Region，13个幸存区Region，这也和之前的（172 young (176128K), 13 survivors (13312K)）吻合。预计收集时间是44.09 ms。 </span><br><span class="line"> 27.884: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 159 regions, survivors: 13 regions, predicted young region time: 44.09 ms]</span><br><span class="line"><span class="meta"> #</span> 这一步是对上面两步的总结。预计总收集时间79.34ms。</span><br><span class="line"> 27.884: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 159 regions, survivors: 13 regions, old: 0 regions, predicted pause time: 79.34 ms, target pause time: 100.00 ms]</span><br><span class="line">, 0.0158389 secs]</span><br><span class="line"><span class="meta">#</span> 由于收集过程是多线程并行（并发）进行，这里是4个线程，总共耗时8.1ms（wall clock time）</span><br><span class="line">   [Parallel Time: 8.1 ms, GC Workers: 4]</span><br><span class="line">   # 收集线程开始的时间，使用的是相对时间，Min是最早开始时间，Avg是平均开始时间，Max是最晚开始时间，Diff是Max-Min</span><br><span class="line">      [GC Worker Start (ms): Min: 27884.5, Avg: 27884.5, Max: 27884.5, Diff: 0.1]</span><br><span class="line">      # 扫描Roots花费的时间，Sum表示total cpu time，下同。</span><br><span class="line">      [Ext Root Scanning (ms): Min: 0.4, Avg: 0.8, Max: 1.2, Diff: 0.8, Sum: 3.1]</span><br><span class="line">      # Update RS (ms)是每个线程花费在更新Remembered Set上的时间。</span><br><span class="line">      [Update RS (ms): Min: 0.0, Avg: 0.3, Max: 0.6, Diff: 0.6, Sum: 1.4]</span><br><span class="line">         [Processed Buffers: Min: 0, Avg: 2.8, Max: 5, Diff: 5, Sum: 11]</span><br><span class="line">      # 扫描CS中的region对应的RSet，因为RSet是points-into，所以这样实现避免了扫描old generadion region，但是会产生float garbage。</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.3]</span><br><span class="line">      # 扫描code root耗时。code root指的是经过JIT编译后的代码里，引用了heap中的对象。引用关系保存在RSet中。</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.6]</span><br><span class="line">      # 拷贝活的对象到新region的耗时。</span><br><span class="line">      [Object Copy (ms): Min: 4.9, Avg: 5.1, Max: 5.2, Diff: 0.3, Sum: 20.4]</span><br><span class="line">      # 线程结束，在结束前，它会检查其他线程是否还有未扫描完的引用，如果有，则"偷"过来，完成后再申请结束，这个时间是线程之前互相同步所花费的时间。</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      # 花费在其他工作上（未列出）的时间。</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.4, Max: 1.3, Diff: 1.3, Sum: 1.4]</span><br><span class="line">      # 每个线程花费的时间和。</span><br><span class="line">      [GC Worker Total (ms): Min: 6.4, Avg: 6.8, Max: 7.8, Diff: 1.4, Sum: 27.2]</span><br><span class="line">      # 每个线程结束的时间。</span><br><span class="line">      [GC Worker End (ms): Min: 27891.0, Avg: 27891.3, Max: 27892.3, Diff: 1.3]</span><br><span class="line"><span class="meta">   #</span> 用来将code root修正到正确的evacuate之后的对象位置所花费的时间。</span><br><span class="line">   [Code Root Fixup: 0.5 ms]</span><br><span class="line"><span class="meta">   #</span> 更新code root 引用的耗时，code root中的引用因为对象的evacuation而需要更新。</span><br><span class="line">   [Code Root Migration: 1.3 ms]</span><br><span class="line"><span class="meta">   #</span> 清除code root的耗时，code root中的引用已经失效，不再指向Region中的对象，所以需要被清除。</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line"><span class="meta">   #</span> 清除card table的耗时。</span><br><span class="line">   [Clear CT: 0.2 ms]</span><br><span class="line"><span class="meta">   #</span> 其他事项共耗时5.8ms，其他事项包括选择CSet，处理已用对象，引用入ReferenceQueues，释放CSet中的region到free list。</span><br><span class="line">   [Other: 5.8 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 5.0 ms]</span><br><span class="line">      [Ref Enq: 0.1 ms]</span><br><span class="line">      [Redirty Cards: 0.0 ms]</span><br><span class="line">      [Free CSet: 0.2 ms]</span><br><span class="line"><span class="meta">   #</span> 新生代清空了，下次扩容到301MB。</span><br><span class="line">   [Eden: 159.0M(159.0M)-&gt;0.0B(301.0M) Survivors: 13.0M-&gt;11.0M Heap: 328.8M(3072.0M)-&gt;167.3M(3072.0M)]</span><br><span class="line">Heap after GC invocations=13 (full 1):</span><br><span class="line"> garbage-first heap   total 3145728K, used 171269K [0x0000000700000000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  region size 1024K, 11 young (11264K), 11 survivors (11264K)</span><br><span class="line"> Metaspace       used 29944K, capacity 30196K, committed 30464K, reserved 1077248K</span><br><span class="line">  class space    used 3391K, capacity 3480K, committed 3584K, reserved 1048576K</span><br><span class="line">&#125;</span><br><span class="line"> [Times: user=0.05 sys=0.01, real=0.02 secs]</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" target="_blank" rel="noopener">深入理解G1垃圾收集器</a></p><p><a href="https://coolshell.cn/articles/1252.html" target="_blank" rel="noopener">G1新型垃圾回收器一瞥</a></p><p><a href="https://tech.meituan.com/g1.html" target="_blank" rel="noopener">Java Hotspot G1 GC的一些关键技术</a></p><p><a href="https://liujiacai.net/blog/2018/06/15/garbage-collection-intro/" target="_blank" rel="noopener">深入浅出垃圾回收（一）简介篇</a></p><p><a href="https://liujiacai.net/blog/2018/07/08/mark-sweep/" target="_blank" rel="noopener">深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</a></p><p>《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谈及 GC 自然是需要先谈及如何触发 GC，GC 作为垃圾回收器，自然是需要定义内存中『垃圾』的，那么怎么定义自然就成了关键。总体来说有以下的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="基础原理" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <link href="http://yoursite.com/2017/10/21/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/10/21/Java内存区域与内存溢出异常/</id>
    <published>2017-10-21T08:55:36.000Z</published>
    <updated>2017-11-22T15:52:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图示各区用途"><a href="#图示各区用途" class="headerlink" title="图示各区用途"></a>图示各区用途</h3><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_27/1.png?raw=true" alt="内存区域图"></p><a id="more"></a><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>可看作<strong>当前线程</strong>所执行的字节码的行号指示器。在 JVM 概念模型中（仅概念模型，各实现可能不一致），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程回复等基础功能都需要依赖这个计数器完成。</p><p>Java 方法中：正在执行的虚拟机字节码指令的地址</p><p>Native 方法中：空（Undefined）</p><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>线程私有，生命周期与线程相同。</p><p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表（粗浅流行划分中的栈）、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>局部变量表：存放编译期可知的各种基本类型、对象引用（不等同于对象本身，可能指向一个对象起始地址的引用指针， 也可能是指向一个代表对象的句柄或其他与此对象相关的位置） 和 returnAddress 类型（指向了一条字节码指令的地址）。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>为虚拟机使用到的 Native 方法服务。</p><h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4><p>被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例（The heap is the run-time data area from which memory for all class instances and arrays is allocated.）都在这里分配内存。</p><p>但随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，使之不『绝对』了。</p><p>Java 堆是 GC 管理的主要区域。从内存回收角度来看，可以将其分为『新生代』（Eden 空间、From Survivor、To Survivor）和『老年代』。从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p><p>Java 堆只需要保证逻辑上连续即可。</p><p>通过 <code>-Xmx</code> (最大堆大小)和 <code>-Xms</code> (初始堆大小)控制大小。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>各个线程共享的内存区域，它用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、JIT 编译后的代码等</strong>数据。</p><p>被很多人作为『永久代』对待（其实并不是），因为仅仅是之前的 HotSpot 设计团队将其 GC 分代收集扩展至方法区，或者说是使用永久代实现方法区而已。</p><p>JVM 规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小和可扩展外，还可以选择不实现 GC（与此对应，如果实现了则内存回收主要目标是<strong>针对常量池的回收和对类型的卸载</strong>）。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>方法区的一部分。Class 文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于<strong>存放编译器生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进行方法区的运行时常量池中存放。<strong>（这个不是运行时常量池）</strong></p><p>运行时长期是区别于上面的 Class 常量池：</p><ol><li><p>保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p></li><li><p>相较 Class 文件中的常量池具备动态性，并非预置入 Class 文件中常量池的内容才能进入方法区，运行期间也可能将新的常量放入池中，这种特性被开发人员利用较多的就是 <code>String#intern()</code> 方法（<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">intern详细介绍</a>）</p><p>​</p></li></ol><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>不是运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但是这部番内存也被频繁使用，且可能会导致 OOM 的出现。</p><p>出现原因：1.4 加入 NIO，引入基于 Channel 和 Buffer 的 I/O 方式，可以使用 Native 函数库直接分配堆外内存，然后通过存在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。（避免 Java 堆与 Native 堆复制数据）。</p><h3 id="对象探秘"><a href="#对象探秘" class="headerlink" title="对象探秘"></a>对象探秘</h3><h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><ol><li><p>检查指令是否在常量池中对应到一个类的符号引用，该符号是否被加载、解析和初始化，如果没有则需要执行相应类加载过程。</p></li><li><p>为新生对象分配内存，等同于将一块确定大小的内存从 Java 堆中划分出来。使用方法：</p><ol><li>指针碰撞：用过的内存放一边，空闲的内存放一边，中间加一个指针作为分界点的指示器，分配仅需将指针移动。</li><li>空闲列表：维护一个可用的内存块，从中分配。</li></ol><p>使用二者是看 Java 堆是否规整决定的。</p><p>有一个问题需要考虑，创建对象过于频繁，即使只是修改指针位置也有可能出现线程不安全的情况。实际中 JVM 采用 CAS 配上失败重试的方法保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间进行，即每一个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓存（Thread Local Allocation Buffer，TLAB）。线程分配各自的 TLAB，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。使用 <code>-XX:+/-UseTLAB</code> 参数来设定是否使用。</p></li><li><p>JVM 需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一工作过程也可以提前至 TLAB 分配时进行。</p></li><li><p>虚拟机要对对象进行必要的设置（对象是哪个类的实例，如何才能找到类的元信息，对象 hash code，对象 GC 分代年龄等信息）。存放于对象头(Object Header)中。</p></li><li><p>执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，将对象初始化。</p></li></ol><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_27/2.png?raw=true" alt="内存布局"></p><h5 id="对象头："><a href="#对象头：" class="headerlink" title="对象头："></a>对象头：</h5><ul><li>存储对象自身的运行时数据，如哈希码、GC分代年龄等。长度在32位和64位的虚拟机中，分别为32bit、 64bit,官方称它为“Mark Word”</li></ul><ul><li>类型指针，对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><p>注：如果对象是一个java数组，对象头中还必须有一块记录数据长度的数据。</p><h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><p>对象真正存储的有用信息，也是程序中定义的各种类型的字段内容。</p><h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><p>由于HotSpot虚拟机要求对象的起始地址必须是8字节的整数倍，通俗的说，就是对象大小必须是8字节的整数倍。对象头正好是8字节的倍数。当实例数据部分没有对齐时，需要通过对齐填充来补全。</p><h4 id="对象的定位访问"><a href="#对象的定位访问" class="headerlink" title="对象的定位访问"></a>对象的定位访问</h4><p>建立对象是为了适用对象，Java通过栈上的引用来引用堆中的对象，引用通过何种方式去定位、访问堆中的对象的具体位置取决于虚拟机的实现。目前主流的访问方式有两种：使用句柄和直接指针。 </p><p>由于 HotSpot 是使用直接指针访问，所以这里指介绍直接指针：</p><p>如果是指针访问方式，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p><p><img src="https://github.com/BingLau7/blog/blob/master/images/blog_27/3.png?raw=true" alt="直接指针"></p><p>优点：速度相对更快。</p><h4 id="关于一个程序的创建过程"><a href="#关于一个程序的创建过程" class="headerlink" title="关于一个程序的创建过程"></a>关于一个程序的创建过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.binglau.jvm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCreateProcessTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">private</span> C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"A created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassCreateProcessTest</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassCreateProcessTest a = <span class="keyword">new</span> ClassCreateProcessTest();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"B created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//some fields.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"C created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//some fields.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">B created</span></span><br><span class="line"><span class="comment">A created</span></span><br><span class="line"><span class="comment">C created</span></span><br><span class="line"><span class="comment">io.github.binglau.jvm.ClassCreateProcessTest@d716361</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">binglau<span class="meta">@BingLaudeMBP</span> ~/c/c/J/basic&gt; javap -verbose target/classes/io/github/binglau/jvm/ClassCreateProcessTest.class </span><br><span class="line">Classfile /Users/binglau/code/cradle/Java-demo/basic/target/classes/io/github/binglau/jvm/ClassCreateProcessTest.class</span><br><span class="line">  Last modified <span class="number">2017</span>-<span class="number">10</span>-<span class="number">17</span>; size <span class="number">938</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">3197</span>a5d18757ab40c96b935f44cba193</span><br><span class="line">  Compiled from <span class="string">"ClassCreateProcessTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">io</span>.<span class="title">github</span>.<span class="title">binglau</span>.<span class="title">jvm</span>.<span class="title">ClassCreateProcessTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #14.#34        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #35            // io/github/binglau/jvm/C</span><br><span class="line">   #3 = Methodref          #2.#34         // io/github/binglau/jvm/C."&lt;init&gt;":()V</span><br><span class="line">   #4 = Fieldref           #5.#36         // io/github/binglau/jvm/ClassCreateProcessTest.c:Lio/github/binglau/jvm/C;</span><br><span class="line">   #5 = Class              #37            // io/github/binglau/jvm/ClassCreateProcessTest</span><br><span class="line">   #6 = Methodref          #5.#34         // io/github/binglau/jvm/ClassCreateProcessTest."&lt;init&gt;":()V</span><br><span class="line">   #7 = Fieldref           #38.#39        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Methodref          #40.#41        // java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">   #9 = Class              #42            // io/github/binglau/jvm/B</span><br><span class="line">  #10 = Methodref          #9.#34         // io/github/binglau/jvm/B."&lt;init&gt;":()V</span><br><span class="line">  #11 = Fieldref           #5.#43         // io/github/binglau/jvm/ClassCreateProcessTest.b:Lio/github/binglau/jvm/B;</span><br><span class="line">  #12 = String             #44            // A created</span><br><span class="line">  #13 = Methodref          #40.#45        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #14 = Class              #46            // java/lang/Object</span><br><span class="line">  #15 = Utf8               b</span><br><span class="line">  #16 = Utf8               Lio/github/binglau/jvm/B;</span><br><span class="line">  #17 = Utf8               c</span><br><span class="line">  #18 = Utf8               Lio/github/binglau/jvm/C;</span><br><span class="line">  #19 = Utf8               &lt;init&gt;</span><br><span class="line">  #20 = Utf8               ()V</span><br><span class="line">  #21 = Utf8               Code</span><br><span class="line">  #22 = Utf8               LineNumberTable</span><br><span class="line">  #23 = Utf8               LocalVariableTable</span><br><span class="line">  #24 = Utf8               this</span><br><span class="line">  #25 = Utf8               Lio/github/binglau/jvm/ClassCreateProcessTest;</span><br><span class="line">  #26 = Utf8               main</span><br><span class="line">  #27 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #28 = Utf8               args</span><br><span class="line">  #29 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #30 = Utf8               a</span><br><span class="line">  #31 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #32 = Utf8               SourceFile</span><br><span class="line">  #33 = Utf8               ClassCreateProcessTest.java</span><br><span class="line">  #34 = NameAndType        #19:#20        // "&lt;init&gt;":()V</span><br><span class="line">  #35 = Utf8               io/github/binglau/jvm/C</span><br><span class="line">  #36 = NameAndType        #17:#18        // c:Lio/github/binglau/jvm/C;</span><br><span class="line">  #37 = Utf8               io/github/binglau/jvm/ClassCreateProcessTest</span><br><span class="line">  #38 = Class              #47            // java/lang/System</span><br><span class="line">  #39 = NameAndType        #48:#49        // out:Ljava/io/PrintStream;</span><br><span class="line">  #40 = Class              #50            // java/io/PrintStream</span><br><span class="line">  #41 = NameAndType        #51:#52        // println:(Ljava/lang/Object;)V</span><br><span class="line">  #42 = Utf8               io/github/binglau/jvm/B</span><br><span class="line">  #43 = NameAndType        #15:#16        // b:Lio/github/binglau/jvm/B;</span><br><span class="line">  #44 = Utf8               A created</span><br><span class="line">  #45 = NameAndType        #51:#53        // println:(Ljava/lang/String;)V</span><br><span class="line">  #46 = Utf8               java/lang/Object</span><br><span class="line">  #47 = Utf8               java/lang/System</span><br><span class="line">  #48 = Utf8               out</span><br><span class="line">  #49 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #50 = Utf8               java/io/PrintStream</span><br><span class="line">  #51 = Utf8               println</span><br><span class="line">  #52 = Utf8               (Ljava/lang/Object;)V</span><br><span class="line">  #53 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> io.github.binglau.jvm.ClassCreateProcessTest(); <span class="comment">// 在实例创建出来的时候调用，包括调用new操作符；调用Class或Java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         5: new           #2                  // class io/github/binglau/jvm/C</span><br><span class="line">         <span class="number">8</span>: dup</span><br><span class="line">         9: invokespecial #3                  // Method io/github/binglau/jvm/C."&lt;init&gt;":()V</span><br><span class="line">        12: putfield      #4                  // Field c:Lio/github/binglau/jvm/C;</span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">15</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">16</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lio/github/binglau/jvm/ClassCreateProcessTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #5                  // class io/github/binglau/jvm/ClassCreateProcessTest</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #6                  // Method "&lt;init&gt;":()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">11</span>: aload_1</span><br><span class="line">        12: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">15</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">16</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>       <span class="number">8</span>     <span class="number">1</span>     a   Lio/github/binglau/jvm/ClassCreateProcessTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;      <span class="comment">// 在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: new           #9                  // class io/github/binglau/jvm/B</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #10                 // Method io/github/binglau/jvm/B."&lt;init&gt;":()V</span><br><span class="line">         7: putstatic     #11                 // Field b:Lio/github/binglau/jvm/B;</span><br><span class="line">        10: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        13: ldc           #12                 // String A created</span><br><span class="line">        15: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"ClassCreateProcessTest.java"</span></span><br><span class="line">binglau<span class="meta">@BingLaudeMBP</span> ~/c/c/J/basic&gt;</span><br></pre></td></tr></table></figure><p>static的方法其实是<code>&lt;clinit&gt;</code>方法，在 <code>&lt;init&gt;</code> 也就是实例化之前执行，所有 先 new B 然后这边调用  #7 并 ldc 也就是其中的 static {} 方法中的 sout 执行 打印出  String A created，此时还没有对 A 进行初始化，A 初始化时候创建了 C。</p><p>所以 B 是在 3 时候创建的，C 是在 5 创建的，A 是在 5之后创建完成的。</p><h3 id="可能出现-StackOverflowError-处"><a href="#可能出现-StackOverflowError-处" class="headerlink" title="可能出现 StackOverflowError 处"></a>可能出现 StackOverflowError 处</h3><h4 id="虚拟机（本地方法）栈中出现："><a href="#虚拟机（本地方法）栈中出现：" class="headerlink" title="虚拟机（本地方法）栈中出现："></a>虚拟机（本地方法）栈中出现：</h4><ul><li>线程请求的栈深度大于虚拟机所允许的深度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 虚拟机栈和本地方法栈溢出</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss128k </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        stackLength++;  </span><br><span class="line">        stackLeak();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;  </span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            oom.stackLeak();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + oom.stackLength);  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可能出现-OutOfMemoryError-处"><a href="#可能出现-OutOfMemoryError-处" class="headerlink" title="可能出现 OutOfMemoryError 处"></a>可能出现 OutOfMemoryError 处</h3><h4 id="虚拟机（本地方法）栈中出现：-1"><a href="#虚拟机（本地方法）栈中出现：-1" class="headerlink" title="虚拟机（本地方法）栈中出现："></a>虚拟机（本地方法）栈中出现：</h4><ul><li>如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存（实验不出来，如果是不断创建线程可以，但是这与栈空间十分足够大不存在关系，而是与操作系统对进程分配内存限制有关。）</li></ul><h4 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h4><ul><li>在堆中没有内存完成实例分配，并且堆也无法再扩展时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Java堆用于存储对象实例，我们只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免GC清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常。</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OOMObject</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();  </span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;  </span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject(<span class="string">"IpConfig..."</span> + i++));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法区-amp-运行时常量池"><a href="#方法区-amp-运行时常量池" class="headerlink" title="方法区 &amp; 运行时常量池"></a>方法区 &amp; 运行时常量池</h4><ul><li>无法满足内存分配需求</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 方法区、运行时常量池溢出</span></span><br><span class="line"><span class="comment"> * 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述符、方法描述等。对于这个区域的测试，</span></span><br><span class="line"><span class="comment"> * 基本的思路是运行时产生大量的类去填满方法区，直到溢出。比如动态代理会生成动态类。</span></span><br><span class="line"><span class="comment"> * 运行时常量池分配在方法区内，可以通过 -XX:PermSize和 -XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 使用List保持着常量池引用，避免Full GC回收常量池行为  </span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了  </span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">            list.add(String.valueOf(i++).intern());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接内存："><a href="#直接内存：" class="headerlink" title="直接内存："></a>直接内存：</h4><ul><li>本机内存限制，这个调整  <code>-Xmx</code> 也没用，直接内存动态扩展时出现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值-Xmx指定一样。</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];  </span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;  </span><br><span class="line">            unsafe.allocateMemory(_1MB);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OOM-时-dump-日志"><a href="#OOM-时-dump-日志" class="headerlink" title="OOM 时 dump 日志"></a>OOM 时 dump 日志</h4><p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p><h3 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h3><p>《深入理解 Java 虚拟机》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;图示各区用途&quot;&gt;&lt;a href=&quot;#图示各区用途&quot; class=&quot;headerlink&quot; title=&quot;图示各区用途&quot;&gt;&lt;/a&gt;图示各区用途&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/BingLau7/blog/blob/master/images/blog_27/1.png?raw=true&quot; alt=&quot;内存区域图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础原理" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
</feed>
